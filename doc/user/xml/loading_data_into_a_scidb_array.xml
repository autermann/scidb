<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter remap="h1">
  <title>Loading Data into a SciDB Array</title>
  <para>The load, save, input and substitute commands are used while loading and unloading data from SciDB into external load files in ASCII format.</para>
  <sect1>
    <title>The LOAD Statement</title>
    <para>The AQL LOAD statement loads formatted data into an existing SciDB array. The syntax of the LOAD statement is:<programlisting>LOAD <replaceable>array_name</replaceable> FROM <replaceable>load_file_path </replaceable>;</programlisting>The <replaceable>array_name</replaceable> argument is the SciDB array into which the data will be loaded. The <replaceable>load_file_path </replaceable> argument is the file path of the formatted data to be loaded.</para>
    <para>Your data file must be formatted so that the chunks are loaded in the correct order. For example, if you have a  16-by-16 array  divided into ordered 4-by-4 chunks, you will need to order the data in the load file appropriately. Chunks in the SciDB array are ordered as follows:<programlisting>C11 C12 C13 C14
C21 C22 C23 C24
C31 C32 C33 C34
C41 C42 C43 C44</programlisting>So the chunks in the load file must appear in the following order:<programlisting>C11; C12; C13; C14; C21; C22; ...; C41; C42; C43; C44</programlisting></para>
  </sect1>
  <sect1>
    <title>Data Generation</title>
    <para>SciDB provides functions for data generation. The simplest way to add data to an  array with one attribute is the <code>build</code> operator and a SciDB expression. </para>
    <para>For example, to store numerical values of 1 to 10 in an array with one attribute and one dimension of size 10, you can do the following:<programlisting>AQL% <command>CREATE ARRAY</command> consecutive_integers 
&lt;val:int64&gt;
[x=0:9,10,0];
AQL% <command>SELECT</command> * <command>INTO</command> consecutive_integers <command>FROM</command> 
build(consecutive_integers, x+1);</programlisting>This code takes the index values <emphasis>x</emphasis> from array consecutive_integers and uses them in the expression <emphasis>x</emphasis>&nbsp;+&nbsp;1. The <code>build</code> command then executes the expression. This puts the following numbers into the attribute <code>val</code>:<screen>[(1),(2),(3),(4),(5),(6),(7),(8),(9),(10)]</screen></para>
    <para>You can create additional array attributes and additional data with the <code>apply</code> function. For example, this statement generates an additional attribute name <code>val2</code> with value <code>val</code>+100:<programlisting>AQL% <command>SELECT</command> * <command>FROM</command> apply(consecutive_integers,val2,val+100);</programlisting><screen>[(1,101),(2,102),(3,103),(4,104),(5,105),
(6,106),(7,107),(8,108),(9,109),(10,110)]</screen></para>
    <para>You can also create new arrays with the generated data by using the <code>
        <command>INTO</command>
      </code> clause. For example, this statement creates an array called <code>random_numbers</code> with an one attribute copied from <code>consecutive_numbers</code> attribute <code>val</code> and one attribute <code>val_rand</code> containing random numbers:<programlisting>AQL% <command>SELECT</command> * <command>INTO</command> random_numbers <command> FROM</command> 
apply(consecutive_integers,val_rand,val*random());</programlisting><screen>[(1,1687457050),(2,486200554),(3,341466474),
(4,2037600252),(5,5420696925),(6,1547216142),
(7,12796206535),(8,136216624),(9,16958580471),
(10,10628809700)]</screen></para>
    <para>If you want to build an array on data you have already generated, you can use the <code>xgrid</code> command to expand an existing array. The <code>xgrid</code> command expands an array by repeating elements from that array. For example, suppose you have a 3-by-3 array:<programlisting>AFL% show(m3x3);scan(m3x3);
[(&quot;m3x3&lt;val:double &gt; [x=0:2,3,0,y=0:2,3,0]&quot;)]
[
[(1),(2),(3)],
[(4),(5),(6)],
[(7),(8),(9)]
]</programlisting>You can make individual elements of this array into <emphasis>n</emphasis>-by-<emphasis>n</emphasis> grids. To make each cell into a 2-by-2 grid, use the following syntax:<programlisting>AFL% xgrid(m3x3,2,2);
[
[(1),(1),(2),(2),(3),(3)],
[(1),(1),(2),(2),(3),(3)],
[(4),(4),(5),(5),(6),(6)],
[(4),(4),(5),(5),(6),(6)],
[(7),(7),(8),(8),(9),(9)],
[(7),(7),(8),(8),(9),(9)]
]</programlisting></para>
  </sect1>
  <sect1>
    <title>Redimensioning an Array</title>
    <para>A common use case for creating and loading SciDB arrays is using data from a  data warehouse. This data set may be very large and formatted as a csv file. You can use the csv2scidb utility to convert a csv file to the 1-dimensional array format and load the file into a SciDB array. Once you have a 1-dimensional SciDB array, you can redimension the array to convert the attributes to dimensions.</para>
    <para>For example, suppose you have a csv file like this:<programlisting>s,p,val
&quot;sample-0&quot;,&quot;probe-0&quot;,0.01
&quot;sample-1&quot;,&quot;probe-0&quot;,2.04
&quot;sample-2&quot;,&quot;probe-0&quot;,6.09
&quot;sample-3&quot;,&quot;probe-0&quot;,12.16
&quot;sample-4&quot;,&quot;probe-0&quot;,20.25
&quot;sample-0&quot;,&quot;probe-1&quot;,30.36
&quot;sample-1&quot;,&quot;probe-1&quot;,42.49
&quot;sample-2&quot;,&quot;probe-1&quot;,56.64
&quot;sample-3&quot;,&quot;probe-1&quot;,72.81
&quot;sample-4&quot;,&quot;probe-1&quot;,91
&quot;sample-0&quot;,&quot;probe-2&quot;,111.21
&quot;sample-1&quot;,&quot;probe-2&quot;,133.44
&quot;sample-2&quot;,&quot;probe-2&quot;,157.69
&quot;sample-3&quot;,&quot;probe-2&quot;,183.96
&quot;sample-4&quot;,&quot;probe-2&quot;,212.25
&quot;sample-0&quot;,&quot;probe-3&quot;,242.56
&quot;sample-1&quot;,&quot;probe-3&quot;,274.89
&quot;sample-2&quot;,&quot;probe-3&quot;,309.24
&quot;sample-3&quot;,&quot;probe-3&quot;,345.61
&quot;sample-4&quot;,&quot;probe-3&quot;,384
&quot;sample-0&quot;,&quot;probe-4&quot;,424.41
&quot;sample-1&quot;,&quot;probe-4&quot;,466.84
&quot;sample-2&quot;,&quot;probe-4&quot;,511.29
&quot;sample-3&quot;,&quot;probe-4&quot;,557.76
&quot;sample-4&quot;,&quot;probe-4&quot;,606.25</programlisting>This data has three columns, two of which are stings and one which is a floating-point number. The column headers are &apos;s&apos;,&apos;p&apos;,and &apos;val&apos;.  To load this data set, create a 1-dimensional SciDB array with three attributes and load the data into it. For this example, the array is named expo. The dimension name is i, the dimension size is 25, the chunk size is 5. The attributes are s, of type string, p of type string, and val of type double.<programlisting>SELECT * FROM show(expo);</programlisting><screen>[(&quot;expo&lt;s:string NOT NULL,p:string,
val:double&gt; [i=1:25,5,0]&quot;)]</screen></para>
    <para>When you examine the data, notice that it could be expressed in a 2-dimensional format like this:<informaltable frame="all">
        <tgroup cols="6">
          <colspec colname="c1"/>
          <colspec colname="cgen1"/>
          <colspec colname="c2"/>
          <colspec colname="c3"/>
          <colspec colname="c4"/>
          <colspec colname="c5"/>
          <tbody>
            <row>
              <entry/>
              <entry>probe-0</entry>
              <entry>probe-1</entry>
              <entry>probe-2</entry>
              <entry>probe-3</entry>
              <entry>probe-4</entry>
            </row>
            <row>
              <entry>sample-0</entry>
              <entry>0.01</entry>
              <entry>30.36</entry>
              <entry>111.21</entry>
              <entry>242.56</entry>
              <entry>424.41</entry>
            </row>
            <row>
              <entry>sample-1</entry>
              <entry>2.04</entry>
              <entry>42.49</entry>
              <entry>133.44</entry>
              <entry>274.89</entry>
              <entry>466.84</entry>
            </row>
            <row>
              <entry>sample-2</entry>
              <entry>6.09</entry>
              <entry>56.64</entry>
              <entry>157.69</entry>
              <entry>309.24</entry>
              <entry>511.29</entry>
            </row>
            <row>
              <entry>sample-3</entry>
              <entry>12.16</entry>
              <entry>72.81</entry>
              <entry>183.96</entry>
              <entry>345.61</entry>
              <entry>557.76</entry>
            </row>
            <row>
              <entry>sample-4</entry>
              <entry>20.25</entry>
              <entry>91</entry>
              <entry>212.25</entry>
              <entry>384</entry>
              <entry>606.25</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>SciDB allows you to redimension the data so that you can store it in this 2-dimensional format. First, create an array with 2 dimensions:<programlisting>AFL% create empty array Dsp
&lt;val:double&gt;
[s(string)=5,5,0, p(string)=5,5,0];</programlisting>Each of the dimensions is of size 5, corresponding to a dimension in the 5-by-5 table. Now, you can use the redimension_store operator to redimension the array expo into the array Dsp:<programlisting>AFL% redimension_store(expo, Dsp);</programlisting><screen>[
[(0.01),(30.36),(111.21),(242.56),(424.41)],
[(2.04),(42.49),(133.44),(274.89),(466.84)],
[(6.09),(56.64),(157.69),(309.24),(511.29)],
[(12.16),(72.81),(183.96),(345.61),(557.76)],
[(20.25),(91),(212.25),(384),(606.25)]
]</screen>Now the data is stored so that sample and probe numbers are the dimensions of the array. This means that you can use the dimension indices to select data from the array. For example, to select the second sample from the third probe, use the dimension indices:<programlisting>AQL% <command>SELECT</command> val <command>FROM</command> Dsp <command> WHERE</command> s=&apos;sample-2&apos; and p=&apos;probe-3&apos;;</programlisting></para>
    <para>Redimensioning is a powerful tool when you want to do array aggregation along the coordinate axes of a data set. For example, you can find the average value of a sample for each probe. This would be  equivalent to finding the average of every row in the table:<programlisting>create empty array Ds
&lt;av:double NULL&gt;[s(string)=5,5,0];
redimension_store(expo, Ds, true, avg(val) as av);</programlisting>Or, you can find the average value of all the samples for a single probe. This would be equivalent to finding the average of every column in the table:<programlisting>AFL% create empty array Dp
&lt;av:double NULL&gt;[p(string)=5,5,0];
AFL% redimension_store(expo, Dp, true, avg(val) as av);
</programlisting></para>
  </sect1>
  <sect1 remap="h2">
    <title>load</title>
    <para>SciDB supports the load operator for loading data into an existing SciDB array.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>load (<emphasis>array_name : array_identifier</emphasis>,<emphasis> data_file : string</emphasis> [,<emphasis> nodeid : int</emphasis>] )</para>
    <para><emphasis>array_name</emphasis> is the array to be loaded.<emphasis> data_file</emphasis> is the path to a file to use -- absolute or relative to the working directory of the SciDB server. For a description of<emphasis> nodeid</emphasis>, see below section on parallel load.</para>
    <para>SciDB data load files must be organized according to the schema of the target array.</para>
    <para>Given an array defined as follows:</para>
    <screen>CREATE ARRAY Load_Example &lt; Val: int32 &gt; [X=1:100,25,0, Y=1:100,25,0]</screen>
    <para>Load files divide the data to be loaded into chunks. Load file chunks correspond to array chunks as defined by the CREATE ARRAY statement. So, for the example 2-dimensional array with the following chunk layout</para>
    <screen>C11 C12 C13 C14
C21 C22 C23 C24
C31 C32 C33 C34
C41 C42 C43 C44</screen>
    <para>The<emphasis> chunks</emphasis> in the load file must appear in the following order:</para>
    <screen>C11; C12; C13; C14; C21; C22; ...; C41; C42; C43; C44</screen>
    <para>Each chunk may also be prefixed with an optional chunk header that lists the dimension values of the starting element in that chunk. If this chunk header is not present, the file is assumed to contain all of the chunks in the order described above.</para>
    <sect2 remap="h3">
      <title>Load formats</title>
      <para>SciDB supports two chunk formats in load files corresponding to<emphasis> dense</emphasis> and<emphasis> sparse</emphasis> data sets. The sparse format is more efficient when a majority of the cells in the array are absent and do not contain attribute data. A SciDB array loaded from a data file that has the sparse load format generates sparse chunks in array storage, whereas one loaded from a dense file format creates chunks that use the dense storage format.</para>
    </sect2>
    <sect2 remap="h3">
      <title>Dense load format</title>
      <para>In the following example we illustrate how a multi-chunk, dense array is created and loaded.</para>
      <screen>CREATE ARRAY Two_Dim&lt;a: int32, c: char&gt;[I=0:7,4,0, J=0:7,4,0]
load(Two_Dim, &apos;/tmp/2d-mc.txt&apos;)</screen>
      <para>In the dense representation, the dimension values for each cell are implicit in the representation. Data is divided up into chunks, with each chunk enclosed within a &apos;[ ]&apos; and separated by a semi-colon.</para>
      <para>Cells within each chunk must appear in<emphasis> left to right</emphasis> dimension order (e.g., row-major order for a two-dimensional array, or generalized appropriately to higher dimensions). Each cell contains a comma-separated list of attribute values placed within (). This &apos;dense&apos; representation can denote empty cells using &apos;()&apos;.</para>
      <para>Contents of /tmp/2d-mc.txt:</para>
      <screen>[
[ (0, &apos;A&apos;), (1, &apos;B&apos;), (2, &apos;C&apos;), (3, &apos;D&apos;)],
[ (8, &apos;I&apos;), (9, &apos;J&apos;), (10, &apos;K&apos;), (11, &apos;L&apos;)],
[ (16, &apos;Q&apos;), (17, &apos;R&apos;), (18, &apos;S&apos;), (19, &apos;T&apos;)],
[ (24, &apos;Y&apos;), (25, &apos;Z&apos;), (26, &apos;A&apos;), (27, &apos;B&apos;)]
];
[
[ (4, &apos;E&apos;), (5, &apos;F&apos;), (6, &apos;G&apos;), (7, &apos;H&apos;)],
[ (12, &apos;M&apos;), (13, &apos;N&apos;), (14, &apos;O&apos;), (15, &apos;P&apos;)],
[ (20, &apos;U&apos;), (21, &apos;V&apos;), (22, &apos;W&apos;), (23, &apos;X&apos;)],
[ (28, &apos;C&apos;), (29, &apos;D&apos;), (30, &apos;E&apos;), (31, &apos;F&apos;)]
];
[
[ (32, &apos;G&apos;), (33, &apos;H&apos;), (34, &apos;I&apos;), (35, &apos;J&apos;)],
[ (40, &apos;O&apos;), (41, &apos;P&apos;), (42, &apos;Q&apos;), (43, &apos;R&apos;)],
[ (48, &apos;W&apos;), (49, &apos;X&apos;), (50, &apos;Y&apos;), (51, &apos;Z&apos;)],
[ (56, &apos;E&apos;), (57, &apos;F&apos;), (58, &apos;G&apos;), (59, &apos;H&apos;)]
];
[
[ (36, &apos;K&apos;), (37, &apos;L&apos;), (38, &apos;M&apos;), (39, &apos;N&apos;)],
[ (44, &apos;S&apos;), (45, &apos;T&apos;), (46, &apos;U&apos;), (47, &apos;V&apos;)],
[ (52, &apos;A&apos;), (53, &apos;B&apos;), (54, &apos;C&apos;), (55, &apos;D&apos;)],
[ (60, &apos;I&apos;), (61, &apos;J&apos;), (62, &apos;K&apos;), (63, &apos;L&apos;)]
]</screen>
      <para>For the simpler case of a one-dimensional array, the dense load file format looks like this:</para>
      <screen>[ (36, &apos;K&apos;), (37, &apos;L&apos;), (38, &apos;M&apos;), (39, &apos;N&apos;)]; 
[ (44, &apos;S&apos;), (45, &apos;T&apos;), (46, &apos;U&apos;), (47, &apos;V&apos;)];
[ (52, &apos;A&apos;), (53, &apos;B&apos;), (54, &apos;C&apos;), (55, &apos;D&apos;)];
[ (60, &apos;I&apos;), (61, &apos;J&apos;), (62, &apos;K&apos;), (63, &apos;L&apos;)] </screen>
    </sect2>
    <sect2 remap="h3">
      <title>Sparse load format</title>
      <para>The sparse load format allows a large number of cells can be unspecified.</para>
      <para>The sparse load format lists the data by chunks--there is a semi-colon between the chunks--and within each chunk the data is organized as a list of comma-separated cells, where each cell includes the coordinates and the attributes of the cell.</para>
      <para>For example:</para>
      <screen>create array sparse_example&lt;a:double&gt; [x=0:8,2,0,y=0:3,2,0];</screen>
      <para>This array is a 2-D array contained within several 2x2 chunks. The following is an example file &apos;/tmp/sparse_load.txt&apos;:</para>
      <screen>cat  /tmp/sparse_load.txt
[[ 
{0,0} (11)
{1,0} (21)
{0,1} (12)
]];
[[ 
{0,2} (13)
]];
[[ 
{2,0} (31)
{3,0} (41)
{2,1} (32)
{3,1} (42)
]];
[[ 
{2,2} (33)
{3,3} (44)
]];
[[ 
{7,0} (81)
{6,1} (72)
{7,1} (82)
]];
[[ 
{6,2} (73)
{7,2} (83)
{7,3} (84)
]];
[[ 
{8,0} (91)
]];
[[ 
{8,2} (93)
{8,3} (94)
]]</screen>
      <para>You would use the following load syntax to load this file into the <literal condition="western">sparse_example</literal> array:</para>
      <screen>load(sparse_example, &apos;/tmp/sparse_load.txt&apos;);</screen>
      <para><emphasis role="bold">Notes:</emphasis></para>
      <orderedlist>
        <listitem>
          <para> The last chunk in the load file should<emphasis role="bold"> not</emphasis> have a &apos;;&apos; chunk delimiter. </para>
        </listitem>
        <listitem>
          <para> The SciDB loader ignores additional newline or space characters in the load file. </para>
        </listitem>
        <listitem>
          <para> Choosing a particular load file format has no bearing on how data is stored internally in SciDB. </para>
        </listitem>
        <listitem>
          <para> In addition to storing the data, load and store operators also return the data back to the client (or next operator in the query). When the data is voluminous, this may not be desired and the output of the query should be suppressed. For instance, the iquery executable that accompanies SciDB includes the &quot;-n&quot; option for this purpose. </para>
        </listitem>
        <listitem>
          <para> Note that unspecified cells can have various interpretations, depending on how the array is declared. See the section on empty arrays. </para>
        </listitem>
      </orderedlist>
    </sect2>
    <sect2 remap="h3">
      <title>Optimizing Chunk Size to Load Format</title>
      <para>The size and density of the load file determines the optimum chunk size for its storage array. Chunks should contain on order of 500,000 elements. The number of bits in an element also affects the optimum chunk size. Chunks that have long strings (greater than 30 characters) may need to set the chunk size to less than 500,000 elements for optimum performance.</para>
    </sect2>
    <sect2 remap="h3">
      <title>Datatype Support</title>
      <para>SciDB supports the following datatypes for attributes and dimensions. Not all SciDB functions support all datatypes. To see if a function supports a particular datatype, use the <literal condition="western">list(&apos;functions&apos;)</literal> operator.</para>
      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <tbody>
            <row>
              <entry>
                <para><emphasis role="bold">Data type</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> binary</para>
              </entry>
              <entry>
                <para> Machine-readable binary file</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> bool</para>
              </entry>
              <entry>
                <para> Boolean TRUE (1) or FALSE (0)</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> char</para>
              </entry>
              <entry>
                <para> Single-character</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> datetime</para>
              </entry>
              <entry>
                <para> Date and time</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> datetimetz</para>
              </entry>
              <entry>
                <para> Timezone</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> double</para>
              </entry>
              <entry>
                <para> Double precision decimal</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> float</para>
              </entry>
              <entry>
                <para> Floating-point number</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> indicator</para>
              </entry>
              <entry>
                <para> Datatype indicator</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> int8</para>
              </entry>
              <entry>
                <para> Signed 8-bit integer</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> int16</para>
              </entry>
              <entry>
                <para> Signed 16-bit integer</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> int32</para>
              </entry>
              <entry>
                <para> Signed 32-bit integer</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> int64</para>
              </entry>
              <entry>
                <para> Signed 64-bit integer</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> string</para>
              </entry>
              <entry>
                <para> Character string</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> uint8</para>
              </entry>
              <entry>
                <para> Unsigned 8-bit integer</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> uint16</para>
              </entry>
              <entry>
                <para> Unsigned 16-bit integer</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> uint32</para>
              </entry>
              <entry>
                <para> Unsigned 32-bit integer</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> uint64</para>
              </entry>
              <entry>
                <para> Unsigned 64-bit integer</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> void</para>
              </entry>
              <entry>
                <para> Return nothing</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <sect3 remap="h4">
        <title>Date and Time Offsets</title>
        <para>SciDB offers timestamp datatypes so that you can customize date and time formats:</para>
        <screen>create array time_and_date &lt;mytime:datetime&gt;[i=0:0,1,0];
store(build(time_and_date,now()),time_and_date);
[(&quot;2011-12-13 18:41:14&quot;)]</screen>
        <para>The time zone data type uses offsets indicating a relative time to the date and time to The <literal condition="western">datetimetz</literal> formats are:</para>
        <screen>YYYY/MM/DD hh:mm:ss +/-hh:mm
DD.MM.YYYY hh:mm::ss +/-hh:mm
YYYY-MM-DD hh:mm:ss.fff +/-hh:mm
YYYY-MM-DD hh.mm.ss.fff +/-hh:mm</screen>
        <para>You can cast datetime to datetimetz by appending an offset:</para>
        <screen>apply(time_and_date,dst,append_offset(mytime,3600));
[(&quot;2011-12-13 18:41:14&quot;,&quot;2011-12-13 19:41:14 +01:00&quot;)]</screen>
        <para>To append an offset and apply it to the time, use apply_offset:</para>
        <screen>create array timedate_and_timezone &lt;mytime:datetime, myzone:datetimetz&gt;[i=0:1\
,1,0];
store(apply(time_and_date,myzone,apply_offset(mytime,3600)),timedate_and_ti\
mezone);
[(&quot;2011-12-13 18:41:14&quot;,&quot;2011-12-13 19:41:14 +01:00&quot;)]</screen>
        <para>To cast a datetimetz to datetime, use the strip_offset function:</para>
        <screen>apply(timedate_and_timezone,dst,strip_offset(myzone));
[(&quot;2011-12-13 18:41:14&quot;,
&quot;2011-12-13 19:41:14 +01:00&quot;,
&quot;2011-12-13 19:41:14&quot;)]</screen>
        <para>To remove offsets applied to a datetime and cast to datetime, use the togmt function:</para>
        <screen>apply(timedate_and_timezone,dst,togmt(myzone));
[(&quot;2011-12-13 18:41:14&quot;,
&quot;2011-12-13 19:41:14 +01:00&quot;,
&quot;2011-12-13 18:41:14&quot;)]</screen>
        <para>To return just the offset from a datetimetz, use the get_offset function:</para>
        <screen>apply(timedate_and_timezone,seconds,get_offset(myzone));
[(&quot;2011-12-13 18:41:14&quot;,
&quot;2011-12-13 19:41:14 +01:00&quot;,
3600)]</screen>
        <para>To return the current time with the current offset, use the tznow function:</para>
        <screen>apply(timedate_and_timezone,est,tznow());
[(&quot;2011-12-13 18:41:14&quot;, 
&quot;2011-12-13 19:41:14 +01:00&quot;,
&quot;2011-12-13 17:07:59 -05:00&quot;)]</screen>
        <para>You can compare timestamps with the relational operators =, &lt;&gt;, &gt; , &lt;, &lt;=, &gt;=. SciDB compares times after the offset is applied. So &quot;2010-10-10, 13:00:00 +1:00&quot; is equal to &quot;2010-10-10, 12:00:00 +0:00&quot;.</para>
      </sect3>
    </sect2>
    <sect2 remap="h3">
      <title>Missing Data</title>
      <para>Suppose you have a numerical data set that is missing some values:</para>
      <screen>less m4x4_missing.txt
[
[(0,100),(1,99),(2,98),(3,97)],
[(4),(5,95),(6,94),(7,93)],
[(8,92),(9,91),(),(11,89)],
[(12,88),(13),(14,86),(15,85)]
]</screen>
      <para>The array m4x4_missing has two issues: the second values in the cells (1,0) and (3,1) are missing, and cell (2,2) is completely empty. You can tell SciDB how you want to handle the missing data with various array options.</para>
      <para>First, consider the case of the completely empty cell, (2,2). By default, SciDB will add zeros to empty cells. If you want SciDB to substitute zeros in all empty cells at load time, create the array with the desired numerical data attributes and load the data set:</para>
      <screen>create array m4x4_missing &lt;val1:double,val2:int32&gt;[x=0:3,4,0,y=0:3,4,0]; 
load(m4x4_missing,&apos;/tmp/m4x4_missing.txt&apos;); 

[ 
[(0,100),(1,99),(2,98),(3,97)],
[(4,0),(5,95),(6,94),(7,93)], 
[(8,92),(9,91),(0,0),(11,89)],
[(12,88),(13,0),(14,86),(15,85)] 
] </screen>
      <para>This means that cell (2,2) has values (0,0). If the missing data is a string, it will be replaced with an empty string:</para>
      <screen>remove(m4x4_missing); 
create array m4x4_missing &lt;val1:string,val2:string&gt; [x=0:3,4,0,y=0:3,4,0]; 
load(m4x4_missing,
&apos;/tmp/m4x4_missing&apos;); 

[
[(&quot;0&quot;,&quot;100&quot;),(&quot;1&quot;,&quot;99&quot;),(&quot;2&quot;,&quot;98&quot;),(&quot;3&quot;,&quot;97&quot;)],
[(&quot;4&quot;,&quot;&quot;),(&quot;5&quot;,&quot;95&quot;),(&quot;6&quot;,&quot;94&quot;),(&quot;7&quot;,&quot;93&quot;)],
[(&quot;8&quot;,&quot;92&quot;),(&quot;9&quot;,&quot;91&quot;),(&quot;&quot;,&quot;&quot;),(&quot;11&quot;,&quot;89&quot;)],
[(&quot;12&quot;,&quot;88&quot;),(&quot;13&quot;,&quot;&quot;),(&quot;14&quot;,&quot;86&quot;),(&quot;15&quot;,&quot;85&quot;)] 
] </screen>
      <para>To change the default value, that is, the value the SciDB subtitutes for the missing data, set the default clause of the attribute option:</para>
      <screen>create array m4x4_missing &lt;val1:double default=3.14159,val2:int32 default 54\
68&gt;[x=0:3,4,0,y=0:3,4,0];</screen>
      <para>If you want to preserve missing data as empty cells, use the <literal condition="western">empty</literal> option for the create array statement:</para>
      <screen>remove(m4x4_missing);
create empty array m4x4_missing &lt;val1:double,val2:int32&gt; [x=0:3,4,0,y=0:3,4,0\
];
load(m4x4_missing, &apos;/tmp/m4x4_missing&apos;);

[
[(0,100),(1,99),(2,98),(3,97)],
[(4,0),(5,95),(6,94),(7,93)],
[(8,92),(9,91),(),(11,89)],
[(12,88),(13,0),(14,86),(15,85)]
]
remove(m4x4_missing);
create empty array m4x4_missing &lt;val1:string,val2:string&gt; [x=0:3,4,0,y=0:3,4,\
0];
load(m4x4_missing, &apos;/tmp/m4x4_missing&apos;);

[
[(&quot;0&quot;,&quot;100&quot;),(&quot;1&quot;,&quot;99&quot;),(&quot;2&quot;,&quot;98&quot;),(&quot;3&quot;,&quot;97&quot;)],
[(&quot;4&quot;,&quot;&quot;),(&quot;5&quot;,&quot;95&quot;),(&quot;6&quot;,&quot;94&quot;),(&quot;7&quot;,&quot;93&quot;)],
[(&quot;8&quot;,&quot;92&quot;),(&quot;9&quot;,&quot;91&quot;),(),(&quot;11&quot;,&quot;89&quot;)],
[(&quot;12&quot;,&quot;88&quot;),(&quot;13&quot;,&quot;&quot;),(&quot;14&quot;,&quot;86&quot;),(&quot;15&quot;,&quot;85&quot;)]
]</screen>
      <para>In this case, cell (2,2) is left empty.</para>
      <para>In addition to completely empty cells, SciDB arrays can handle individual missing attribute values within nonempty cells. To substitute 0 for missing numerical attribute values, create the array and load the data:</para>
      <screen>remove(m4x4_missing);
create array m4x4_missing &lt;val1:double,val2:int32&gt;[x=0:3,4,0,y=0:3,4,0]; 
load(m4x4_missing,&apos;/tmp/m4x4_missing&apos;); 

[ 
[(0,100),(1,99),(2,98),(3,97)],
[(4,0),(5,95),(6,94),(7,93)], 
[(8,92),(9,91),(0,0),(11,89)],
[(12,88),(13,0),(14,86),(15,85)] 
] </screen>
      <para>In the above array, the val2 of cell (1,0) and cell (3,1) are set to 0 during the load process. To set the value to NULL, set the NULL flag of the attribute:</para>
      <screen>remove(m4x4_missing);
create array m4x4_missing &lt;val1:double null,val2:int32 null&gt; [x=0:3,4,0,y=0:3\
,4,0];
load(m4x4_missing,&apos;/tmp/m4x4_missing&apos;); 

[[(0,100),(1,99),(2,98),(3,97)],
[(4,null),(5,95),(6,94),(7,93)],
[(8,92),(9,91),(),(11,89)],
[(12,88),(13,null),(14,86),(15,85)]]</screen>
      <para>Missing data may also be specified with NA. For example,</para>
      <screen>less /tmp/na_test.txt

[
[(NA,100),(1,99),(2,98),(3,97)],
[(4,5),(5,95),(6,94),(7,93)],
[(8,92),(9,91),(12,12),(11,89)],
[(12,88),(7,13),(14,86),(15,85)]
]
create array na_test &lt;val1:double default 3.14159, val2:double default 3.141\
59&gt; [x=0:3,4,0, y=0:3,4,0];
load(na_test,&apos;/tmp/na_test.txt&apos;);

[
[(NA,100),(1,99),(2,98),(3,97)],
[(4,5),(5,95),(6,94),(7,93)],
[(8,92),(9,91),(12,12),(11,89)],
[(12,88),(7,13),(14,86),(15,85)]
]</screen>
      <para>NA may appear in cells that are missing values. NA will not be replaced with the default value at load.</para>
      <screen>less /tmp/na_test_missing.txt

[
[(NA,100),(1,99),(2,98),(3,97)],
[(,NA),(5,95),(6,94),(7,93)],
[(NA,),(9,91),(12,12),(11,89)],
[(NA),(7,13),(14,86),(15,85)]
]

load(na_test,&apos;/tmp/na_test_missing.txt&apos;);

[
[(NA,100),(1,99),(2,98),(3,97)],
[(3.14159,NA),(5,95),(6,94),(7,93)],
[(NA,3.14159),(9,91),(12,12),(11,89)],
[(NA,3.14159),(7,13),(14,86),(15,85)]
]</screen>
      <para>If you apply a function to a SciDB attribute that is NA SciDB will return NA:</para>
      <screen>apply(na_test_missing,val3,sin(val1));

[
[(NA,100,NA),(1,99,0.841471),(2,98,0.909297),(3,97,0.14112)],
[(3.14159,NA,2.65359e-06),(5,95,-0.958924),(6,94,-0.279415),(7,93,0.656987)\
],
[(NA,3.14159,NA),(9,91,0.412118),(12,12,-0.536573),(11,89,-0.99999)],
[(NA,3.14159,NA),(7,13,0.656987),(14,86,0.990607),(15,85,0.650288)]
]</screen>
      <para>See the next section, &quot;Null attribute format&quot; for more information on NULL attributes and default clauses.</para>
    </sect2>
    <sect2 remap="h3">
      <title>NULL attribute format</title>
      <para>Both the dense and sparse array formats can include special codes for NULL attributes. For example, if a faulty instrument occasionally fails to report a reading, that attribute could be represented in a SciDB array as NULL. If an erroneous instrument reports readings that are out of valid bounds for an attribute, that may also be represented as NULL.</para>
      <para>NULL must be represented using the token &apos;null&apos; or &apos;?&apos; in place of the attribute value.</para>
      <para>In addition, NULL values can be tagged with a &quot;missing reason code&quot; to help a SciDB application distinguish among different types of null values -- for example, assigning a unique code to the following types of errors: &quot;instrument error&quot;, &quot;cloud cover&quot;, or &quot;not enough data for statistically significant result&quot;. Or, in the case of financial market data, data may be missing because &quot;market closed&quot;, &quot;trading halted&quot;, or &quot;data feed down&quot;.</para>
      <para>Missing reason codes allow an application to optionally treat each kind of null as a special case, e.g. to supply or calculate a context-sensitive default value.</para>
      <para>The examples below show how to represent missing data in the load file.<emphasis> ?</emphasis> or<emphasis> null</emphasis> represent null values, and<emphasis> ?2</emphasis> represents null value with a reason code of<emphasis> 2</emphasis>.</para>
      <screen>[[ ( 10, 4.5, &quot;My String&quot;, &apos;C&apos;), (10, 5.1, ?1, &apos;D&apos;), (?2, 5.1, &quot;Another String&quot;\
, ?) ...</screen>
      <para>or</para>
      <screen>[[ ( 10, 4.5, &quot;My String&quot;, &apos;C&apos;), (10, 5.1, ?1, &apos;D&apos;), (?2, 5.1, &quot;Another String&quot;\
, null) ...</screen>
      <para>The <literal condition="western">substitute</literal> operator described later in this chapter can be used to replace missing values with user-defined values looked up from another SciDB array. </para>
      <para>The default clause of the NULL flag allows you to set a custom value for missing data:</para>
      <screen>less /tmp/default_value.txt
[(1),(),(3)]
create array D &lt;a:int32 null default 7&gt; [x=0:2,3,0];
load(D,&apos;/tmp/default_value.txt&apos;);
[(1),(7),(3)]</screen>
      <para>You can set the default value to value that is legal in the datatype of the attribute. You can also use a function.</para>
      <screen>remove(D);
create array D &lt;a: double default sin(3*3.14/2)&gt; [x=0:2,3,0];
load(D,&apos;/tmp/default_value.txt);
[(1),(-0.999997),(3)]</screen>
    </sect2>
    <sect2 remap="h3">
      <title>Loading an unbounded array</title>
      <para>An unbounded array is one declared to have one or more unbounded dimensions. With an unbounded dimension there is no declared limit on the<emphasis> high</emphasis> value. SciDB allows an array to be expanded along unbounded dimensions and new chunks can be appended to an unbounded array after the initial load beyond the current maximum size of the dimension.</para>
      <screen>CREATE ARRAY open_array &lt;a:int64&gt;[x=0:*,5,0]</screen>
      <para>Load data in three phases into<emphasis> open_array</emphasis> described in the create statement above.</para>
      <screen>load(open_array, &apos;/tmp/load_1.txt&apos;)
load(open_array, &apos;/tmp/load_2.txt&apos;)
load(open_array, &apos;/tmp/load_3.txt&apos;)</screen>
      <para>The load files are shown below and described in more detail in the sections on <literal condition="western">input</literal> and <literal condition="western">load</literal>. Initial load from /tmp/load_1.txt</para>
      <screen>[(0), (1), (2), (3), (4)];[(5), (6), (7), (8), (9)]</screen>
      <para>Additional loads:</para>
      <screen>/tmp/load_2.txt
{10}[(15), (16), (17), (18), (19)]
/tmp/load_3.txt
{15}[(10), (11), (12), (13), (14)]</screen>
    </sect2>
    <sect2 remap="h3">
      <title>Loading in parallel</title>
      <para>The optional<emphasis> nodeid</emphasis> parameter instructs the load command to open and load data from a particular instance of SciDB. Possible<emphasis> nodeid</emphasis> values are:</para>
      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <tbody>
            <row>
              <entry>
                <para><emphasis role="bold">nodeid</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Description</emphasis></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> 0</para>
              </entry>
              <entry>
                <para> Coordinator</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> 1..N</para>
              </entry>
              <entry>
                <para> Node id of a node in the cluster, obtained form the system catalog table<emphasis> node</emphasis></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> -1</para>
              </entry>
              <entry>
                <para> All nodes in the cluster</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Specifying &quot;-1&quot; for the nodeid causes a parallel load to all nodes in the cluster. The file path of the load file must be the same on all nodes in the cluster, but each node must be given distinct chunks to load. If multiple nodes attempt to load the same chunk during the, the load command will fail. Conversely, if any particular node cannot open the file, the load will continue after logging a warning.</para>
      <para>If your SciDB installation has 4 nodes (say, node1, node2, node3, and node4) and the load must load 20 chunks, you can place chunks 1-5 on node1, chunks 6-10 on node2, and so on. The following load command will simultaneously load all 20 chunks into the array in roughly 1/4th the time compared to a coordinator load.</para>
      <screen>load (Array, &apos;/tmp/load.data&apos;, -1);</screen>
    </sect2>
    <sect2 remap="h3">
      <title>Loading through a Unix pipe</title>
      <para>All the above methods of loading SciDB can also be done via a Unix pipe (instead of load files). Pipes avoid creating and storing SciDB load files from source files.</para>
    </sect2>
    <sect2 remap="h3">
      <title>csv2scidb</title>
      <para>CSV is a common data exchange format. Many systems produce data in CSV format. SciDB provides a utility called<emphasis> csv2scidb</emphasis> to convert a csv file into a 1-dimensional array. This array must later be transformed using other SciDB operators such as redimension and redimension_store discussed later in this document.</para>
      <para>Consider the csv file /tmp/observations.csv:</para>
      <screen>String_One,15354,01-01-2005 10:11:32,31.7257
String_One,15354,01-01-2005 10:11:35,404.0464
String_One,15354,01-01-2005 10:11:38,926.4216
String_One,,01-01-2005 10:11:41,16.7285
...</screen>
      <para>csv2scidb can be used to re-format this file into a dense SciDB load file ready to be loaded into the 1-dimensional array<emphasis> Raw_Load</emphasis>.</para>
      <screen>iquery -anq &quot;create array Raw_Load&lt;s: string, dt: dateTime, r: double&gt;[1:*, 13\
4340,0]&quot;
mkfifo /tmp/load_pipe
cat /tmp/observations.csv  | awk -F, &apos;{print $1&quot;,&quot;$3&quot;,&quot;$4}&apos; 
   | csv2scidb -c 134340 -p SSN &gt; /tmp/load_pipe &amp; 
iquery -anq &quot;load (Raw_Load, &apos;/tmp/load_pipe&apos;)&quot;</screen>
      <para>The following arguments to csv2scidb are shown here.<emphasis> -c</emphasis> is used to specify the chunk size, and<emphasis> -p</emphasis> is used to specify a parse format for the file (S = string, N = numerical, C = char). See<emphasis> csv2scidb --help</emphasis> for more details on usage.</para>
    </sect2>
  </sect1>
  <sect1 remap="h2">
    <title>input</title>
    <para><emphasis role="bold">Summary:</emphasis> Input is used to read a file from the filesystem, interpret the contents as cells in an array and return the result. Input has the exact same signature as load.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>input (<emphasis>array_name : array_identifier</emphasis>,<emphasis> data_file : string</emphasis> [,<emphasis> nodeid : int</emphasis>] )</para>
    <para>Input works exactly the same way as load, except it does NOT store the data. The store operator can be used to persist the output of the <literal condition="western">input</literal> operator. This means that:</para>
    <screen>store ( input (a, &apos;somefile&apos; ), a);</screen>
    <para>is the same as</para>
    <screen>load ( a, &apos;somefile&apos; );</screen>
    <para>and</para>
    <screen>store ( input (a, &apos;somefile&apos; ), b);</screen>
  </sect1>
  <sect1 remap="h2">
    <title>substitute</title>
    <para>Substitute null values in the input array, using their missing reason code, if using the &quot;?code&quot; format, as index in the second (substitution) array.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <blockquote>
      <para><literal condition="western">substitute</literal>(<emphasis> array</emphasis>,<emphasis> mask: array</emphasis> )</para>
    </blockquote>
    <para>For example, array foo contains two nulls (which is equivalent to ?0) and one ?1:</para>
    <programlisting>create array foo &lt;val:int32 null&gt;[x=0:8,1,0];
load(foo,&apos;/tmp/foo.txt&apos;);
scan(foo);
[(1),(2),(null),(4),(5),(null),(7),(?1)]</programlisting>
    <para>You can use substitute to replace ?0 with 20 and ?1 with 30, for instance. We build an array where 0 maps to 20 and 1 maps to 30:</para>
    <screen>build(&lt;val:double&gt; [x=0:1,2,0], iif( x = 0, 20, 30));
[(20),(30)]</screen>
    <para>You can use this build expression as part of substitute directly by using an anonymous schema:</para>
    <screen>substitute(foo,build(&lt;val:int32&gt; [x=0:1,2,0], iif( x = 0, 20, 30)));
[(1),(2),(20),(4),(5),(20),(7),(30)]</screen>
    <para>The <literal condition="western">substitute</literal> operator does not store the new values or create a new version of <literal condition="western">foo</literal>:</para>
    <screen>list(&apos;arrays&apos;);
[(&quot;foo&quot;),(&quot;foo@1&quot;)]
scan(foo);
[(1),(2),(null),(4),(5),(null),(7),(?1)]</screen>
    <para>Both input arguments to <literal condition="western">substitute</literal> must be single-attribute arrays with the same attribute type.</para>
  </sect1>
  <sect1 remap="h2">
    <title>save</title>
    <para><emphasis role="bold">Summary</emphasis>: Unload array data to a file</para>
    <para>Use the save operator to unload the data to an external file on the file system. The format of the file is the same as the load file format described above. If the internal chunk storage format of the array is dense, this file is unloaded into a dense file format. And if the array chunk storage format is sparse, the save output is in sparse file format.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <screen>save( &apos;&apos;array&apos;&apos;, &apos;&apos;file_path : string&apos;&apos; )</screen>
    <para>Array name refers to the array to be unloaded and saved. File path is the path to a file to use -- if a relative path name is used this is assumed to be relative to the working directory of the SciDB server.</para>
    <para>In a cluster configuration, save operates as follows. For each node in a cluster<emphasis> save</emphasis> creates a file with the same file name containing only the chunks stored on that node. The entire array data is obtained by concatenating saved files from all nodes.</para>
  </sect1>
</chapter>
