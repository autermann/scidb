<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter remap="h1">
  <title>&#160;Basic Array Operations: Viewing and Manipulating Your Data</title>
  <sect1 remap="h2">
    <title>apply</title>
    <para><emphasis role="bold">Summary:</emphasis> Compute new attribute values</para>
    <para>Use the apply operator to compute new values from attributes and indexes of input arrays. The value(s) computed in the apply are appended to the attributes in the input array.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <screen>apply( array, new_attribute : attribute_identifier, expr_to_apply : express\
ion )
apply( array, new_attribute1 : attribute_identifier1, expr_to_apply1 : expr\
ession1 
    [, new_attribute2 : attribute_identifier2, expr_to_apply2 : expression2\
] ...)</screen>
    <para>For example, the query below will compute new attributes C and D, whose values are given by the expressions A + 20 and A + 30. The resulting array will have all the old attributes, as well as the new attributes C and D.</para>
    <screen>apply ( subarray ( my_array, 4, 4, 6, 6 ), C, A + 20, D, A + 30 );</screen>
    <para>Queries with more than one apply statement can also nest them. This is important if one apply statement uses the output of a previous apply statement as input:</para>
    <screen>apply ( apply ( subarray ( my_array, 4, 4, 6, 6 ), C, A + 20 ), D, C * 3);</screen>
  </sect1>
  <sect1 remap="h2">
    <title>attribute_rename</title>
    <para><emphasis role="bold">Summary</emphasis>: Change attribute name</para>
    <para>Works similarly to cast but only changes the name of an attribute. The new name is used in the result array, and the source array is not changed.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>attribute_rename (<emphasis> array</emphasis>,<emphasis> old_name : attribute_identifier</emphasis>,<emphasis> new_name : attribute_identifier</emphasis> )</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen>attribute_rename(m3x3,val,foo)</screen>
  </sect1>
  <sect1 remap="h2">
    <title>build</title>
    <para>Return a dense single-attribute array, assigning values to its attributes using an expression. Expressions can refer to one of the functions supported in SciDB, and to dimension values.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <blockquote>
      <para><literal condition="western">build</literal>(<emphasis> array : array_identifier | anonymous_schema</emphasis> ,<emphasis> expression</emphasis> )</para>
    </blockquote>
    <para>The build operator&apos;s first argument is:</para>
    <itemizedlist>
      <listitem>
        <para> the name of an array that is to be used as the template for the operator&apos;s result, or </para>
      </listitem>
      <listitem>
        <para> an array schema (&quot;anonymous_schema&quot;) to be used as the template for the operator result </para>
      </listitem>
    </itemizedlist>
    <para><literal condition="western">build</literal> proceeds through the array, cell by cell, using the value of the<emphasis> exp : expression</emphasis> to compute the value of each cell. The expression can use any of the array&apos;s dimension values. On a cluster configuration, build works in parallel on all instances.</para>
    <para><emphasis role="bold">Example 1</emphasis>: Create an identity matrix called Build_Example_INT:</para>
    <screen>CREATE ARRAY Build_Example_INT &lt; A: int32 &gt; [ X=0:4,5,0, Y=0:4,5,0 ];
build (Build_Example_INT, iif(X=Y, 1, 0));

[
[(1),(0),(0),(0),(0)],
[(0),(1),(0),(0),(0)],
[(0),(0),(1),(0),(0)],
[(0),(0),(0),(1),(0)],
[(0),(0),(0),(0),(1)]
]</screen>
    <para><emphasis role="bold">Example 2</emphasis>: Build an array of monotonically increasing values from an anonymous schema:</para>
    <screen>build (&lt;val:int64&gt; [x=1:4,4,0,y=1:4,4,0], x*4+y-5);

[
[(0),(1),(2),(3)],
[(4),(5),(6),(7)],
[(8),(9),(10),(11)],
[(12),(13),(14),(15)]
]</screen>
    <para><emphasis role="bold">Note</emphasis>: The <literal condition="western">build</literal> operator does not store data and does not change the given array; it only uses the given shape to generate and return a result. To store the result of the build operator you will need to use the <literal condition="western">store</literal> operator.</para>
    <para><emphasis role="bold">Note</emphasis>: &quot;The input array or anonymous schema input to <literal condition="western">build</literal> should contain only a single attribute (although multiple dimensions are allowed). Use the <literal condition="western">join</literal> operator with the <literal condition="western">build</literal> operator to build multi-attribute arrays.&quot;</para>
    <para><emphasis role="bold">Note</emphasis>: If an array is declared as EMPTY it cannot be used as an input to build() operator. EMPTY arrays implicitly include an attribute named &quot;empty_indicator&quot; and so are multi-attribute.</para>
  </sect1>
  <sect1 remap="h2">
    <title>build_sparse</title>
    <para><literal condition="western">build_sparse</literal> works similarly to <literal condition="western">build</literal> but returns an EMPTY type array and accepts a second expression that must be boolean.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>build_sparse(<emphasis> array : array_identifier | anonymous_schema</emphasis>,<emphasis> exp : expression</emphasis>,<emphasis> bexp : expression</emphasis> )</para>
    <para>The <literal condition="western">build_sparse</literal> operator&apos;s first argument is:</para>
    <itemizedlist>
      <listitem>
        <para> the name of an array that is to be used as the template for the operator&apos;s result, or </para>
      </listitem>
      <listitem>
        <para> an array schema (&quot;anonymous_schema&quot;) to be used as the template for the operator result. </para>
      </listitem>
    </itemizedlist>
    <para>The output of build_sparse contains empty cells wherever<emphasis> bexp</emphasis> evaluates to false. Both expressions can access any of the array coordinates.</para>
    <para><emphasis role="bold">Example</emphasis>: Build a diagonal matrix called <literal condition="western">sparse_diagonal</literal>:</para>
    <screen>CREATE ARRAY sparse_diagonal &lt;a1: double&gt; [x=0:2,3,0, y=0:2,3,0]
build_sparse(sparse_diagonal, 1.0*x+100.0*y, x=y)</screen>
    <para>Build the same matrix template with an anonymous schema:</para>
    <screen>build_sparse(&lt;a1: double&gt; [x=0:2,3,0, y=0:2,3,0], 1.0*x+100.0*y, x=y)</screen>
  </sect1>
  <sect1 remap="h2">
    <title>cast</title>
    <para><emphasis role="bold">Summary</emphasis>: Change the attribute or dimension names</para>
    <para>The <literal condition="western">cast</literal> operator allows renaming an array or any of its attributes and dimensions. A single cast invocation can be used to rename multiple items at once -- one or more attribute names and/or one or more dimension names. The input array and template arrays should have the same numbers and types of attributes and the same numbers and types of dimensions.</para>
    <para>Note that the template-array need not have actual data and is only used as a template from which attribute names and dimension names are used. Note that the input array is not modified, rather, a new array is created as a result of the cast operator. To store this newly created array use the store operator.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>cast (<emphasis> array</emphasis>,<emphasis> template : array_identifier | anonymous_schema</emphasis> )</para>
    <para>The <literal condition="western">cast</literal> operator&apos;s second argument is:</para>
    <itemizedlist>
      <listitem>
        <para> the name of an array and its schema to be used as the template for the operator&apos;s result, or </para>
      </listitem>
      <listitem>
        <para> an array schema (&quot;anonymous_schema&quot;) to be used as the template for the operator result </para>
      </listitem>
    </itemizedlist>
    <para><emphasis role="bold">Example 1</emphasis>:</para>
    <orderedlist>
      <listitem>
        <para> Create an array called source with a attribute called val: </para>
      </listitem>
    </orderedlist>
    <screen>create array source &lt;val:double&gt; [x=0:5,3,0];</screen>
    <orderedlist>
      <listitem>
        <para> Use an anonymous schema to change the attribute name to value,and the dimension name to i. Store the result in an array called target: </para>
      </listitem>
    </orderedlist>
    <screen>store(cast(source, &lt;value:int64&gt;[i=0:5,3,0]),target);</screen>
    <para><literal condition="western">target</literal> has the new names while <literal condition="western">source</literal> maintains the old:</para>
    <screen>show(target);

[(&quot;target&lt;value:double NOT NULL&gt; [i=0:5,3,0]&quot;)]

show(source);

[(&quot;source&lt;val:double NOT NULL&gt; [x=0:5,3,0]&quot;)]</screen>
    <para><emphasis role="bold">Example 2</emphasis>: One important application of <literal condition="western">cast</literal> is the resolution of naming conflicts:</para>
    <informaltable frame="none">
      <tgroup cols="1">
        <colspec colname="c1" colwidth="100*"/>
        <tbody>
          <row>
            <entry>
              <para><screen>store(build (&lt;a:int64&gt; [x=0:10,1,0], x), vector);

[(0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10)]

store(build (&lt;a:int64&gt; [x=0:10,1,0], -x), vector2);

[(0),(-1),(-2),(-3),(-4),(-5),(-6),(-7),(-8),(-9),(-10)]

apply(join(vector,vector2), b, a+a);
-- ERROR: a is ambiguous

apply(join(vector, cast (vector2, &lt;b:int64&gt;[x=0:10,1,0])), c, a+b);

[(0,0,0),(1,-1,0),(2,-2,0),(3,-3,0),(4,-4,0),(5,-5,0),(6,-6,0),(7,-7,0),(8,\
-8,0),(9,-9,0),(10,-10,0)]</screen></para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </sect1>
  <sect1 remap="h2">
    <title>project</title>
    <para><emphasis role="bold">Summary:</emphasis> Select array attributes</para>
    <para>Project the input array on the specified attributes, in the specified order. Attributes that are not specified are excluded from the output.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>project (<emphasis> array</emphasis>,<emphasis> attribute1 : attribute_identifier</emphasis> [,<emphasis> attribute-2 : attribute_identifier</emphasis> ...] )</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen> project( subarray ( my_array, 4, 4, 6, 6 ), A);

(44)  (45)  (46)
(54)  (55)  (56)
(64)  (65)  (66)
 project( apply ( subarray ( my_array, 4, 4, 6, 6 ), C, A + 20 ), C);
(64.0)  (65.0)  (66.0)
(74.0)  (75.0)  (76.0)
(84.0)  (85.0)  (86.0)</screen>
  </sect1>
  <sect1 remap="h2">
    <title>rename</title>
    <para><emphasis role="bold">Summary</emphasis>: Rename an array</para>
    <para>Signature:</para>
    <para>rename( old_name : array_identifier, new_name : array_identifier )</para>
    <para>The first argument is the name of the array to be renamed, and the second argument is the new array name.</para>
    <para>Example:</para>
    <screen>store ( build (&lt; A: int32 &gt; [ X=0:4,5,0, Y=0:4,5,0 ], iif(X=Y,1,0)), rename_e\
xample);
list (&apos;arrays&apos;);
rename (rename_example, new_name);
project (new_name, A);

[[(1),(0),(0),(0),(0)],
[(0),(1),(0),(0),(0)],
[(0),(0),(1),(0),(0)],
[(0),(0),(0),(1),(0)],
[(0),(0),(0),(0),(1)]]

</screen>
    <para><emphasis role="bold">Notes</emphasis>:</para>
    <orderedlist>
      <listitem>
        <para> Once a rename is done, the old array name can be re-used. Any mapping arrays are also renamed. </para>
      </listitem>
      <listitem>
        <para> The <literal condition="western">rename</literal> operator should not be used concurrently with another query on the same array. Perform the rename first, then execute other queries on a renamed array. </para>
      </listitem>
    </orderedlist>
  </sect1>
  <sect1 remap="h2">
    <title>scan</title>
    <para><emphasis role="bold">Summary:</emphasis> Print attribute values</para>
    <para>Scan returns the contents of the array whose name is passed in as an argument.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>scan(<emphasis>array_identifier</emphasis> )</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen>scan(my_array);</screen>
    <para>The &apos;scan&apos; operator expects an array identifier as its first argument, and returns an array as a result of operation. This operator is used to get a complete listing of the contents of an array stored in the SciDB database. To see a particular version of an array, append the version number to the array name:</para>
    <screen>scan(my_array@1);</screen>
  </sect1>
  <sect1 remap="h2">
    <title>sort</title>
    <para><emphasis role="bold">Summary</emphasis>: Sort by attribute value</para>
    <para>Sort a one-dimensional array by one or more attributes. The sort attributes are specified using a 1-based attribute number.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>sort ( array, attribute_name [ desc] [, .....] )</para>
    <para>The first argument can be:</para>
    <orderedlist>
      <listitem>
        <para> An array </para>
      </listitem>
      <listitem>
        <para> An array operator, that is, an operator that outputs a SciDB array. </para>
      </listitem>
    </orderedlist>
    <para>The attribute name can optionally be followed by <literal condition="western">desc</literal> to sort in descending order. Default is ascending order.</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen>less /tmp/sd.txt
[(1,&quot;a&quot;),(2,&quot;z&quot;),(0,&quot;b&quot;),(3,&quot;x&quot;),(2,&quot;f&quot;),(6,&quot;o&quot;),(1.5,&quot;e&quot;),(2.7,&quot;l&quot;)]

create array sd &lt;num:double,label:string&gt;[x=0:8,8,0];
load(sd,&apos;/tmp/sd.txt&apos;);

[(1,&quot;a&quot;),(2,&quot;z&quot;),(0,&quot;b&quot;),(3,&quot;x&quot;),(2,&quot;f&quot;),(6,&quot;o&quot;),(1.5,&quot;e&quot;),(2.7,&quot;l&quot;)]

sort(sd,num);

[(0,&quot;b&quot;),(1,&quot;a&quot;),(1.5,&quot;e&quot;),(2,&quot;z&quot;),(2,&quot;f&quot;),(2.7,&quot;l&quot;),(3,&quot;x&quot;),(6,&quot;o&quot;)]</screen>
    <para>To sort in descending order, use the desc argument:</para>
    <screen>sort(sd,num desc);

[(6,&quot;o&quot;),(3,&quot;x&quot;),(2.7,&quot;l&quot;),(2,&quot;z&quot;),(2,&quot;f&quot;),(1.5,&quot;e&quot;),(1,&quot;a&quot;),(0,&quot;b&quot;)]

sort(sd,label desc);

[(2,&quot;z&quot;),(3,&quot;x&quot;),(6,&quot;o&quot;),(2.7,&quot;l&quot;),(2,&quot;f&quot;),(1.5,&quot;e&quot;),(0,&quot;b&quot;),(1,&quot;a&quot;)]</screen>
  </sect1>
</chapter>
