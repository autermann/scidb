<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter remap="h1">
    <title>Combining Arrays: Putting the Pieces of Your Database Together</title>
    <sect1 remap="h2">
      <title>concat</title>
      <para><emphasis role="bold">Summary</emphasis>: Concatenate two arrays</para>
      <para>Array should have the name number of dimensions. Concatenation is performed by the left-most dimension. All other dimensions of the input arrays must match. The left-most dimension of both arrays must have a fixed size (not unbounded) and same chunking schema. Both inputs must have the same attributes.</para>
      <para>The inputs to concat can be:</para>
      <orderedlist><listitem>
          <para> An existing array. </para>
        </listitem>
<listitem>
          <para> An array operator, that is, an operator that outputs a SciDB array. </para>
        </listitem>
</orderedlist>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <blockquote>
        <para><literal condition="western">concat</literal>(<emphasis> left: array</emphasis>,<emphasis> right : array</emphasis> )</para>
      </blockquote>
      <para><emphasis role="bold">Example</emphasis>:</para>
      <screen>store(build(&lt;val:int64&gt;[x=0:3,100,0,y=0:4,100,0],x*5+y),four_by_five);

[
[(0),(1),(2),(3),(4)],
[(5),(6),(7),(8),(9)],
[(10),(11),(12),(13),(14)],
[(15),(16),(17),(18),(19)]
]

store(build(&lt;val:int64&gt;[x=0:1,100,0,y=0:4,100,0],20+x*2+y),two_by_five);
[
[(20),(21),(22),(23),(24)],
[(22),(23),(24),(25),(26)]
]

concat(four_by_five,two_by_five);

[
[(0),(1),(2),(3),(4)],
[(5),(6),(7),(8),(9)],
[(10),(11),(12),(13),(14)],
[(15),(16),(17),(18),(19)],
[(20),(21),(22),(23),(24)],
[(22),(23),(24),(25),(26)]
]</screen>
      <para>Note that concat can be combined with transpose, adddim, deldim, subarray, slice and other ops for more complex transformations.</para>
    </sect1>
    <sect1 remap="h2">
      <title>cross</title>
      <para><emphasis role="bold">Summary</emphasis>: Cross-product join</para>
      <para>The inputs to cross can be:</para>
      <orderedlist><listitem>
          <para> An existing array. </para>
        </listitem>
<listitem>
          <para> An array operator, that is, an operator that outputs a SciDB array. </para>
        </listitem>
</orderedlist>
      <para>Calculates the full cross product join of two arrays, say A (m-dimensional array) and B (n-dimensional array) such that the result is an m+n dimensional array in which each cell is computed as the concatenation of the attribute lists from corresponding cells in arrays A and B. For example, consider a 2-dimensional array A with dimensions i, j, and a 1-dimensional array B with dimension k. The cell at coordinate position {i, j, k} of the output is computed as the concatenation of cells {i, j} of A with cell at coordinate {k} of B.</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>cross(<emphasis> left : array</emphasis>,<emphasis> right : array</emphasis> )</para>
      <para><emphasis role="bold">Example</emphasis>:</para>
      <screen>create array a&lt;a1: double&gt;[i=1:3,3,0, j=1:3,3,0];
create array b&lt;b1: double&gt;[k=1:2,2,0];

store(build(a, i+j), a);

[[(2),(3),(4)],
[(3),(4),(5)],
[(4),(5),(6)]]

store(build(b, 1.0/k), b);

[(1),(0.5)]

cross(a, b);

[[
[(2,1),(2,0.5)],
[(3,1),(3,0.5)],
[(4,1),(4,0.5)]
],
[
[(3,1),(3,0.5)],
[(4,1),(4,0.5)],
[(5,1),(5,0.5)]
],
[
[(4,1),(4,0.5)],
[(5,1),(5,0.5)],
[(6,1),(6,0.5)]
]]</screen>
      <para>The output is a 3-dimensional array with the following schema:</para>
      <screen>&lt;a1:double NOT NULL, b1:double NOT NULL&gt;[i=1:3,3,0, j=1:3,3,0, k=1:2,2,0]</screen>
    </sect1>
    <sect1 remap="h2">
      <title>cross_join</title>
      <para><emphasis role="bold">Summary</emphasis>: Cross-product join with equality predicates</para>
      <para>Calculates the cross product join of two arrays, say A (m-dimensional array) and B (n-dimensional array) with equality predicates applied to pairs of dimensions, one from each input. Predicates can only be computed along dimension pairs that are aligned in their type, size, and chunking.</para>
      <para>Assume p such predicates in the cross_join, then the result is an m+n-p dimensional array in which each cell is computed by concatenating the attributes as follows:</para>
      <para>For a 2-dimensional array A with dimensions i, j, and a 1-dimensional array B with dimension k, cross_join(A, B, j, k) results in a 2-dimensional array with coordinates {i, j} in which the cell at coordinate position {i, j} of the output is computed as the concatenation of cells {i, j} of A with cell at coordinate {k=j} of B.</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>cross_join(<emphasis> left : array</emphasis>,<emphasis> right : array</emphasis>,<emphasis> left_dim_1: dimension_identifier</emphasis>,<emphasis> right_dim_1 : dimension_identifier</emphasis> [,<emphasis> left_dim_2: dimension_identifier</emphasis>,<emphasis> right_dim_2: dimension_identifier</emphasis>,... ] )</para>
      <para><emphasis role="bold">Example</emphasis>:</para>
      <screen>create array a&lt;a1: double&gt;[i=1:3,3,0, j=1:3,3,0];
create array b&lt;b1: double&gt;[k=1:3,3,0];

store(build(a, i+j), a);

[[(2),(3),(4)],
[(3),(4),(5)],
[(4),(5),(6)]]

store(build(b, 1.0/k), b);

[(1),(0.5), (0.333)]

cross_join(a, b, j, k);

[
[(2,1),(3,0.5),(4,0.333333)],
[(3,1),(4,0.5),(5,0.333333)],
[(4,1),(5,0.5),(6,0.333333)]
]</screen>
      <para>The result has schema:</para>
      <screen>&lt;a:double NOT NULL, b:double NOT NULL&gt;[i=1:3,3,0, j=1:3,3,0]</screen>
    </sect1>
    <sect1 remap="h2">
      <title>join</title>
      <para><emphasis role="bold">Summary</emphasis>: Join two arrays</para>
      <para>Join combines the attributes of two input arrays at matching dimension values.</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>join (<emphasis> left : array</emphasis>,<emphasis> right : array</emphasis> )</para>
      <para>The following example illustrates a join between two different subarray operators applied to the same underlying array. Note that join combines attributes from cells at dimension addresses on its immediate input arrays; not in the original inputs:</para>
      <screen> subarray ( my_array AS M1, 4, 4, 6, 6 );

(44,44.0)  (45,45.0)  (46,46.0)
(54,54.0)  (55,55.0)  (56,56.0)
(64,64.0)  (65,65.0)  (66,66.0)
 subarray ( my_array AS M2, 6, 6, 8, 8 );

(66,66.0)  (67,67.0)  (68,68.0)
(76,76.0)  (77,77.0)  (78,78.0)
(86,86.0)  (87,87.0)  (88,88.0)
join ( subarray ( my_array AS M1, 4, 4, 6, 6 ), 
  subarray ( my_array AS M2, 6, 6, 8, 8 ) );

(44,44.0,66,66.0)  (45,45.0,67,67.0)  (46,46.0,68,68.0)
(54,54.0,76,76.0)  (55,55.0,77,77.0)  (56,56.0,78,78.0)
64,64.0,86,86.0)  (65,65.0,87,87.0)  (66,66.0,88,88.0)</screen>
      <para>The join result has the same dimension names as the first input. The left and right arrays must have the same shape. If a cell in either the left or right array is empty, the corresponding cell in the result is also empty.</para>
    </sect1>
    <sect1 remap="h2">
      <title>merge</title>
      <para><emphasis role="bold">Summary</emphasis>: Merge two arrays.</para>
      <para>The inputs to merge can be:</para>
      <orderedlist><listitem>
          <para> An existing array. </para>
        </listitem>
<listitem>
          <para> An array operator, that is, an operator that outputs a SciDB array. </para>
        </listitem>
</orderedlist>
      <para>The two input arrays should have the same shape as one another: that is, the same attribute list and dimensions.</para>
      <para>Merge combines elements from the input array the following way: for each cell in the two inputs, if the cell of first (left) array is<emphasis> non-empty</emphasis>, then the attributes from that cell are selected and placed in the output. If the cell in the first array is marked as<emphasis> empty</emphasis>, then the attributes of the corresponding cell in the second array are taken. If the cell is<emphasis> empty</emphasis> in both input arrays, the output&apos;s cell is set to<emphasis> empty</emphasis>.</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>merge(<emphasis> left : array</emphasis>,<emphasis> right : array</emphasis> )</para>
      <para><emphasis role="bold">Example</emphasis>:</para>
      <screen>scan(vec1);

[[(1,true)],[()],[(3,true)],[()],[(5,true)]]

scan(vec2);

[[()],[(5,true)],[()],[(7,true)],[()]]

merge(vec1,vec2);

[[(1,true)],[(5,true)],[(3,true)],[(7,true)],[(5,true)]]</screen>
    </sect1>
  </chapter>
