<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter remap="h1">
    <title>Updates and Versioning</title>
    <para>SciDB uses a &quot;no overwrite&quot; storage model - i.e., data is never overwritten, instead each store or update query writes a new version of the array. Versions are stored efficiently within the storage manager to minimize redundant storage. SciDB uses copy-on-write and delta encoding to store only data that has changed between versions, often resulting in efficient internal storage.</para>
    <sect1 remap="h2">
      <title>store</title>
      <para><emphasis role="bold">Summary</emphasis>: Update a SciDB array</para>
      <para>The AFL <literal condition="western">store</literal> command is a write operator, that is, one of the AFL commands that can update an array. Each execution of <literal condition="western">store</literal> causes a new version of the array to be created. When an array is removed, so are all its versions.</para>
      <para>store() can be used to save the resultant output array into an existing/new array. It can also be used to duplicate an array (by using the name of the source array in the first parameter and target_array in the second parameter).</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <blockquote>
        <para><literal condition="western">store</literal>(<emphasis>input</emphasis>,<emphasis> array_name</emphasis>)</para>
      </blockquote>
      <para>The<emphasis> input</emphasis> argument can be:</para>
      <orderedlist><listitem>
          <para> a previously created array, or </para>
        </listitem>
<listitem>
          <para> a sub-query result </para>
        </listitem>
</orderedlist>
      <para>The<emphasis> array_name</emphasis> argument can be:</para>
      <orderedlist><listitem>
          <para> name of a pre-existing array, or </para>
        </listitem>
<listitem>
          <para> name of a non-existent array. In this case, the array takes the schema of the input array or sub-query result. </para>
        </listitem>
</orderedlist>
      <para><emphasis role="bold">Note</emphasis>: SciDB does not allow the array type (EMPTY vs. non-EMPTY) to be altered after array creation. However, array data can be copied from a non-EMPTY array to an EMPTY array if the array dimensions and attributes are compatible.</para>
      <para>The example below shows the contents of file /tmp/dense2.txt used in the AFL examples below.</para>
      <screen>{0,3}
[
[(140),  (150),  (160) ],
[(240),  (250),  (260) ],
[(340),  (350),  (360) ]
];
{3,0}
[
[ (410),  (420),  (430) ],
[ (510),  (520),  (530) ],
[ (610),  (620),  (630) ]
]</screen>
      <para>The input file shown above contains 2 chunks at {0,3} and {3,0} that can be used to update a previously loaded array using:</para>
      <screen>store(merge(input(updarr, &apos;../tests/basic/data/dense2.txt&apos;), updarr), updar\
r)</screen>
      <para>This creates a new version of the<emphasis> updarr</emphasis> array.</para>
    </sect1>
    <sect1 remap="h2">
      <title>Array Versions</title>
      <para>When an array is updated, a new array version is created. You can refer to any version or dimension of an array with the following syntax:</para>
      <blockquote>
        <para><literal condition="western">array_name</literal> [@ <literal condition="western">version</literal> | <literal condition="western">datetime</literal>] [: <literal condition="western">dimension_name</literal>]</para>
      </blockquote>
      <para>For example, suppose you create an array and do two consecutive load commands:</para>
      <screen>CREATE ARRAY A_versions &lt;x:double, y:double&gt;[i=1:10,5,0];
load(A_versions, &apos;/tmp/dataset.txt&apos;)

[(1,100),(1,99),(2,98),(3,97),(4,17),
(5,95),(6,94),(7,93),(8,92),(9,91)]

load(A_versions, &apos;/tmp/dataset2.txt&apos;);

[(100,100),(99,99),(98,98),(97,97),(17,17),
(5,95),(6,94),(7,93),(8,92),(9,91)]</screen>
      <para>The two calls to <literal condition="western">load</literal> will create two versions of the array. To see a listing of an array&apos;s versions, use the <literal condition="western">version</literal> operator:</para>
      <screen>versions(A_versions);

[(1,&quot;2011-12-13 15:13:18&quot;),
(2,&quot;2011-12-13 15:13:26&quot;)]</screen>
      <para>You can use an operator on a prior version of an array using a version qualifier appended to the @ symbol:</para>
      <screen>scan(A_versions@1);
[(1,100),(1,99),(2,98),(3,97),(4,17),
(5,95),(6,94),(7,93),(8,92),(9,91)]

scan(A_versions@2);
[(100,100),(99,99),(98,98),(97,97),(17,17),
(5,95),(6,94),(7,93),(8,92),(9,91)]</screen>
      <para>Array versions can also be identified with a timestamp.</para>
      <screen>scan(A_versions@now());

[(100,100),(99,99),(98,98),(97,97),(17,17),
(5,95),(6,94),(7,93),(8,92),(9,91)]</screen>
      <para>SciDB timestamp format is &quot;YYYY-MM-DD HH:MM:SS&quot;.</para>
      <screen>scan(A_versions@datetime(&apos;2011-12-13 15:13:26&apos;));

[(100,100),(99,99),(98,98),(97,97),(17,17),
(5,95),(6,94),(7,93),(8,92),(9,91)]</screen>
      <para>By default, the array name without a version identifier refers to the latest version of the array.</para>
      <screen>scan(A_versions);

[(100,100),(99,99),(98,98),(97,97),(17,17),
(5,95),(6,94),(7,93),(8,92),(9,91)]</screen>
    </sect1>
  </chapter>
