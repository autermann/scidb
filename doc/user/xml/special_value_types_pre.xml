<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"docbookV4.5/docbookx.dtd">
<section>
  <title>Special Value Types</title>

  <para>Implications from issue #1445.</para>

  <para>Test hex values for letters.   "here"&amp; ì infinity: ∞
  <symbol>∞</symbol></para>

  <para>There are 6 types of values for attributes—the values stored in array
  cells:</para>

  <itemizedlist>
    <listitem>
      <para><emphasis role="bold">Ordinary values. </emphasis>These lie within
      a defined range of representable values for the attribute type. For
      example, "123" is an ordinary value for the data type int64.</para>
    </listitem>

    <listitem>
      <para><emphasis role="bold">Null (missing) values. </emphasis>These
      match the semantics of NULL in a relational database. Note that join
      operations do not take place across nulls. That is, joining any value
      with a null results in a null. <emphasis role="bold">(Is that correct?
      Or do things fail?)</emphasis></para>

      <para>Null values can contain a missing reason code. This allows
      applications to optionally specify multiple types of null values and
      treat each type differently. If you are loading data, you can specify a
      null value with a missing reason code by using
      "?<replaceable>n</replaceable>", where <replaceable>n</replaceable> is
      an integer from 0 to 127. There are two SciDB functions that are
      associated with missing value codes: missing() and
      missing_reason().</para>
    </listitem>

    <listitem>
      <para><emphasis role="bold">Empty cells. </emphasis>This is purely a
      SciDB concept. Missing values allow for a type of default value when
      building an array; that is, they act as a shortcut so that you do not
      need to specify all values when creating an array. Missing values can
      participate in join operations.</para>
    </listitem>

    <listitem>
      <para><emphasis role="bold">Infinity.</emphasis> During calculations, it
      is possible to divide by 0 and store the result into an attribute value.
      SciDB represents this as either <literal>inf</literal> or
      <literal>-inf</literal>, depending on the sign of the dividend.
      <emphasis role="bold">What are the implications?</emphasis></para>

      <para>Multiply an ordinary value by <symbol>∞ </symbol>and it returns
      <symbol>∞</symbol>. So it seems like <symbol>∞</symbol> acts like a big
      number when multiplied by the other non-number types.</para>

      <para>Is infinity a type of NaN? In the Wikipedia entry for <emphasis
      role="bold">NaN</emphasis>, it mentions that NaN can represent
      "non-finite quantities like infinities."</para>
    </listitem>
  </itemizedlist>

  <itemizedlist>
    <listitem>
      <para><emphasis role="bold">NaN values. </emphasis>"Not a Number," these
      are floating-point values that do not actually represent floating-point
      numbers. When arithmetic is performed and one of the arguments is a NaN,
      a NaN is always the result. They are similar to nulls, as they are
      typically not able to take part in join operations.</para>

      <para>According to Wikipedia, the following operations can return
      NaN:<itemizedlist>
          <listitem>
            <para>Operations with a NaN as at least one operand. <emphasis
            role="bold">Does this happen in SciDB?</emphasis></para>
          </listitem>

          <listitem>
            <para>Indeterminate forms (such as divisions 0/0 and inf/inf).
            <emphasis role="bold">Confirm in SciDB.</emphasis></para>
          </listitem>

          <listitem>
            <para>Real operations with complex results:<itemizedlist>
                <listitem>
                  <para>square root of a negative number</para>
                </listitem>

                <listitem>
                  <para>logarithm of a negative number</para>
                </listitem>

                <listitem>
                  <para>inverse sine or cosine of a number that is less than
                  -1 or greater than +1. <emphasis role="bold">Confirmed for
                  sine.</emphasis></para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
    </listitem>
  </itemizedlist>

  <itemizedlist>
    <listitem>
      <para><emphasis role="bold">NA values. </emphasis>Similar to a NaN
      value, NA can be stored in a floating-point data type while not actually
      representing a floating-point value. NA can be stored in a cell to
      indicate that the value is intentionally not a number.</para>

      <para>It is a convention of certain mathematical packages that process
      vectors and arrays of floating point values, where NA represents a value
      that is expressly noted to be missing.</para>

      <para>For example, NA could represent an experimental value that is
      missing in the source data. In SciDB, it is more computationally
      efficient (that is, faster) to use NA values rather than Null values to
      represent missing information.</para>

      <para><emphasis role="bold">Note: </emphasis>NA values can only be
      stored in floating-point data types.</para>

      <para>One more "interesting" thing about NA: when you try to store NA
      into a float, it becomes NaN; when you try to store NA into a double, it
      is stored as NA. When I asked Paul whether this was a bug or intentional
      behavior, he was noncommittal.</para>
    </listitem>

    <listitem>
      <para><emphasis role="bold">Void. </emphasis>Void may not belong on this
      list. It may belong in the table that lists the SciDB data types, and
      then would simply count as an ordinary value for an attribute that is
      defined as type void:</para>
    </listitem>
  </itemizedlist>

  <section>
    <title>Questions/Issues</title>

    <para>Okay, so the previous section is my first pass at writing up the 6
    kinds of values (5 special, while the first is "ordinary").</para>

    <para>The bug mentions that the <emphasis>missing value type </emphasis>is
    different from the way the doc has described the concept of
    <emphasis>missing values/data</emphasis>.</para>

    <para>One objective, as part of documenting these different types, is to
    clearly define what happens when a value is converted from one of these
    types to another, but is not representable in the target. For example,
    what happens when a NaN is converted to an attribute with integer data
    type?</para>

    <para>So, I was looking at "missing reason codes," in Creating and
    Removing chapter. I messed around with multiple attributes, and it gave me
    some insights. So, when loading data, if you do not supply any values for
    an entire cell, the cell is empty. But if you skip only some attributes of
    the cell, default values - or null for nullable attributes -- are
    supplied.</para>

    <para>So it seems like a cell can be empty or not empty -- but not
    "partially" empty. That is, if a cell contains a value for any attribute,
    it must contain values for all attributes.</para>

    <para>I think I've got a handle on most of the types and some of their
    behavior. However, the biggest piece that I still do not understand is the
    difference between NaN and Na. And why they seem to be equivalent for
    floats, but not for doubles. On Wikipedia, the NaN article mentions "quiet
    NaN" and "signalling NaN" — is this the way SciDB differentiates them as
    well?</para>

    <informalexample>
      <para>In this example, we build some matrices with special values and
      then multiply them together.</para>

      <procedure>
        <step>
          <para>First, let's build a 2x2 matrix with inf.</para>

          <para><programlisting language="test">--afl store(build(&lt;val:double&gt; [i=0:1,2,0, j=0:1,2,0], '[[(1),(inf)],[(-inf),2]]',true),A);
  --output-format=dense --chunkify=yes</programlisting></para>
        </step>

        <step>
          <para>Next, let's build another one.</para>

          <para><programlisting language="test">--afl store(build(&lt;val:double&gt; [i=0:1,2,0, j=0:1,2,0], '[[(4),(inf)],[(),2]]',true),B);
  --output-format=dense --chunkify=yes</programlisting></para>
        </step>

        <step>
          <para>Multiply them.</para>

          <programlisting language="test">--afl multiply(A,B); --output-format=dense --chunkify</programlisting>

          <para>So, the first result cell, C<subscript>00</subscript> = (1
          <symbol>x</symbol> 4) + ( <symbol>∞ x </symbol>() ) = NaN. Which
          seems to mean that <symbol>∞ x</symbol> <literal>empty</literal>
          returns NaN. The other cells are all <symbol>∞</symbol> or
          -<symbol>∞</symbol>, which seems to mean that, assuming
          <replaceable>n</replaceable> is an ordinary value,
          <replaceable>n</replaceable> <symbol>x ∞</symbol> returns
          <symbol>∞</symbol>.</para>
        </step>

        <step>
          <para>Let's play around with a multiple-attribute
          array.<programlisting language="test">--afl create array test &lt;a:int64, b:double null, c:string, d:char null&gt; [i=0:3,4,0]; --show-output=no
--afl store(build(test,'[(10,?4, "Boy", "C"),(,?11,,)]', true),test); --output-format=dense</programlisting></para>
        </step>

        <step>
          <para>Now let's examine void, missing() and
          missing_reason().<programlisting language="test">--afl store(build(&lt;val:int32 null&gt;[i=0:6,7,0], '[(),2,?4,(null),5]', true),arrayA); --show-output=no
--afl create array arrayB&lt;mrCode:int32 NULL DEFAULT null&gt; [i=0:6,7,0] --show-output=no
--aql select missing_reason(val) into arrayB from arrayA; --output-format=dense
--afl show(arrayB)
--aql select missing(mrCode) into arrayC from arrayB; --output-format=dense
--afl show(arrayC)
--afl apply(arrayB, ms1, missing(mrCode)); --output-format=dense</programlisting></para>
        </step>

        <step>
          <para>Let's try to get some NaNs returned.<programlisting
          language="test">--afl store(build(&lt;val:double&gt;[i=1:10,10,0],i/3.0 - 2),C); --output-format=dense
--aql select asin(val) from C; --output-format=dense
</programlisting></para>
        </step>
      </procedure>
    </informalexample>
  </section>
</section>
