<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter remap="h1">
  <title>Python Connector</title>
  <sect1 remap="h2">
    <title>SciDB Client API for Python</title>
    <para>SciDB uses an ODBC/JDBC like interface to connect to the SciDB server and execute commands. This interface is available from multiple computer languages. This page documents the Python version of the SciDB API.</para>
    <para>To get access to the API add the following to your Python file:</para>
    <screen>import sys
sys.path.append(&apos;/opt/scidb/11.10/lib&apos;)  # or location appropriate to your \
installed version
import scidbapi as scidb</screen>
    <para>This imports the scidbapi module, scidbapi.py, which defines an interface to scidb. This interface is implemented using several Python and C++ libraries beneath it: libscidbpython.py (generated by the SWIG compiler) contains python classes that are proxies for C++ classes, _libscidbpython.so which was also generated by SWIG and provides some of the conversion between the Python API and C++, and libscidbclient.so, which implements the C++ remote client library for SciDB.</para>
    <para>You can then list information about the scidbapi module with the Python statement:</para>
    <screen>help(scidb)</screen>
  </sect1>
  <sect1 remap="h2">
    <title>Example Python Application</title>
    <para>Two sample python applications are provided in the <literal condition="western">/opt/scidb/11.12/share/scidb/examples/python</literal> directory of a server installation. These are also located at src/capi/pythonexamples directory of the SciDB sources, available to registered SciDB developers. The example files are:</para>
    <itemizedlist>
      <listitem>
        <para> README </para>
      </listitem>
      <listitem>
        <para> sample.py is a program that creates and loads an array, executes a select AQL statement, and drops the array. </para>
      </listitem>
      <listitem>
        <para> sample2.py takes in a list of afl/aql queries from a file (or files) and executes them. This example shows the use of additional data types and the empty flag for queries with filter predicates. </para>
      </listitem>
      <listitem>
        <para> simplearray.data is read by sample.py </para>
      </listitem>
      <listitem>
        <para> sample2.csv is read by sample2.py </para>
      </listitem>
    </itemizedlist>
    <para>NOTE: You may find other contributed examples in the src/capi/pythonexamples; however, they will not be given the level of attention for maintaining correctness as sample.py and sample2.py and may be written in older versions of the API.</para>
    <para>NOTE: The python API will probably move to its own directory in the source tree (out of the capi directory) in the near future.</para>
  </sect1>
  <sect1 remap="h2">
    <title>Example: Connect and Execute a Simple Query</title>
    <para>You connect to SciDB using connect() and execute queries using executeQuery(). Connect() takes a server address and the port number for the SciDB coordinator.</para>
    <screen>db = scidb.connect(&quot;localhost&quot;, 1239)
# connect to the SciDB coordinator.
result = db.executeQuery(&quot;drop array simplearray&quot;, &apos;aql&apos;) 
# execute an AQL query</screen>
    <para>You then iterate over result to obtain the result data. See the section on Array and Chunk Iterators, below.</para>
  </sect1>
  <sect1 remap="h2">
    <title>Create and Load Queries</title>
    <para><emphasis>executeQuery (statement, type, result, handle)</emphasis></para>
    <informaltable frame="none">
      <tgroup cols="2">
        <colspec colname="c1" colwidth="50*"/>
        <colspec colname="c2" colwidth="50*"/>
        <tbody>
          <row>
            <entry>
              <para><emphasis role="bold">Arg</emphasis></para>
            </entry>
            <entry>
              <para><emphasis role="bold">Description</emphasis></para>
            </entry>
          </row>
          <row>
            <entry>
              <para> <emphasis>statement</emphasis></para>
            </entry>
            <entry>
              <para> Valid AQL or AFL statement.</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> <emphasis>type</emphasis></para>
            </entry>
            <entry>
              <para> scidb.AQL or scidb.AFL.</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> <emphasis>result</emphasis></para>
            </entry>
            <entry>
              <para> Each query requires a new QueryResult structure on the client. QueryResult is described in the section below on Data Access.</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> <emphasis>handle</emphasis></para>
            </entry>
            <entry>
              <para> connection handle</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>The examples below show how to execute create and load queries.</para>
    <para>Create an array<emphasis> simplearray</emphasis>.</para>
    <screen>db.executeQuery(&quot;CREATE immutable ARRAY simplearray 
     &lt; foo:int32, bar:char, baz:string &gt; [row=0:99,10,0, col=0:9,10,0]&quot;, &quot;aql&quot;)</screen>
    <para>Load data into this array. The data file must be visible on the server&apos;s file system. A relative path to the file will be interpreted relative to the working directory of the server. This will be appropriate if the data were saved from the same server. In other cases, it may be more appropriate to use an absolute path to files to be loaded.</para>
    <screen>db.executeQuery(&quot;load simplearray from &apos;simplearray.data&apos;&quot;, &quot;AQL&quot;)
db.executeQuery(&quot;select * from simplearray&quot;, &quot;AQL&quot;)</screen>
  </sect1>
  <sect1 remap="h2">
    <title>Data Access</title>
    <sect2 remap="h3">
      <title>Query Result</title>
      <para>Accessing the schema of the result set is performed through a set of python objects accessible through the QueryResult.</para>
      <para>Use the following help commands to get more information</para>
      <screen>help(scidb.swig.QueryResult)</screen>
      <variablelist>
        <varlistentry>
          <term/>
          <listitem>
            <para><informaltable frame="none">
                <tgroup cols="2">
                  <colspec colname="c1" colwidth="50*"/>
                  <colspec colname="c2" colwidth="50*"/>
                  <tbody>
                    <row>
                      <entry>
                        <para><emphasis role="bold">Arg</emphasis></para>
                      </entry>
                      <entry>
                        <para><emphasis role="bold">Description</emphasis></para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> array</para>
                      </entry>
                      <entry>
                        <para> Handle to the array object, its iterators and descriptors returned by the server.</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> queryID</para>
                      </entry>
                      <entry>
                        <para> Query ID as known to the server. It is valid after the successful execution of a statement and may not be re-used.</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> selective</para>
                      </entry>
                      <entry>
                        <para> Indicates if a data retrieval command was executed.</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> executionTime</para>
                      </entry>
                      <entry>
                        <para> Execution time of this query.</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> explainLogical</para>
                      </entry>
                      <entry>
                        <para> Logical plan used.</para>
                      </entry>
                    </row>
                    <row>
                      <entry>
                        <para> explainPhysical</para>
                      </entry>
                      <entry>
                        <para> Physical plan used.</para>
                      </entry>
                    </row>
                  </tbody>
                </tgroup>
              </informaltable>
</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
    <sect2 remap="h3">
      <title>Array, Attribute, and Dimension Descriptors</title>
      <para>Additional information such as the dimensions and attributes of the result array are accessible from objects in the array. For more information use help on the following classes:</para>
      <screen>help(scidb.swig.ArrayDesc)
help(scidb.swig.AttributeDesc)
help(scidb.swig.DimensionDesc)</screen>
    </sect2>
    <sect2 remap="h3">
      <title>Array and Chunk Iterators</title>
      <para>The data access API is based on the nested array data model of SciDB.</para>
      <para>A SciDB array is returned to the caller as a collection of<emphasis> chunks</emphasis> that together represent the array. Array and chunk iterators must be used to scan all cells of the array.</para>
      <para>Each attribute of the array can be accessed using a separate set of iterators. Attribute iteration is done at two levels: an outer iteration of chunks of the array and an iteration of cells in a chunk. The array iterator iterates over the chunks in dimension major order, as does the chunk iterator. That is to say that both arrays and chunks are multidimensional and data is returned in first to last dimension order (e.g., row-major order for a 2d array).</para>
      <para>The data access API includes the following objects.</para>
      <screen>Array
ArrayDesc
AttributeDesc
DimensionDesc 
ConstArrayIterator
ConstChunkIterator
ConstChunk
Coordinates
Value</screen>
      <para>The following example shows how to iterate over all chunks of an array, and all elements of each chunk.</para>
      <screen>    chunkiters = []
    for i in range(attrs.size()):
        nc = -1
        while not iters[i].end():
            nc += 1
            chunkiter = iters[i].getChunk().getConstIterator(
                 (scidb.swig.ConstChunkIterator.IGNORE_EMPTY_CELLS |
                  scidb.swig.ConstChunkIterator.IGNORE_OVERLAPS))
            print &quot;Chunk iterator %d loaded.&quot; % nc
            
            while not chunkiter.end():
                dataitem = chunkiter.getItem()

                item = scidb.getTypedValue(dataitem, attrs[i].getType()) 
                # generate the right type of python object

                print &quot;Data: %s&quot; % item

           iters[i].increment_to_next();</screen>
    </sect2>
    <sect2 remap="h3">
      <title>Items</title>
      <para>Each<emphasis> dataitem</emphasis> returned by the iterator requires a different internal method to retrieve it. Determining that method requires examining the type of its attribute, which can be found by calling AttributeDesc.getType(). If you are using a built-in type, then there is a utility function that will call the per-type for you and return and object of the correct type. For example:</para>
      <screen>    scidb.getTypedValue(dataItem, attrs[i].getType()) 
    # attrs is a per-attribute array of AttributeDesc</screen>
      <para>Special methods are available to detect if an element (or array position) has special significance, such as:</para>
      <screen>dataitem.isEmpty()</screen>
    </sect2>
  </sect1>
  <sect1 remap="h2">
    <title>Cleanup</title>
    <para>A query previously started may be canceled using cancelQuery(). See above for a description of the query ID.</para>
    <screen>db.cancelQuery(queryID) # queryID is in the queryResult class</screen>
    <para>And the client can disconnect from the server using</para>
    <screen>db.disconnect()</screen>
    <para>which will also be called when the db object is deleted (typically by garbage collection). In order to be sure the connection resources are recycled for use by the SciDB server, its probably smart to call db.disconnect() explicitly, rather than waiting for garbage collection to delete the db object at some indeterminate point in the future.</para>
  </sect1>
  <sect1 remap="h2">
    <title>Exception Handling</title>
    <para>If the connector encounters an error, or if the server returns an error during query execution an exception is raised to the python application. These exceptions may be handled using the standard python try/except mechanism.</para>
  </sect1>
</chapter>
