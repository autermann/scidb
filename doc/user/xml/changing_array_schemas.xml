<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter>
  <title>Changing Array Schemas: Transforming Your SciDB Array</title>
  <sect1>
    <title>Redimensioning an Array</title>
    <para>A common use case for creating and loading SciDB arrays is using data from a  data warehouse. This data set may be very large and formatted as a csv file. You can use the csv2scidb utility to convert a csv file to the 1-dimensional array format and load the file into a SciDB array. Once you have a 1-dimensional SciDB array, you can redimension the array to convert the attributes to dimensions.</para>
    <para>For example, suppose you have a csv file like this:<programlisting>d,t,val
&quot;device-0&quot;,&quot;trial-0&quot;,0.01
&quot;device-1&quot;,&quot;trial-0&quot;,2.04
&quot;device-2&quot;,&quot;trial-0&quot;,6.09
&quot;device-3&quot;,&quot;trial-0&quot;,12.16
&quot;device-4&quot;,&quot;trial-0&quot;,20.25
&quot;device-0&quot;,&quot;trial-1&quot;,30.36
&quot;device-1&quot;,&quot;trial-1&quot;,42.49
&quot;device-2&quot;,&quot;trial-1&quot;,56.64
&quot;device-3&quot;,&quot;trial-1&quot;,72.81
&quot;device-4&quot;,&quot;trial-1&quot;,91
&quot;device-0&quot;,&quot;trial-2&quot;,111.21
&quot;device-1&quot;,&quot;trial-2&quot;,133.44
&quot;device-2&quot;,&quot;trial-2&quot;,157.69
&quot;device-3&quot;,&quot;trial-2&quot;,183.96
&quot;device-4&quot;,&quot;trial-2&quot;,212.25
&quot;device-0&quot;,&quot;trial-3&quot;,242.56
&quot;device-1&quot;,&quot;trial-3&quot;,274.89
&quot;device-2&quot;,&quot;trial-3&quot;,309.24
&quot;device-3&quot;,&quot;trial-3&quot;,345.61
&quot;device-4&quot;,&quot;trial-3&quot;,384
&quot;device-0&quot;,&quot;trial-4&quot;,424.41
&quot;device-1&quot;,&quot;trial-4&quot;,466.84
&quot;device-2&quot;,&quot;trial-4&quot;,511.29
&quot;device-3&quot;,&quot;trial-4&quot;,557.76
&quot;device-4&quot;,&quot;trial-4&quot;,606.25</programlisting>This data has three columns, two of which are stings and one which is a floating-point number. The column headers are &apos;d&apos;,&apos;t&apos;,and &apos;val&apos;.  To load this data set, create a 1-dimensional SciDB array with three attributes and load the data into it. For this example, the array is named expo. The dimension name is i, the dimension size is 25, the chunk size is 5. The attributes are s, of type string, p of type string, and val of type double.<programlisting>AQL% <command>SELECT</command> * <command>FROM</command> show(device_trial);</programlisting><screen>[(&quot;device_trial&lt;d:string,t:string,
val:double&gt; [i=1:25,5,0]&quot;)]</screen></para>
    <para>When you examine the data, notice that it could be expressed in a 2-dimensional format like this:<informaltable frame="all">
<?dbfo keep-together="always" ?>        <tgroup cols="6">
          <colspec colname="c1"/>
          <colspec colname="cgen1"/>
          <colspec colname="c2"/>
          <colspec colname="c3"/>
          <colspec colname="c4"/>
          <colspec colname="c5"/>
          <tbody>
            <row>
              <entry/>
              <entry>trial-0</entry>
              <entry>trial-1</entry>
              <entry>trial-2</entry>
              <entry>trial-3</entry>
              <entry>trial-4</entry>
            </row>
            <row>
              <entry>device-0</entry>
              <entry>0.01</entry>
              <entry>30.36</entry>
              <entry>111.21</entry>
              <entry>242.56</entry>
              <entry>424.41</entry>
            </row>
            <row>
              <entry>device-1</entry>
              <entry>2.04</entry>
              <entry>42.49</entry>
              <entry>133.44</entry>
              <entry>274.89</entry>
              <entry>466.84</entry>
            </row>
            <row>
              <entry>device-2</entry>
              <entry>6.09</entry>
              <entry>56.64</entry>
              <entry>157.69</entry>
              <entry>309.24</entry>
              <entry>511.29</entry>
            </row>
            <row>
              <entry>device-3</entry>
              <entry>12.16</entry>
              <entry>72.81</entry>
              <entry>183.96</entry>
              <entry>345.61</entry>
              <entry>557.76</entry>
            </row>
            <row>
              <entry>device-4</entry>
              <entry>20.25</entry>
              <entry>91</entry>
              <entry>212.25</entry>
              <entry>384</entry>
              <entry>606.25</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>SciDB allows you to redimension the data so that you can store it in this 2-dimensional format. First, create an array with 2 dimensions:<programlisting>AFL% create array two_dim
&lt;val:double&gt;
[d(string)=5,5,0, t(string)=5,5,0];</programlisting>Each of the dimensions is of size 5, corresponding to a dimension in the 5-by-5 table. Now, you can use the redimension_store operator to redimension the array device_trial into the array two_dim:<programlisting>AFL% redimension_store(device_trial, two_dim);</programlisting><screen>[
[(0.01),(30.36),(111.21),(242.56),(424.41)],
[(2.04),(42.49),(133.44),(274.89),(466.84)],
[(6.09),(56.64),(157.69),(309.24),(511.29)],
[(12.16),(72.81),(183.96),(345.61),(557.76)],
[(20.25),(91),(212.25),(384),(606.25)]
]</screen>Now the data is stored so that device and trial numbers are the dimensions of the array. This means that you can use the dimension indices to select data from the array. For example, to select the second device from the third trial, use the dimension indices:<programlisting>AQL% <command>SELECT</command> val <command>FROM</command> two_dim <command> WHERE</command> s=&apos;device-2&apos; and p=&apos;trial-3&apos;;</programlisting></para>
    <para>Redimensioning is a powerful tool when you want to do array aggregation along the coordinate axes of a data set. For example, you can find the average value of a trial for each device. This would be  equivalent to finding the average of every row in the table:<programlisting>AFL% create array Ds
&lt;av:double NULL&gt;[d(string)=5,5,0];
redimension_store(device_trial, Ds, true, avg(val) as av);</programlisting>Or, you can find the average value of all the samples for a single trial. This would be equivalent to finding the average of every column in the table:<programlisting>AFL% create array Dp
&lt;av:double NULL&gt;[d(string)=5,5,0];
AFL% redimension_store(device_trial, Dp, true, avg(val) as av);</programlisting></para>
    <sect2>
      <title>Redimensioning Arrays Containing Null Values</title>
      <para>Nullable attributes cannot be transformed into dimensions. For example, consider the 1-dimensional array redim_missing:<programlisting>AFL% show(redim_missing);scan(redim_missing);</programlisting><screen>[(&quot;redim_missing&lt;val1:string,val2:string NULL,val3:double&gt; 
[i=0:9,10,0]&quot;)]
[(&quot;0&quot;,&quot;0&quot;,1),
(&quot;0&quot;,&quot;1&quot;,0.540302),
(&quot;0&quot;,&quot;2&quot;,-0.416147),
(&quot;0&quot;,&quot;3&quot;,-0.989992),
(&quot;0&quot;,&quot;4&quot;,-0.653644),
(&quot;1&quot;,&quot;null&quot;,.7),
(&quot;1&quot;,&quot;1&quot;,0.841471),
(&quot;1&quot;,&quot;2&quot;,0.909297),
(&quot;1&quot;,&quot;3&quot;,0.14112),
(&quot;1&quot;,&quot;4&quot;,-0.756802)
]</screen></para>
      <para>Suppose you want to change the first two attributes into dimension indices and store the third attribute in a 2-dimensional array. Create an array redim_target to store the redimension results:<programlisting>AFL% CREATE ARRAY redim_target &lt;val3:double&gt;
     [val1(string)=2,2,0,val2(string)=5,5,0];</programlisting></para>
      <para>The array redim_missing contains a nullable attribute and a null-valued cell. You will need to use the substitute operator to update  redim_missing before redimensioning:<programlisting>AFL% store(build(&lt;exp1:string&gt;[i=0:0,1,0],0),subst_array);
AFL% store(substitute(redim_missing,subst_array),redim_source);</programlisting>This query outputs:<programlisting>[
(&quot;0&quot;,&quot;0&quot;,1),
(&quot;0&quot;,&quot;1&quot;,0.540302),
(&quot;0&quot;,&quot;2&quot;,-0.416147),
(&quot;0&quot;,&quot;3&quot;,-0.989992),
(&quot;0&quot;,&quot;4&quot;,-0.653644),
(&quot;1&quot;,&quot;0&quot;,.7),
(&quot;1&quot;,&quot;1&quot;,0.841471),
(&quot;1&quot;,&quot;2&quot;,0.909297),
(&quot;1&quot;,&quot;3&quot;,0.14112),
(&quot;1&quot;,&quot;4&quot;,-0.756802)
]</programlisting>You can now use redimension_store to turn redim_source into a 2-dimensional array:<programlisting>AFL% redimension_store(redim_source,redim_target);</programlisting>This query outputs:<screen>[
[(1),(0.540302),(-0.416147),(-0.989992),(-0.653644)],
[(.7),(0.841471),(0.909297),(0.14112),(-0.756802)]
]</screen></para>
    </sect2>
  </sect1>
  <sect1>
    <title>Array Transformations</title>
    <para>Once you have created,  loaded, and redimensioned a SciDB array, you may want to change some aspect  of that array. SciDB offers functionality to transform the elements of the array schema (attributes and dimensions). </para>
    <para>The array transformation operations produce a result array with a new schema. They do not modify the source array. Array transformation operations have the signature:<synopsis>AQL% <command>SELECT</command> * <command>FROM</command> operation(<replaceable>source_array</replaceable>,<replaceable>parameters</replaceable>)</synopsis>This query outputs a SciDB array. To store that array result, use the <code>
        <command>INTO</command>
      </code> clause:<synopsis>AQL% <command>SELECT</command> * <command>INTO</command> <replaceable>result_array</replaceable> <command>FROM</command> operation(<replaceable>source_array</replaceable>,<replaceable>parameters</replaceable>)</synopsis></para>
    <sect2>
      <title>Rearranging Array Data</title>
      <para>SciDB offers functionality to rearrange an array data:<itemizedlist>
          <listitem>
            <para><emphasis role="bold">Reshaping</emphasis> an array by changing the dimension sizes. is performed with the <code>reshape</code> command.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">Unpacking</emphasis> a multidimensional array into a 1-dimensional array is performed with the <code>unpack</code> command.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">Reversing</emphasis> the cells in a dimension is performed with the <code>reverse</code> command.</para>
          </listitem>
        </itemizedlist></para>
      <para>For example, you might want to reshape your array from an <emphasis>m</emphasis>-by-<emphasis>n</emphasis> array to a 2<emphasis>m</emphasis>-by-<emphasis>n</emphasis>/2 array. The <code>reshape</code> command allows you to transform an array into another compatible schema. Consider a 4<symbol role="symbolfont">&times;</symbol>4 array, <code>m4x4</code>, with contents and schema as follows:<programlisting>AFL% show(m4x4);scan(m4x4);
[(&quot;m4x4&lt;val:double&gt; [i=0:3,4,0,j=0:3,4,0]&quot;)]
[
[(0),(1),(2),(3)],
[(4),(5),(6),(7)],
[(8),(9),(10),(11)],
[(12),(13),(14),(15)]
]</programlisting>As long as the two array schemas have the same number of cells, you can use reshape to transform one schema into the other. A 4<symbol role="symbolfont">&times;</symbol>4 array has 16 cells, so you can use any schema with 16 cells, such as 8<symbol role="symbolfont">&times;</symbol>2, as the new schema:<programlisting>AQL% <command>SELECT</command> * <command>INTO</command> m8x2 <command>FROM</command> 
reshape(m4x4,&lt;val:double&gt;
[i2=0:7,8,0,j2=0:1,2,0]);</programlisting><screen>[
[(0),(1)],
[(2),(3)],
[(4),(5)],
[(6),(7)],
[(8),(9)],
[(10),(11)],
[(12),(13)],
[(14),(15)]
]</screen></para>
      <para>A special case of reshaping is unpacking a multidimensional array to a 1-dimensional  array. When you unpack an array, the coordinates of the array cells are stored in the attributes to the result array. This is particularly useful is you are planning to save your data to csv format. </para>
      <para>The <code>unpack</code> command takes the second and higher dimensions of an array and transforms them into attributes along the first dimension. The     result array consists of the dimension values of the input array with the attribute values from the corresponding cells appended. So, an attribute value <code>val</code> that was in   row 1, column 3 of a 2-dimensional array will be transformed into a cell with attribute values 1,3,<code>val</code>. For example, a 2-dimensional, 1-attribute array will output a 1-dimensional, 3-attribute array as follows:<programlisting>AQL% <command>SELECT</command> * <command>FROM</command> show(m3x3);</programlisting><screen>[(&quot;m3x3&lt;val:double&gt; [i=0:2,3,0,j=0:2,3,0]&quot;)]</screen><programlisting>AQL% <command>SELECT</command> * <command>INTO</command> m1 <command>FROM</command> unpack(m3x3,k);</programlisting><screen>[(0,0,0),
(0,1,1),
(0,2,2),
(1,0,3),
(1,1,4),
(1,2,5),
(2,0,6),
(2,1,7),
(2,2,8),
(0,0,0),
(0,0,0),
(0,0,0)]</screen><programlisting>AQL% <command>SELECT</command> * <command>FROM</command> show(m1);</programlisting><screen>[(&quot;m1&lt;i:int64,
j:int64,
val:double&gt;
[val1=0:15,4,0]&quot;)]</screen></para>
      <para>You can reverse the ordering of the data in each dimension of an array with the <code>reverse</code> command:<programlisting>AFL% show(m3x3);scan(m3x3);</programlisting><screen>[(&quot;m3x3&lt;val:double&gt; [i=0:2,3,0,j=0:2,3,0]&quot;)]
[[(0),(1),(2)],[(3),(4),(5)],[(6),(7),(8)]]</screen><programlisting>AQL% <command>SELECT</command> * <command>FROM</command> reverse(m3x3);</programlisting><screen>[
[(8),(7),(6)],
[(5),(4),(3)],
[(2),(1),(0)]]</screen></para>
    </sect2>
    <sect2>
      <title>Reduce an Array</title>
      <para>One common array task is selecting subsets of an array. SciDB allows you to reduce an array to contiguous subsets of the array cells or noncontiguous subsets of the array&apos;s cells.<itemizedlist>
          <listitem>
            <para>A <emphasis role="bold">subarray</emphasis> is  a contiguous block of cells from an array. This action is performed by the <code>subarray</code> command.</para>
          </listitem>
          <listitem>
            <para>An array <emphasis role="bold">slice</emphasis> is a subset of the array defined by planes of the array. This action is performed by the <code>slice</code> command.</para>
          </listitem>
          <listitem>
            <para>A dimension can be winnowed or <emphasis role="bold">thinned</emphasis> by selecting data at intervals along its entirety. This action is performed by the <code>thin</code> command.</para>
          </listitem>
        </itemizedlist></para>
      <para>You can select part of an existing array into another array with the <code>subarray</code> command. For example, you can select a 2-by-2 array of the last two values from each dimension of the array <code>m4x4</code> with the following <code>subarray</code> command:<programlisting>AFL% show(m4x4);scan(m4x4);
[(&quot;m4x4&lt;val:double&gt; 
[i=0:3,4,0,j=0:3,4,0]&quot;)]</programlisting><screen>[
[(0),(1),(2),(3)],
[(4),(5),(6),(7)],
[(8),(9),(10),(11)],
[(12),(13),(14),(15)]
]</screen><programlisting>AQL% <command>SELECT</command> * <command>FROM</command> subarray(m4x4,2,2,3,3);</programlisting><screen>[
[(10),(11)],
[(14),(15)]
]</screen></para>
      <para>If you have a 3-dimensional array,  you might want to select just a flat 2-dimensional slice, as like the cross-hatched section of this image:<informalfigure>
          <mediaobject>
            <imageobject>
              <imagedata scale="60" fileref="../graphics/slice_3d.png"/>
            </imageobject>
          </mediaobject>
        </informalfigure></para>
      <para>For example, you can select the data in a horizontal slice in the middle of a 3-dimensional array <code>m3x3x3</code> by using the <code>slice</code> command and specifying the value for    dimension <code>k</code>:<programlisting>AFL% show(m3x3x3);scan(m3x3x3);
[(&quot;m3x3x3&lt;val:double&gt;
[i=0:2,3,0,j=0:2,3,0,k=0:2,3,0]&quot;)]</programlisting><screen>[
[[(0),(1),(2)],
[(4),(5),(6)],
[(8),(9),(10)]
],
[[(7),(8),(9)],
[(11),(12),(13)],
[(15),(16),(17)]
],
[
[(14),(15),(16)],
[(18),(19),(20)],
[(22),(23),(24)]
]
]</screen><programlisting>AFL% slice(m3x3x3,k,1);</programlisting><screen>[
[(1),(5),(9)],
[(8),(12),(16)],
[(15),(19),(23)]
]</screen></para>
      <para>You may want to sample data uniformly across an entire dimension. The <code>thin</code> command selects elements from  given array dimensions at  defined intervals. For example, you can select every other element from every other row:<programlisting>AFL% show(m4x4);scan(m4x4);
[(&quot;m4x4&lt;val:double&gt; 
[i=0:3,4,0,j=0:3,4,0]&quot;)]</programlisting><programlisting>[
[(0),(1),(2),(3)],
[(4),(5),(6),(7)],
[(8),(9),(10),(11)],
[(12),(13),(14),(15)]
]</programlisting><programlisting>AQL% <command>SELECT</command> * <command>FROM</command> thin(m4x4,1,2,0,2);</programlisting><screen>[
[(4),(6)],
[(12),(14)]
]</screen></para>
    </sect2>
  </sect1>
  <sect1>
    <title>Changing Array Attributes</title>
    <para>An array&apos;s attributes contain the data stored in the array. You can transform attributes by<itemizedlist>
        <listitem>
          <para>Changing the name of the attribute.</para>
        </listitem>
        <listitem>
          <para>Adding an attribute.</para>
        </listitem>
        <listitem>
          <para>Changing the order of attributes in a cell.</para>
        </listitem>
        <listitem>
          <para>Deleting an attribute.</para>
        </listitem>
      </itemizedlist></para>
    <para>You can change the name of an attribute with the <code>attribute_rename</code> command:<programlisting>AQL% <command>SELECT</command> * <command>INTO</command> m3x3_new <command> FROM</command> attribute_rename(m3x3,val,val2);</programlisting><screen>[
[(0),(1),(2)],
[(3),(4),(5)],
[(6),(7),(8)]
]</screen><programlisting>AQL% <command>SELECT</command> * <command>FROM</command> show(m3x3_new);</programlisting><screen>[(&quot;m3x3_new&lt;val2:double&gt; [i=0:2,3,0,j=0:2,3,0]&quot;)]</screen></para>
    <para>You can add attributes to an existing array with the <code>apply</code> command:<programlisting>AQL% <command>SELECT</command> * 
    <command>INTO</command> m3x3_new_attr 
    <command>FROM</command> apply(m3x3,val2,val+10,val3,pow(val,2));</programlisting><screen>[
[(0,10,0),(1,11,1),(2,12,4)],
[(3,13,9),(4,14,16),(5,15,25)],
[(6,16,36),(7,17,49),(8,18,64)]
]</screen><programlisting>AQL% <command>SELECT</command> * <command>FROM</command> show(m3x3_new_attr);</programlisting><screen>[(&quot;m3x3_new_attr
&lt;val:double,val2:double,val3:double&gt; 
[i=0:2,3,0,j=0:2,3,0]&quot;)]</screen></para>
    <para>You can select a subset of an array&apos;s attributes and return them in any order with the <code>project</code> command. <programlisting>AQL% <command>SELECT</command> * <command>FROM</command> project(m3x3_new_attr,val3,val2);</programlisting><screen>[
[(0,10),(1,11),(4,12)],
[(9,13),(16,14),(25,15)],
[(36,16),(49,17),(64,18)]
]</screen></para>
  </sect1>
  <sect1>
    <title>Changing Array Dimensions</title>
    <sect2>
      <title>Changing Chunk Size</title>
      <para>If you have created an array with a particular chunk size and then later find that you need a different chunk size, you can use the <code>repart</code> command to change the chunk size. For example, suppose you have an array that is 1000-by-1000 with chunk size 100 in each dimension:<programlisting>AQL% <command>SELECT</command> * <command>FROM</command> show(chunks);</programlisting><screen>[(&quot;chunks&lt;val1:double,val2:double&gt;
[i=0:999,100,0,j=0:999,100,0]&quot;)]</screen>You can repartition the chunks to be 10 along one dimension and 1000 in the other:</para>
      <programlisting>AQL% <command>SELECT</command> * 
     <command>INTO</command> chunks_part 
     <command>FROM</command> repart(chunks,&lt;val1:double,val2:double&gt;
     [i=0:999,10,0,j=0:999,1000,0]);</programlisting>
      <programlisting>AQL% <command>SELECT</command> * <command>FROM</command> show(chunks_part);</programlisting>
      <screen>[(&quot;chunks_part&lt;val1:double,val2:double&gt;
     [i=0:999,10,0,j=0:999,1000,0]&quot;)]</screen>
      <para>Repartitioning is also important if you want the change the chunk overlap to speed up nearest-neighbor or window aggregate queries.<programlisting>AQL% <command>SELECT</command> * 
     <command>INTO</command> chunks_overlap 
     <command> FROM</command> repart(chunks,&lt;val1:double,val2:double&gt;
     [i=0:999,100,10,j=0:999,100,10]);</programlisting></para>
    </sect2>
    <sect2>
      <title>Appending a Dimension</title>
      <para>You may need to append dimensions to existing arrays, particularly when you want to do more complicated transformations to your array. This example demonstrates how you can take slices from an existing array and then reassemble them into a array with a different schema. Consider the following 2-dimensional array:<programlisting>AFL% show(Dsp);scan(Dsp);</programlisting><screen>[(&quot;Dsp&lt;val:double&gt;
[d(string)=5,5,0,t(string)=5,5,0]&quot;)]

[
[(0.01),(30.36),(111.21),(242.56),(424.41)],
[(2.04),(42.49),(133.44),(274.89),(466.84)],
[(6.09),(56.64),(157.69),(309.24),(511.29)],
[(12.16),(72.81),(183.96),(345.61),(557.76)],
[(20.25),(91),(212.25),(384),(606.25)]
]</screen></para>
      <para>Suppose you want to examine a sample plane from each dimension of the array. You can use the slice command to select array slices from array <code>Dsp</code>:<programlisting>AQL% <command>SELECT</command> * <command>INTO</command> Dsp_slice_0 <command> FROM</command> slice(Dsp,s,&apos;device-0&apos;);

AQL% <command>SELECT</command> * <command>INTO</command> Dsp_slice_1 <command> FROM</command> slice(Dsp,s,&apos;device-1&apos;);

AQL% <command>SELECT</command> * <command>INTO</command> Dsp_slice_2 <command> FROM</command> slice(Dsp,s,&apos;device-2&apos;);</programlisting>The slices are 1-dimensional.<programlisting>AQL% <command>SELECT</command> * <command>FROM</command> show(Dsp_slice_0);</programlisting><screen>[(&quot;Dsp_slice_0
&lt;val:double&gt;
[t(string)=5,5,0]&quot;)]</screen>Concatenating these slices will create a 1-d array:<programlisting>AQL% <command>SELECT</command> * <command>INTO</command> Dsp_1d <command>FROM</command> concat(Dsp_slice_0,Dsp_slice_2);
AQL% <command>SELECT</command> * <command>FROM</command> show(Dsp_1d);</programlisting><screen>[(&quot;Dsp_1d&lt;val:double,
empty_indicator:indicator&gt; 
[t=0:9,5,0]&quot;)]</screen>To concatenate these arrays into a 2-dimensional array, you need to add a dimension to both. The <code>adddim</code> command will add a stub dimension to the array to increase its dimensionality.<programlisting>AQL% <command>SELECT</command> * <command>INTO</command> Dsp_new 
<command>FROM</command> concat(adddim(Dsp_slice_0, s), 
adddim(Dsp_slice_2, d));
AQL% <command>SELECT</command> * <command>FROM</command> show(Dsp_new);</programlisting><screen>[(&quot;Dsp_new&lt;val:double,
empty_indicator:indicator&gt;
[d=0:1,1,0,t(string)=5,5,0]&quot;)]</screen></para>
    </sect2>
  </sect1>
</chapter>
