<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter>
  <title>Aggregates</title>
  <para>SciDB supports commands to group data from an array and calculate summaries over those groups. These commands are called <emphasis>aggregates</emphasis>. SciDB provides the following types of aggregates based on how data is grouped:</para>
  <itemizedlist>
    <listitem>
      <para><emphasis>Grand aggregates</emphasis> compute aggregates over entire arrays.</para>
    </listitem>
    <listitem>
      <para><emphasis>Group-by aggregates</emphasis> compute summaries by grouping array data by dimension values.</para>
    </listitem>
    <listitem>
      <para><emphasis>Grid aggregates</emphasis> compute summaries for nonoverlapping subarrays.</para>
    </listitem>
    <listitem>
      <para><emphasis>Window aggregates</emphasis> compute summaries over a moving window  in an array.</para>
    </listitem>
  </itemizedlist>
  <para>This chapter uses example arrays <code>m4x4</code> and <code>m4x4_2attr</code>, which have the following schemas and contain the following values:<programlisting>AFL% show(m4x4);</programlisting><screen>[(&quot;m4x4&lt;attr1:double&gt; [x=0:3,4,0,y=0:3,4,0]&quot;)]</screen><programlisting>AFL% scan(m4x4);</programlisting><screen>[
[(0),(1),(2),(3)],
[(4),(5),(6),(7)],
[(8),(9),(10),(11)],
[(12),(13),(14),(15)]
]</screen><programlisting>AFL%  show(m4x4_2attr);</programlisting><screen>[(&quot;m4x4_2attr&lt;attr1:double,attr2:double&gt; 
[x=0:3,4,0,y=0:3,4,0]&quot;)]</screen><programlisting>AFL% scan(m4x4_2attr);</programlisting><screen>[
[(0,0),(1,2),(2,4),(3,6)],
[(4,8),(5,10),(6,12),(7,14)],
[(8,16),(9,18),(10,20),(11,22)],
[(12,24),(13,26),(14,28),(15,30)]
]</screen></para>
  <para>SciDB offers the following built-in aggregates.
</para>
  <informaltable frame="none">
    <tgroup cols="2">
      <colspec colname="c1" colwidth="20*"/>
      <colspec colname="c2" colwidth="60*"/>
      <tbody>
        <row>
<?dbfo keep-together="auto" ?>          <entry>
            <para><emphasis role="bold">Aggregate Function</emphasis></para>
          </entry>
          <entry>
            <para><emphasis role="bold">Definition</emphasis></para>
          </entry>
        </row>
        <row>
          <entry>
            <para><code>avg</code></para>
          </entry>
          <entry>
            <para> Average value</para>
          </entry>
        </row>
        <row>
          <entry>
            <para><code>count</code></para>
          </entry>
          <entry>
            <para> Number of nonempty elements (array count) and non-null elements <?linebreak?>(attribute count). </para>
          </entry>
        </row>
        <row>
          <entry>
            <para><code>max</code></para>
          </entry>
          <entry>
            <para> Largest value</para>
          </entry>
        </row>
        <row>
          <entry>
            <para><code>min</code></para>
          </entry>
          <entry>
            <para> Smallest value</para>
          </entry>
        </row>
        <row>
          <entry>
            <para><code>sum</code></para>
          </entry>
          <entry>
            <para> Sum of all elements</para>
          </entry>
        </row>
        <row>
          <entry>
            <para><code>stdev</code></para>
          </entry>
          <entry>
            <para> Standard deviation</para>
          </entry>
        </row>
        <row>
          <entry>
            <para><code>var</code></para>
          </entry>
          <entry>
            <para> Variance</para>
          </entry>
        </row>
      </tbody>
    </tgroup>
  </informaltable>
  <sect1>
    <title>Grand Aggregates</title>
    <para>Grand aggregates in SciDB calculate aggregates or summaries of attributes across an entire array. The syntax of the <code>
        <command>SELECT</command>
      </code> statement with a summary clause is:<programlisting>AQL% <command>SELECT</command> <replaceable>aggregate</replaceable><replaceable>(attribute</replaceable>),<replaceable>function</replaceable><replaceable>(attribute</replaceable>),...
     <command>INTO</command> <replaceable>dst-array</replaceable>
     <command>FROM</command> <replaceable>src-array</replaceable> | <replaceable>array-expression</replaceable>
     <command>WHERE</command> <replaceable>where-expression</replaceable></programlisting></para>
    <para>The output is a SciDB array with one attribute named for the summary type in the query and array dimensions determined by the size and shape of the result. </para>
    <para>For example, to select the maximum and the minimum values of the attribute <code>attr1</code> of the array <code>m4x4</code>:<programlisting>AQL% <command>SELECT</command> max(attr1),min(attr1) <command>FROM</command> m4x4;</programlisting><screen>[(15,0)]</screen>You can store the output of a query into a destination array, <code>m4x4_max_min</code> with an <code>
        <command>INTO</command>
      </code> clause:<programlisting>AQL% <command>SELECT</command> max(attr1),min(attr1)
     <command>INTO</command> m4x4_max_min 
     <command>FROM</command> m4x4;</programlisting>The destination array <code>m4x4_max_min</code> has schema:<screen>[(&quot;m4x4_max_min&lt;max:double NULL,min_1:double NULL&gt; [i=0:0,1,0]&quot;)]</screen></para>
    <para>To select the maximum value from the attribute val of <code>m4x4_2attr</code> and the minimum value from the attribute <code>val2</code> of <code>m4x4_2attr</code>:<programlisting>AQL% <command>SELECT</command> max(attr2),min(attr) 
     <command>FROM</command> m4x4_2attr;</programlisting><screen>[(30,0)]</screen></para>
    <note>
      <para>In the special case of a one-attribute array, you can omit the attribute name. For example, to select the maximum value from the attribute <code>attr1</code> of the array <code>m4x4</code>, use the AQL <code>
          <command>SELECT</command>
        </code> statement:<programlisting>AQL% <command>SELECT</command> max(m4x4);</programlisting><screen>[(15)]</screen></para>
    </note>
    <para>The AFL    <code>aggregate</code> operator also computes grand aggregates. To select the maximum value from the attribute val of <code>m4x4_2attr</code> and the minimum value from the attribute <code>val2</code> of <code>m4x4_2attr</code>:<programlisting>AFL% aggregate(m4x4_2attr, max(attr2),min(attr1));</programlisting><screen>[(30,0)]</screen></para>
    <para>SciDB  functions exclude null-valued data. For example, consider the following array <code>m4x4_null</code>:<screen>[
[(null),(null),(null),(null)],
[(null),(null),(null),(null)],
[(0),(0),(0),(0)],
[(null),(null),(null),(null)]
]</screen>The syntaxes <code>count(attr1)</code> and <code>count(*)</code> return different results:<programlisting>AQL% <command>SELECT</command> count(attr1) <command>AS</command> a, count(*) <command>AS</command> b 
     <command>FROM</command> m4x4_null;</programlisting><screen>[(4,16)]</screen></para>
    <para>One syntax, <code>count(attr1)</code>, shows only cells that have values that are not NULL. The other syntax, <code>count(*)</code>, counts all of the present cells (both NULL and not NULL).</para>
  </sect1>
  <sect1>
    <title>Group-By Aggregates</title>
    <para>Group-by aggregates allow you to group array data by array dimensions and summarize the data in those groups.</para>
    <para>AQL <code>
        <command>GROUP BY</command>
      </code> aggregates take a list of dimensions as the grouping criteria and  compute the aggregate function for each group. The result   is an array containing only the dimensions specified in the  <code>
        <command>GROUP BY</command>
      </code> clause and a single attribute per specified aggregate call. The syntax of the <code>
        <command>SELECT</command>
      </code> statement for a group-by aggregate is:<programlisting><command>SELECT</command> <replaceable>function</replaceable><replaceable>(attribute</replaceable>), <replaceable>function</replaceable><replaceable>(attribute</replaceable>), ...
  <command>INTO</command> <replaceable>dst-array</replaceable>
  <command>FROM</command> <replaceable>src-array</replaceable> | <replaceable>array-expression</replaceable>
  <command>WHERE</command> <replaceable>where-expression</replaceable>
  <command>GROUP BY</command> <replaceable>dimension</replaceable>, <replaceable>dimension</replaceable>, ...;</programlisting></para>
    <para>For example, this query selects the maximum value from the  attribute <code>val</code> of array <code>m4x4</code> grouped by dimension <code>x</code>:<programlisting>AQL% <command>SELECT</command> max(attr1) 
     <command>FROM</command> m4x4 
     <command>GROUP BY</command> x;</programlisting>This query outputs:<screen>[(3),(7),(11),(15)]</screen>which has schema:<screen>&lt;max:double NULL&gt; [x=0:3,4,0]</screen></para>
    <para>This query selects the maximum values from attribute <code>attr1</code> of array <code>m4x4</code> grouped by dimension <code>y</code>:<programlisting>AQL% <command>SELECT</command> max(attr1) <command>FROM</command> m4x4 <command>GROUP BY</command> y;</programlisting><screen>[(12),(13),(14),(15)]</screen></para>
    <para>The AFL <code>aggregate</code> operator takes dimension arguments to support group-by functionality. This query selects the maximum values from the dimension <code>y</code> and attribute <code>val</code> from the array <code>m4x4</code> using AFL:<programlisting>AFL% aggregate(m4x4, max(attr1),y);</programlisting><screen>[(12),(13),(14),(15)]</screen></para>
  </sect1>
  <sect1>
    <title>Grid Aggregates</title>
    <para>A grid aggregate selects  nonoverlapping subarrays  from an existing array and calculates an aggregate of each subarray. For example, if you have a 4x4 array, you can create 4 nonoverlapping 2x2 regions and calculate an aggregate for those regions. The array <code>m4x4</code> would be divided into 2x2 grids as follows:<informalfigure>
        <mediaobject>
          <imageobject>
            <imagedata scale="50" fileref="../graphics/grid_aggregates.png"/>
          </imageobject>
        </mediaobject>
      </informalfigure>The syntax of a grid aggregate statement is:<programlisting>AQL% <command>SELECT</command> <replaceable>function</replaceable><replaceable>(attribute</replaceable>), <replaceable>function</replaceable><replaceable>(attribute</replaceable>), ...
     <command>INTO</command> <replaceable>dst-array</replaceable>
     <command>FROM</command> <replaceable>src-array</replaceable> | <replaceable>array-expression</replaceable>
     <command>WHERE</command> <replaceable>where-expression</replaceable>
     <command>REGRID</command> <replaceable>dimension1-size</replaceable>, <replaceable>dimension2-size</replaceable>, ...;</programlisting></para>
    <para>For example, this statement finds the maximum and minimum values for each of the four grids in the previous figure:<programlisting>AQL% <command>SELECT</command> max(attr1), min(attr1)
     <command>FROM</command> m4x4 <command>REGRID</command> 2,2;</programlisting><screen>[
[(5,0),(7,2)],
[(13,8),(15,10)]
]</screen>This output  has schema:<screen>&lt;max:double NULL,min_1:double NULL&gt; [x=0:1,2,0,y=0:1,2,0]</screen></para>
    <para>In AFL, you can use the <code>regrid</code> operator:<programlisting>AFL% regrid(m4x4, 2,2, max(attr1),min(attr1));</programlisting><screen>[
[(5,0),(7,2)],
[(13,8),(15,10)]
]</screen></para>
  </sect1>
  <sect1>
    <title>Window Aggregates</title>
    <para>Window aggregates allow you to specify groups with a moving window. The window is defined by a size in each dimension. The window centroid starts at the first array element. The grouping starts at the first element of the array and moves in stride-major order from the lowest to highest value in each dimension. The syntax of a window aggregate statement is:<programlisting>AQL% <command>SELECT</command> <replaceable>function</replaceable><replaceable>(attribute</replaceable>), <replaceable>function</replaceable><replaceable>(attribute</replaceable>), ...
     <command>INTO</command> <replaceable>dst-array</replaceable>
     <command>FROM</command> <replaceable>src-array</replaceable> | <replaceable>array-expression</replaceable>
     <command>WHERE</command> <replaceable>where-expression</replaceable>
     <command>WINDOW</command> <replaceable>dimension1-size</replaceable>, <replaceable>dimension2-size</replaceable>, ...;</programlisting></para>
    <para>For example, you can use a window to calculate a running sum for a 3x3 window on array <code>m4x4</code>. </para>
    <informalfigure>
      <mediaobject>
        <imageobject>
          <imagedata scale="60" fileref="../graphics/window_aggregates.png"/>
        </imageobject>
      </mediaobject>
    </informalfigure>
    <para>In AQL, you would use this statement:<programlisting>AQL% <command>SELECT</command> sum(attr1) 
     <command>FROM</command> m4x4 
     <command>WINDOW</command> 3,3;</programlisting>Which returns values:<screen>[
[(10),(18),(24),(18)],
[(27),(45),(54),(39)],
[(51),(81),(90),(63)],
[(42),(66),(72),(50)]
]</screen>with schema:<programlisting>&lt;sum:double NULL&gt; [x=0:3,4,0,y=0:3,4,0]</programlisting>Since the window centroid starts at cell {0,0}, the region of the window that is outside the array boundary is not counted in the aggregation. The window always returns the same dimensions as the input array. If the window size is even, the query takes the preceding cells first. For example, a 1-dimensional window size of 4 means that the window takes the values of two 2 preceding cells,   the value of the current cell, and the value of 1 cell following. </para>
    <para>In AFL, you would use the <code>window</code> operator:<programlisting>AFL% window(m4x4,3,3,sum(attr1));</programlisting><screen>[
[(10),(18),(24),(18)],
[(27),(45),(54),(39)],
[(51),(81),(90),(63)],
[(42),(66),(72),(50)]
]</screen></para>
  </sect1>
</chapter>
