<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter remap="h1">
  <title>Matrix Algebra</title>
  <sect1 remap="h2">
    <title>inverse</title>
    <para>The <literal condition="western">inverse</literal> operator produces the matrix inverse of a square matrix. The input matrix must be invertible, i.e., the determinant of the matrix must be nonzero. The inverse is calculated using LU decomposition executed on a single node (the coordinator).</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <screen>inverse(array)</screen>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <orderedlist>
      <listitem>
        <para> Create a 2-dimensional array <literal condition="western">inv_33</literal>. </para>
      </listitem>
    </orderedlist>
    <screen>create array inv_33 &lt; val : double &gt; [ I=1:3,3,0, J=1:3,3,0 ];
store(build(inv_33, 1.0/(I+J-1)), inv_33);
scan(inv_33);</screen>
    <orderedlist>
      <listitem>
        <para> Find the matrix inverse of <literal condition="western">inv_33</literal>: </para>
      </listitem>
    </orderedlist>
    <screen>inverse(inv_33);</screen>
    <orderedlist>
      <listitem>
        <para> Remove <literal condition="western">inv_33</literal>: </para>
      </listitem>
    </orderedlist>
    <screen>remove(inv_33);</screen>
    <para><emphasis role="bold">NOTES:</emphasis></para>
    <orderedlist>
      <listitem>
        <para> <literal condition="western">inverse</literal>() accepts a square matrix with double data type attribute only. Other numeric attribute data types are not supported. </para>
      </listitem>
      <listitem>
        <para> <literal condition="western">inverse</literal>() is not a parallel algorithm. For parallel implementations of matrix inverse please refer to the <literal condition="western">solve</literal>() and <literal condition="western">svd</literal>() operators. </para>
      </listitem>
    </orderedlist>
    <para><emphasis role="bold">See Also</emphasis>:</para>
    <itemizedlist>
      <listitem>
        <para>Matrix Inverse at Wolfram&apos;s Mathworld </para>
      </listitem>
    </itemizedlist>
  </sect1>
  <sect1 remap="h2">
    <title>multiply</title>
    <para>The multiply operator performs matrix multiplication on two input matrices and returns a result matrix.</para>
    <para>Signature:</para>
    <screen>multiply(array, array)</screen>
    <para>Both inputs must be compatible for the multiply operation, and both must have a single attribute. To be compatible, two matrices must have the same size of &apos;inner&apos; dimension and same chunk size along that dimension.</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <orderedlist>
      <listitem>
        <para> Create a 10-by-6 array <literal condition="western">lhs</literal> with one attribute of type double: </para>
      </listitem>
    </orderedlist>
    <screen>create array lhs &lt;val: double&gt; [ I=1:10,5,0, J=1:6,3,0 ];
store(build(lhs, (I*3)+J), lhs);</screen>
    <orderedlist>
      <listitem>
        <para> Create a 6-by-15 array: </para>
      </listitem>
    </orderedlist>
    <screen>create array rhs &lt;val: double&gt; [ I=1:6,3,0, J=1:15,5,0 ];
store(build(rhs, (I*3)+J), rhs);</screen>
    <orderedlist>
      <listitem>
        <para> Multiply the two arrays. The result is 10-by-15: </para>
      </listitem>
    </orderedlist>
    <screen>multiply(lhs, rhs);</screen>
    <orderedlist>
      <listitem>
        <para> Remove the arrays: </para>
      </listitem>
    </orderedlist>
    <screen>remove(lhs);
remove(rhs);</screen>
    <para><emphasis role="bold">NOTES:</emphasis></para>
    <orderedlist>
      <listitem>
        <para> <emphasis>multiply</emphasis> supports all numeric data types (double, float, and all signed and unsigned integer data types). </para>
      </listitem>
      <listitem>
        <para> If two input arrays contain multiple attributes the attribute to be used in the multiply operator must be obtained using project(). </para>
      </listitem>
      <listitem>
        <para> Matrix multiply currently does not accept matrices with NULL attributes. Empty cells in the inputs are treated as 0. </para>
      </listitem>
      <listitem>
        <para> If two input matrices do not have compatible chunk sizes, the AFL repart() operator must be used to produce compatible matrices prior to multiplication. </para>
      </listitem>
      <listitem>
        <para> multiply() does not create metadata or storage objects unless the result is added in memory with the <literal condition="western">store</literal>() operator. </para>
      </listitem>
    </orderedlist>
  </sect1>
  <sect1 remap="h2">
    <title>normalize</title>
    <para>Divide each element of a vector by the square root of the sum of squares of the elements.</para>
    <para><emphasis role="bold">Signature</emphasis>: normalize(<emphasis> array</emphasis>,<emphasis> attribute : attribute_identifier</emphasis> )</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen>scan(v10);

[(1),(2),(3),(4),(5),(6),(7),(8),(9),(10)]

normalize(v10);

[(0.0509647),(0.101929),(0.152894),(0.203859),(0.254824),
   (0.305788),(0.356753),(0.407718),(0.458682),(0.509647)]</screen>
  </sect1>
  <sect1 remap="h2">
    <title>transpose</title>
    <para>Performs the linear algebraic matrix transpose.</para>
    <para>Signature:</para>
    <screen>transpose (array)</screen>
    <para>The transpose operator accepts an array which may contain any number of attributes and dimensions. Attributes may be of any type. If the array contains dimensions d1, d2, d3, ..., dn the result contains the dimensions in reverse order dn, ..., d3, d2, d1.</para>
    <para><emphasis role="bold">Example 1</emphasis>:</para>
    <orderedlist>
      <listitem>
        <para> Create an array E with two dimensions i and j and int32 attribute x: </para>
      </listitem>
    </orderedlist>
    <screen>CREATE ARRAY E &lt;x: int32&gt; [ i=0:2,3,0, j=0:2,3,0 ];
store(build(E, i), E);
scan(E);</screen>
    <orderedlist>
      <listitem>
        <para> Transpose the array: </para>
      </listitem>
    </orderedlist>
    <screen>transpose(E);</screen>
    <orderedlist>
      <listitem>
        <para> Remove the array E: </para>
      </listitem>
    </orderedlist>
    <screen>remove(E);</screen>
    <para><emphasis role="bold">Example 2</emphasis>:</para>
    <orderedlist>
      <listitem>
        <para> Create a 2-by-3 array: </para>
      </listitem>
    </orderedlist>
    <screen>CREATE ARRAY E2x3 &lt;x: int32 &gt; [ i=0:1,2,0, j=0:2,3,0 ];
store(build(E2x3, x+1), E2x3);
scan (E2x3);</screen>
    <orderedlist>
      <listitem>
        <para> Transpose the array. The resulting array is 3-by-2: </para>
      </listitem>
    </orderedlist>
    <screen>transpose(E2x3); </screen>
  </sect1>
</chapter>
