<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter remap="h1">
  <title>SciDB Plugins: Extending SciDB Functionality</title>
  <para>User-defined extensions to SciDB functionality are referred to as<emphasis> plugins</emphasis>. SciDB supports user-defined functions (UDFs), user-defined types (UDTs), and user-defined operators (UDOs).</para>
  <sect1 remap="h2">
    <title>Extensibility: Types and Functions</title>
    <para>Out of the box, SciDB provides users with a standard set of data types; integer, float/double, and string. Scientific and large-scale analytic applications often require other data types such as complex numbers, rational numbers, two-dimensional points, or others. Some applications call for specific mathematical functions (such as greatest common factor of two integers or non-uniform random number generation) that SciDB does not provide by default. SciDB&apos;s extensibility mechanism allows users to add their own implementation of types and functions to the SciDB engine.</para>
    <para>Suppose a SciDB application requires a rational number datatype. Rather than use double precision, the user wants to store an integer-type numerator and denominator pair. As part of the the new type&apos;s functionality users will also want to support basic arithmetic ( +, -, *, / ) and logical (&lt;, &lt;=, =, &gt;=, &gt;, &lt;&gt;) functionality.</para>
    <para>At the level of the AQL query language, the new type can be used as follows:</para>
    <screen>create array rational_example &lt; N : rational &gt; [ I=0:99,10,0, J=0:99,10,0 ]

# Q1: 

SELECT COUNT(*)
   FROM rational_example AS R
 WHERE R.N = rational(1,2);

# Q2: 

SELECT str(R.N) 
  FROM rational_example AS R
 WHERE R.N + rational(1,4) &gt; rational(1,2);
  </screen>
    <para>So far as a user&apos;s queries are concerned, there will be no difference between the way a built-in type and a user-defined type (or function) works. There are, however, a couple of things to be aware of:</para>
    <orderedlist>
      <listitem>
        <para> All type conversions need to be explicit. SciDB does not (yet) support implicit casting. </para>
      </listitem>
      <listitem>
        <para> Client applications can only accommodate a limited set of types: doubles, integers, and strings. When you write queries (using iquery, say) the query&apos;s result needs to explicitly convert result types into something that the client understands. </para>
      </listitem>
      <listitem>
        <para> While it is quite possible to write complex and computationally expensive UDFs (we include an example of a prime number factorization) it&apos;s generally a better practice to build UDFs as small, self-contained units of functionality and then to combine them using the SciDB query language&apos;s facilities. </para>
      </listitem>
      <listitem>
        <para> We do not (yet) support features like embedding queries within UDFs, or plugins that do anything more sophisticated than take a vector of scalar values and return a single scalar type result. </para>
      </listitem>
    </orderedlist>
  </sect1>
  <sect1 remap="h2">
    <title>SciDB Plugin Examples</title>
    <para>SciDB includes multiple example extensions in the ~/examples folder located beneath the SciDB root directory. These examples are:</para>
    <informaltable frame="none">
      <tgroup cols="2">
        <colspec colname="c1" colwidth="50*"/>
        <colspec colname="c2" colwidth="50*"/>
        <tbody>
          <row>
            <entry>
              <para> <emphasis role="bold">Name</emphasis></para>
            </entry>
            <entry>
              <para> <emphasis role="bold">Description</emphasis></para>
            </entry>
          </row>
          <row>
            <entry>
              <para> complex</para>
            </entry>
            <entry>
              <para> Complex Number UDT (a + b.i), together with the associated algebraic operations, and equality.</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> rational</para>
            </entry>
            <entry>
              <para> Rational Number UDT (int64 numerator and denominator) together with the associated algebra operations and ordering comparisons</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> point</para>
            </entry>
            <entry>
              <para> 2-D Point UDT. Double precision X and Y</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> more_math</para>
            </entry>
            <entry>
              <para> A selection of user-defined functions which perform useful mathematical operations.</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </sect1>
  <sect1 remap="h2">
    <title>SciDB Plugins Architecture</title>
    <para>The basic architecture of a SciDB Plugin works as follows. The algorithms implemented within the SciDB engine are designed to treat instances of data type values as<emphasis> black box</emphasis> memory segments. For example, all that the SciDB engine &quot;knows&quot; about the contents of the Complex Number data type is that it is 16 bytes long. The code that needs to know about the contents of these 16 bytes is implemented by the user in their own C/C++, which they compile into a shared library.</para>
    <para>At run-time, the SciDB engine dynamically links this shared library and calls the functions it contains to perform the operations specified in the query.</para>
    <para>For example, the user-written &apos;C&apos; code to add two complex numbers looks like this:</para>
    <screen>//
// This is the struct that describes how the 16 bytes of data that makes up\
 an instance 
// of a SciDB Complex UDT is organized.
struct Complex
{
    double re;
    double im;
};

//
// This is the code that takes data from the SciDB engine, performs the add\
ition, and deposits
// the return result in an appropriately sized &quot;black box&quot; of bytes. The SciD\
B engine takes 
// this return result and stores it, or passes it on to another function. 
static void addComplex(const Value** args, Value* res, void*)
{
    Complex&amp; a = *(Complex*)args[0]-&gt;data();
    Complex&amp; b = *(Complex*)args[1]-&gt;data();
    Complex&amp; c = *(Complex*)res-&gt;data();

    c.re = a.re + b.re;    
    c.im = a.im + b.im;
}
</screen>
    <para>When it parses a query like the one labeled &quot;Q2&quot; above, the SciDB engine checks to ensure that it had been provided with a shared library containing code to perform the plus ( Type, Type ) -&gt; Type operation. In this case, SciDB would look for a function named &quot;+&quot; that took two arguments of the appropriate type (in this case, a pair of complex number instances). Then at run time the SciDB engine would assemble the necessary 16-byte &quot;black boxes&quot;, invoke the function &apos;C&apos; addComplex(), and deal with the value it computed.</para>
  </sect1>
  <sect1 remap="h2">
    <title>User-Defined Functions: How SciDB Provides Datatype Instances</title>
    <para>As you can see from the example code above, SciDB uses a typesystem::Value class to encapsulate information about all type value instances. The Values class provides a set of methods for getting and setting the &quot;value&quot; of the class for each of the SciDB built-in types; getType() and setType(), or more explicitly (in the case of a typesystem::Value val; instance that contains a string) val.getString() and val.setString().</para>
    <para>From the perspective of the SciDB engine, all UDFs have the same basic signature:</para>
    <screen>void functionUDF(const Value** args, Value* res, void*)
{

}
</screen>
    <para>Each function must &quot;know&quot; how many arguments it is to receive. These arguments are obtained from the vector of typesystem::Value pointers that makes up the first argument. Each UDF (currently) returns a single result and the location where this result is to be placed is passed in by reference in the second argument. The final argument is a pointer to a data structure that conveys information about the state of the engine, and is a means of passing data between repeated calls to the UDF within the same query.</para>
  </sect1>
  <sect1 remap="h2">
    <title>Loading a Plugin</title>
    <para>Each of these example plugins included with the SciDB distribution is built (by default) at the time we build the core engine. However, SciDB does not load unregistered plugins when it starts up. To use one of the examples you need to load it into the SciDB instance. The following figure illustrates how to load shared libraries containing plugins into SciDB using first, the AFL interface, and second, our AQL query language.</para>
    <screen>--
-- AFL load_library() operation
load_library ( &apos;librational.so&apos; )

--
-- AQL &apos;load library&apos; syntax
load library &apos;librational.so&apos;;</screen>
    <para>The act of loading a plugin shared library first registers the library in the SciDB system catalogs. Then it opens and examines the shared library to store its contents with SciDB&apos;s internal extension management subsystem. Shared library module which are registered with the SciDB instance will be loaded at system start time.</para>
    <para>If you want to unload library run:</para>
    <screen>--
-- AFL unload_library() operation
unload_library(&apos;libpoint1&apos;)

--
-- AQL &apos;unload library&apos; syntax
unload library &apos;libpoint1&apos;</screen>
    <para>This command will unregister the library in the system catalog. The library will not be loaded on consecutive restart, but it might not be unloaded immediately because some queries can be using it.</para>
  </sect1>
  <sect1 remap="h2">
    <title>Tutorial: Creating SciDB Plugins</title>
    <para>This section explains the steps needed for creating a new plugin for SciDB.</para>
    <sect2 remap="h3">
      <title>Designing your UDT</title>
      <para>Your UDT will need the following kinds of UDFs.</para>
      <orderedlist>
        <listitem>
          <para> UDFs that construct instances of your new type based on the values of other types. In general the types you will use as input to these UDFs will be built in types. For example, it is typical to use a string as a source for a new data type&apos;s contents. For example, the following UDF converts a string with a particular format into an instance of a rational number UDT. </para>
        </listitem>
      </orderedlist>
      <screen>//
// This is the struct used to store the data inside SciDB. 
typedef struct
{
    int64_t num;
    int64_t denom;
} SciDB_Rational;

void str2Rational(const Value** args, Value* res, void*)
{
        int64_t n, d;
    SciDB_Rational* r = (SciDB_Rational*)res-&gt;data();

    if (sscanf(args[0]-&gt;getString(), &quot;(%&quot;PRIi64&quot;/%&quot;PRIi64&quot;)&quot;, &amp;n, &amp;d) != 2)
        throw PLUGIN_USER_EXCEPTION(&quot;librational&quot;, SCIDB_SE_UDO, RATIONAL_E_C\
ANT_CONVERT_TO_RATIONAL)
            &lt;&lt; args[0]-&gt;getString();

        if ((0 == d) &amp;&amp; (0 == n))
                d = 1;
                
        boost::rational&lt;int64_t&gt;rp0(n, d);
        r-&gt;num   = rp0.numerator();
        r-&gt;denom = rp0.denominator();

}
</screen>
      <para>Note that the &quot;string to UDT&quot; conversion function is particularly important. type ( string ) -&gt; type is the UDF used by the load() operation to bulk ingest data into SciDB.</para>
      <orderedlist>
        <listitem>
          <para> UDFs that convert your UDT back into a built-in type, or a number of built-in types. In the case of the complex type, for example, you can either write a UDF that composes the 16 bytes into a string, or else a pair of UDFs that extract the real and imaginary portions of the type. </para>
        </listitem>
      </orderedlist>
      <screen>static void reComplex(const Value** args, Value* res, void*)
{
   Complex&amp; a = *(Complex*)args[0]-&gt;data();
   res-&gt;setDouble(a.re);
}

static void imComplex(const Value** args, Value* res, void*)
{
   Complex&amp; a = *(Complex*)args[0]-&gt;data();
   res-&gt;setDouble(a.im);
}
</screen>
      <para>Remember that SciDB will not perform implicit casting. You need to include these UDFs in any queries that pull these values out of database.</para>
      <orderedlist>
        <listitem>
          <para> UDFs that perform common type operations, such as simple arithmetic or relational operations will not need to support all datatypes. While it makes sense to support the full set of relational operators for a datatype that can be ordered (such as rational number), a values in the complex domain cannot be ordered (for sorting, say). All SciDB needs for ordering are two UDFs: one to return TRUE when two type values are equal, and a second to return TRUE when one type is less than another. </para>
        </listitem>
      </orderedlist>
      <screen>void rationalLT(const Value** args, Value* res, void * v)
{
    SciDB_Rational* r0 = (SciDB_Rational*)args[0]-&gt;data();
    SciDB_Rational* r1 = (SciDB_Rational*)args[1]-&gt;data();

        check_zero ( r0 );
        check_zero ( r1 );

        boost::rational&lt;int64_t&gt;rp0(r0-&gt;num, r0-&gt;denom);
        boost::rational&lt;int64_t&gt;rp1(r1-&gt;num, r1-&gt;denom);

        if ( rp0 &lt; rp1 ) 
        res-&gt;setBool(true);
        else
        res-&gt;setBool(false);
}

void rationalEQ(const Value** args, Value* res, void * v)
{
    SciDB_Rational* r0 = (SciDB_Rational*)args[0]-&gt;data();
    SciDB_Rational* r1 = (SciDB_Rational*)args[1]-&gt;data();

        check_zero ( r0 );
        check_zero ( r1 );

        boost::rational&lt;int64_t&gt;rp0(r0-&gt;num, r0-&gt;denom);
        boost::rational&lt;int64_t&gt;rp1(r1-&gt;num, r1-&gt;denom);

        if ( rp0 == rp1 ) 
        res-&gt;setBool(true);
        else
        res-&gt;setBool(false);
}
</screen>
      <orderedlist>
        <listitem>
          <para> UDFs that are necessary to support the integration of the UDT with other facilities; aggregates like AVG(), MAX() and MIN(), for example. MAX() and MIN() use the UDFs that order instance values. If your type has a peculiar requirements for MAX() and MIN(), it might be reasonable to add these UDFs. </para>
        </listitem>
      </orderedlist>
    </sect2>
    <sect2 remap="h3">
      <title>Exceptions and Error Handling</title>
      <para>Your UDFs will often need to check for errors and exceptions in their code. In SciDB, we provide facilities to report to the SciDB engine that your UDF has encountered an error, and what kind of error. Doing this allows the SciDB engine to terminate the query and report some useful status information to the log file. Errors and exceptions are thrown using a macro USER_EXCEPTION( error_code, description : string ).</para>
      <screen>    throw PLUGIN_USER_EXCEPTION(&lt;plugin name&gt;, SCIDB_SE_UDO, \
    &lt;plugin error code&gt;) &lt;&lt; &lt;args&gt;;</screen>
      <para>For example,</para>
      <screen>void str2Rational(const Value** args, Value* res, void*)
{
        int64_t n, d;
    SciDB_Rational* r = (SciDB_Rational*)res-&gt;data();

    if (sscanf(args[0]-&gt;getString(), &quot;(%&quot;PRIi64&quot;/%&quot;PRIi64&quot;)&quot;, &amp;n, &amp;d) != 2)
        throw PLUGIN_USER_EXCEPTION(&quot;librational&quot;, SCIDB_SE_UDO, RATIONAL_E_C\
ANT_CONVERT_TO_RATIONAL)
            &lt;&lt; args[0]-&gt;getString();

        if ((0 == d) &amp;&amp; (0 == n))
                d = 1;
                
        boost::rational&lt;int64_t&gt;rp0(n, d);
        r-&gt;num   = rp0.numerator();
        r-&gt;denom = rp0.denominator();

}</screen>
      <para>For a full list of the terse error codes that you can throw from within a UDF, consult the &apos;~/include/system/ErrorCodes.h&apos; file.</para>
    </sect2>
    <sect2 remap="h3">
      <title>Registering Your &apos;C&apos; Functions as UDFs</title>
      <para>Once you have implemented your functions, you should register them with the SciDB facilities for extracting information from a shared library. The SciDB install provides a set of &apos;C&apos; macros to do this. These macros are:</para>
      <informaltable frame="none">
        <tgroup cols="3">
          <colspec colname="c1" colwidth="33*"/>
          <colspec colname="c2" colwidth="33*"/>
          <colspec colname="c3" colwidth="33*"/>
          <tbody>
            <row>
              <entry>
                <para> <emphasis role="bold">Macro Name</emphasis></para>
              </entry>
              <entry>
                <para> <emphasis>Description </emphasis></para>
              </entry>
              <entry>
                <para> Example</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> REGISTER_TYPE ( name, length )</para>
              </entry>
              <entry>
                <para> Instructs SciDB to register a new UDT in it&apos;s catalogs with the name provided (note that this argument to the macro is not a string) and the length, in bytes, of the type instance values.</para>
              </entry>
              <entry>
                <para> REGISTER_TYPE ( complex, 16 )</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> REGISTER_FUNCTION ( name, input argument types, output argument type, function pointer)</para>
              </entry>
              <entry>
                <para> Instructs SciDB to register a new UDF in its catalogs. The new UDF can be called in AQL or AFL using the first argument name (again, not a string), the the function is expected to take a list of argument types as input, and return a value of the type provided. The actual reference to the function you want SciDB to call is the last argument to the macro.</para>
              </entry>
              <entry>
                <para> REGISTER_FUNCTION(+, (&quot;complex&quot;, &quot;complex&quot;), &quot;complex&quot;, addComplex);</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> REGISTER_CONVERTER(input type, output type, conversion cost, function pointer)</para>
              </entry>
              <entry>
                <para> From time to time SciDB needs to convert types, and it can require UDFs to perform this operation. This macro is how you register conversions.</para>
              </entry>
              <entry>
                <para> REGISTER_CONVERTER(string, complex, EXPLICIT_CONVERSION_COST, string2complex);</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>
    <sect2 remap="h3">
      <title>A Simple Recipe</title>
      <para>The simplest way to implement your own plugin library is to copy the style of the examples.</para>
      <orderedlist>
        <listitem>
          <para> Create a new directory in parallel to the one that implements one of the examples, say the complex type. </para>
        </listitem>
      </orderedlist>
      <para>In the ~/examples/CMakeLists.txt file, add new line with name of new directory. Let&apos;s say the new directory is named &quot;point1&quot;</para>
      <screen>add_subdirectory(&quot;complex&quot;)   &lt;-- already exists.
add_subdirectory(&quot;point1&quot;)       &lt;-- the reference to your new plugin director\
y</screen>
      <para>At this point you will want to rename <literal condition="western">point1/complex.cpp</literal> to something more appropriate for the purposes of the library.</para>
      <orderedlist>
        <listitem>
          <para> Change the contents of the new <literal condition="western">~/examples/point1/CMakeLists.txt</literal> file to get the server to build your new plugin library. </para>
        </listitem>
      </orderedlist>
      <orderedlist>
        <listitem>
          <para> Make your modifications in the new source code file: <literal condition="western">~/examples/point1/point.cpp</literal>. </para>
        </listitem>
      </orderedlist>
      <orderedlist>
        <listitem>
          <para> Using &quot;make&quot;, build &quot;libpoint1.so&quot;. It will be placed into the plugins directory folder alongside &quot;libcomplex.so&quot;. </para>
        </listitem>
      </orderedlist>
      <orderedlist>
        <listitem>
          <para> Load your new library module. </para>
        </listitem>
      </orderedlist>
    </sect2>
  </sect1>
  <sect1 remap="h2">
    <title>User-Defined Operators</title>
    <para>The most complicated user-defined objects are user-defined operators. Every operator in SciDB is a pair of objects:</para>
    <itemizedlist>
      <listitem>
        <para> A<emphasis> logical operator</emphasis> class, and </para>
      </listitem>
      <listitem>
        <para> A<emphasis> physical operator</emphasis> class. </para>
      </listitem>
    </itemizedlist>
    <para>The main purpose of logical operator is:</para>
    <itemizedlist>
      <listitem>
        <para> to infer an array schema, and </para>
      </listitem>
      <listitem>
        <para> to provide information about expected inputs and parameters of the operator. </para>
      </listitem>
    </itemizedlist>
    <para>Ideally, the logical operator is common to every operator of the same class. However, the logical operator can have several implementations called<emphasis> physical operators</emphasis>. The main purpose of physical operator to execute operator implementation.</para>
    <para>Every operator, logical or physical, can have a<emphasis> state</emphasis>. States are created by special factory methods. Every instance of an operator is a new instance of the class. This means that you can add a new field to inherited classes.</para>
    <sect2 remap="h3">
      <title>Creating a User-Defined Operator</title>
      <para>The easiest way to create a new operator is to find the closest built-in operator, copy-and-paste it into a separate folder, and change the existing implementation into the desired implementation.</para>
      <para>In the <literal condition="western">example/operators</literal> directory in your SciDB build you can find a stub example for creating a plugin with user-defined operators. You can replace the example stubs by the built-in operator implementation that is closest to what you want your new operator to do and then rename internal classes and operator names.</para>
      <para>The following sections provide short descriptions of base classes for logical and physical operators and descriptive comments about class members.</para>
      <sect3 remap="h4">
        <title>Logical Operator Example</title>
        <para>The logical operator must be inherit from the LogicalOperator class and implement the methods constructor and inferSchema:</para>
        <screen>class LogicalStub : public LogicalOperator
{
public:
    LogicalStub(const std::string&amp; logicalName, const std::string&amp; alias):
        LogicalOperator(logicalName, alias)
    {
        /**
         * See built-in operators implementation for example
         */
    }

    ArrayDesc inferSchema(std::vector&lt;ArrayDesc&gt; schemas, boost::shared_ptr&lt;Qu\
ery&gt; query)
    {
        /**
         * See built-in operators implementation for example
         */
        return ArrayDesc();
    }

};</screen>
        <para>The constructor contains code for the declaration of possible inputs and parameters. For example, the APPLY operator has the following constructor:</para>
        <screen>    Apply(const std::string&amp; logicalName, const std::string&amp; alias):
        LogicalOperator(logicalName, alias)
    {
        _properties.tile = true;
        ADD_PARAM_INPUT()
        ADD_PARAM_OUT_ATTRIBUTE_NAME(&quot;void&quot;)//0
        ADD_PARAM_EXPRESSION(&quot;void&quot;)        //1
        ADD_PARAM_VARIES()
    }</screen>
        <itemizedlist>
          <listitem>
            <para> <literal condition="western">properties.tile</literal> is true if operator can work in tile mode. </para>
          </listitem>
          <listitem>
            <para> <literal condition="western">ADD_PARAM_INPUT()</literal> says that operator expects one more input (in this case, an input array). </para>
          </listitem>
          <listitem>
            <para> <literal condition="western">ADD_PARAM_OUT_ATTRIBUTE_NAME(&quot;void&quot;)</literal> says that the operator will add new attribute with the given data type (&quot;void&quot; means &quot;any&quot;). </para>
          </listitem>
          <listitem>
            <para> <literal condition="western">inferSchema</literal> will produce the real data types based on input schema. </para>
          </listitem>
          <listitem>
            <para> <literal condition="western">ADD_PARAM_EXPRESSION(&quot;void&quot;)</literal> says that operator expect one expression with &quot;any&quot; (&quot;void&quot;) data type. You may add other attributes and attribute kinds as well. </para>
          </listitem>
          <listitem>
            <para> <literal condition="western">ADD_PARAM_VARIES()</literal> means that APPLY can have a variable number of parameters. In this case you need to implement one more virtual method <literal condition="western">nextVaryParamPlaceholder</literal>. See the APPLY implementation for example. </para>
          </listitem>
          <listitem>
            <para> <literal condition="western">inferSchema</literal> provides the schema for resultant array. </para>
          </listitem>
        </itemizedlist>
      </sect3>
      <sect3 remap="h4">
        <title>Physical operators</title>
        <para>Physical operators must inherit from the PhysicalOperator class and implement the <literal condition="western">execute</literal> method:</para>
        <screen>class PhysicalStub: public PhysicalOperator
{
public:
    PhysicalStub(const std::string&amp; logicalName, const std::string&amp; physicalN\
ame,\
    const Parameters&amp; parameters, const ArrayDesc&amp; schema):
            PhysicalOperator(logicalName, physicalName, parameters, schema)
        {
        }

    shared_ptr&lt;Array&gt; execute(std::vector&lt;shared_ptr&lt;Array&gt; &gt;&amp; inputArrays,\
    shared_ptr&lt;Query&gt; query)
        {
        /**
         * See built-in operators implementation for example
         */
        return shared_ptr&lt;Array&gt;();
        }
};</screen>
        <para>For example, here is the APPLY operator:</para>
        <screen>    boost::shared_ptr&lt;Array&gt; execute(vector&lt; boost::shared_ptr&lt;Array&gt; &gt;&amp; inputArra\
ys,\
    boost::shared_ptr&lt;Query&gt; query)
    {
        assert(inputArrays.size() == 1);
        assert(_parameters.size()%2 == 0);

        vector&lt;shared_ptr&lt;Expression&gt; &gt; expressions(0);

        size_t currentParam = 0;
        for(size_t i =0; i&lt; _schema.getAttributes().size(); i++)
        {
            assert(_parameters[currentParam]-&gt;getParamType() == PARAM_ATTRIB\
UTE_REF);
            assert(_parameters[currentParam+1]-&gt;getParamType() == PARAM_PHYS\
ICAL_EXPRESSION);

            string const&amp; schemaAttName = _schema.getAttributes()[i].getName\
();
            string const&amp; paramAttName = \
            ((boost::shared_ptr&lt;OperatorParamReference&gt;&amp;)_parameters[currentPa\
ram])-&gt;\
            getObjectName();

            if(schemaAttName!=paramAttName)
            {
                expressions.push_back\
                ( shared_ptr&lt;Expression&gt; ());
            }
            else
            {
                expressions.push_back(((boost::shared_ptr&lt;OperatorParamPhysi\
calExpression&gt;&amp;)\
               _parameters[currentParam+1])-&gt;getExpression());
                currentParam+=2;
            }

            if(currentParam == _parameters.size())
            {
                for (size_t j = i+1; j&lt; _schema.getAttributes().size(); j++)
                {
                    expressions.push_back( shared_ptr&lt;Expression&gt; () );
                }
                break;
            }
        }

        assert(currentParam == _parameters.size());
        assert(expressions.size() == _schema.getAttributes().size());

        boost::shared_ptr&lt;Array&gt; input = inputArrays[0];
        return boost::shared_ptr&lt;Array&gt;(new ApplyArray(_schema, input, \
        expressions, query, _tileMode));
    }</screen>
        <para>The <literal condition="western">execute()</literal> method takes a number of input arrays and query context. It can use all methods of input arrays and perform any evaluations. The result must be a new array instance.</para>
        <para>It is also possible to create a pipelined array instance which will perform evaluations only when data will be requested. For example, you may want to evaluate a chunk only when the <literal condition="western">getChunk</literal> method is called. ApplyArray in the above code is an example of such an array. </para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 remap="h2">
    <title>User-Defined Aggregates</title>
    <para/>
  </sect1>
</chapter>
