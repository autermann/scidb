<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"docbookV4.5/docbookx.dtd">
<chapter>
  <title>SciDB Linear Algebra Library</title>

  <para>The SciDB linear algebra operators accept SciDB matrices as inputs.
  Linear algebra operators interpret the first declared dimension as rows, and
  the second dimension as columns.</para>

  <para>The Linear Algebra Library provides functionality for matrix
  operations including:<itemizedlist>
      <listitem>
        <para>Matrix multiply</para>
      </listitem>

      <listitem>
        <para>Matrix transpose</para>
      </listitem>

      <listitem>
        <para>Singular Value Decomposition</para>
      </listitem>
    </itemizedlist>The examples in this chapter use the arrays
  <code>m3x3</code>, <code>m2x3</code>, and <code>m3x2</code>, which are as
  follows: <programlisting language="test">--aql CREATE ARRAY A &lt;attribute:double&gt; [x=1:3,3,0,y=1:5,5,0]; --show-query=no --show-output=no
--afl create array m2x3 &lt;val:double&gt; [i=0:1,2,0,j=0:2,3,0]; --show-output=no --show-query=no
--afl store(build(m2x3,'[[.5,1.5,2.5],[1,2,3]]',true),m2x3); --show-output=no --show-query=no
--afl create array m3x2 &lt;val:double&gt; [i=0:2,3,0,j=0:1,2,0]; --show-output=no --show-query=no
--afl store(build(m3x2,'[[0,2],[1,3],[2,4]]',true),m3x2); --show-output=no --show-query=no
--schema m2x3;
--afl scan(m2x3); --output-format=dense --chunkify=yes
--schema m3x2;
--afl scan(m3x2); --output-format=dense --chunkify=yes
--afl create array m3x3&lt;val:double&gt; [x=0:2,3,0,y=0:2,3,0]; --show-output=no --show-query=no
--afl store(build(m3x3,x*3+y),m3x3); --show-output=no --show-query=no
--schema m3x3;
--afl scan(m3x3);  --output-format=dense --chunkify=yes</programlisting></para>

  <section id="matrixMultiply">
    <title>Matrix Multiply</title>

    <para><indexterm>
        <primary>multiply</primary>
      </indexterm><indexterm>
        <primary>matrix</primary>

        <secondary>multiplication</secondary>

        <seealso>gemm</seealso>
      </indexterm><indexterm>
        <primary>linear algebra</primary>

        <secondary>multiplication</secondary>

        <seealso>gemm</seealso>
      </indexterm>Matrix multiply does the standard linear algebra multiply to
    produce a matrix product. For two matrices <emphasis role="">A</emphasis>
    and <emphasis>B</emphasis> where <emphasis>A</emphasis> is
    <emphasis>m</emphasis>-by-<emphasis>n</emphasis> and
    <emphasis>B</emphasis> is
    <emphasis>n</emphasis>-by-<emphasis>p</emphasis>, the product
    <emphasis>AB</emphasis> is an
    <emphasis>m</emphasis>-by-<emphasis>p</emphasis> matrix given
    by:<informalequation>
        <alt>AB(i,k) = \sum_{j=1}^{n} A(i,j)B(j,k)</alt>

        <mediaobject>
          <imageobject>
            <imagedata fileref="../equations/matrix_multiply.png" scale="50"/>
          </imageobject>
        </mediaobject>
      </informalequation>For example the following query produces a 2-by-2
    matrix:<programlisting language="test">
--aql SELECT * INTO m2x2 FROM multiply(m2x3,m3x2); --output-format=dense --chunkify=yes
</programlisting></para>

    <para>If you have dense matrices, and data that has data type of <emphasis
    role="bold">double</emphasis>, then we recommend that you use <link
    linkend="gemmOperator">GEMM</link>, rather than multiply, to increase
    performance. (For the third argument to GEMM, just construct a matrix with
    all of its values as zeros.)</para>
  </section>

  <section id="matrixTranspose">
    <title>Matrix Transpose</title>

    <para><indexterm>
        <primary>transpose</primary>
      </indexterm><indexterm>
        <primary>matrix</primary>

        <secondary>transpose</secondary>
      </indexterm><indexterm>
        <primary>linear algebra</primary>

        <secondary>transpose</secondary>
      </indexterm>The transpose of matrix <emphasis>A</emphasis>, denoted
    <emphasis>A</emphasis><superscript> <emphasis>T</emphasis> </superscript>,
    is the matrix <emphasis>A</emphasis><superscript> <emphasis>T</emphasis>
    </superscript>(<emphasis>j</emphasis>,<emphasis>i</emphasis>) = 
    <emphasis>A</emphasis>(<emphasis>i</emphasis>,<emphasis>j</emphasis>) for
    all <emphasis>j</emphasis> and <emphasis>i</emphasis> where 1 <symbol
    role="symbolfont">≤</symbol> <emphasis>i</emphasis> <symbol
    role="symbolfont">≤</symbol> <emphasis>n</emphasis> and 1 <symbol
    role="symbolfont">≤</symbol> <emphasis>j</emphasis> <symbol
    role="symbolfont">≤</symbol> <emphasis>m.</emphasis> The
    <code>transpose</code> operator performs matrix transpose: <programlisting
    language="test"> 
--afl scan(m3x3); --output-format=dense --chunkify=yes
--afl transpose(m3x3);  --output-format=dense --chunkify=yes
</programlisting></para>
  </section>

  <section id="SciDBSVD">
    <title>Singular Value Decomposition</title>

    <para><indexterm>
        <primary>gesvd</primary>
      </indexterm><indexterm>
        <primary>matrix</primary>

        <secondary>svd</secondary>
      </indexterm><indexterm>
        <primary>linear algebra</primary>

        <secondary>transpose</secondary>
      </indexterm>For a singular matrix <emphasis>M</emphasis>, that is, a
    matrix not invertible either because it is rectangular or because it has a
    determinant of 0, singular-value decomposition returns the matrix
    factorization:<informalequation>
        <alt>M = U\Sigma V^*</alt>

        <mediaobject>
          <imageobject>
            <imagedata fileref="../equations/svd.png" scale="60"/>
          </imageobject>
        </mediaobject>
      </informalequation>For <emphasis>m</emphasis><symbol
    role="symbolfont">×</symbol><emphasis>n</emphasis> matrix
    <emphasis>M</emphasis>, the left matrix <emphasis>U</emphasis> is
    <emphasis>m</emphasis><symbol
    role="symbolfont">×</symbol><emphasis>m</emphasis> and the right matrix
    <emphasis>V*</emphasis> is <emphasis>n</emphasis><symbol
    role="symbolfont">×</symbol><emphasis>n</emphasis>. <emphasis>U</emphasis>
    is orthogonal in the row space (<emphasis>U</emphasis><superscript>
    <emphasis>T</emphasis>
    </superscript><emphasis>U</emphasis> = <emphasis>I</emphasis>(<emphasis>m</emphasis><symbol
    role="symbolfont">×</symbol><emphasis>m</emphasis>)) and
    <emphasis>V*</emphasis> is orthogonal in the column space
    (<emphasis>V*</emphasis><superscript> <emphasis>T</emphasis>
    </superscript><emphasis>V</emphasis> = <emphasis>I</emphasis>(<emphasis>n</emphasis><symbol
    role="symbolfont">×</symbol><emphasis>n</emphasis>)).</para>

    <para>The matrix <symbol role="symbolfont">∑</symbol> is a diagonal matrix
    containing the singular values of <emphasis>M</emphasis>.</para>

    <para>For example, consider the 3<symbol role="symbolfont">×</symbol>2
    matrix <code>m3x2</code>:<programlisting language="test">--afl store(repart(m3x2,&lt;val:double&gt; [i=0:2,32,0, j=0:3,32,0]),new_m3x2); --show-query=no --show-output=no
--afl remove(m3x2); --show-query=no --show-output=no
--afl rename(new_m3x2,m3x2); --show-query=no --show-output=no
--schema m3x2;
--afl scan(m3x2);  --output-format=dense --chunkify=yes
</programlisting> You can return the left matrix, the right matrix, or an
    array containing the singular values: <programlisting language="test">--afl load_library('dense_linear_algebra'); --show-query=no --show-output=no
--aql SELECT * FROM gesvd(m3x2, 'right');  --output-format=dense --chunkify=yes
</programlisting> <programlisting language="test">
--aql SELECT * FROM gesvd(m3x2, 'left');  --output-format=dense --chunkify=yes
</programlisting> <programlisting language="test">
--aql SELECT * FROM gesvd(m3x2, 'values');  --output-format=dense </programlisting></para>
  </section>
</chapter>
