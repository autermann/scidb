<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter remap="h1">
  <title>Windowing and Aggregating: Grouping Your Data</title>
  <sect1 remap="h2">
    <title>Aggregates</title>
    <sect2 remap="h3">
      <title>Aggregates</title>
      <para>AQL supports the following built-in aggregate functions:</para>
      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colname="c1" colwidth="50*"/>
          <colspec colname="c2" colwidth="50*"/>
          <tbody>
            <row>
              <entry>
                <para><emphasis role="bold">Name</emphasis></para>
              </entry>
              <entry>
                <para><emphasis role="bold">Operation Performed</emphasis></para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal condition="western">avg</literal></para>
              </entry>
              <entry>
                <para> Average value</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal condition="western">count</literal></para>
              </entry>
              <entry>
                <para> Number of nonempty elements</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal condition="western">max</literal></para>
              </entry>
              <entry>
                <para> Largest value</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal condition="western">min</literal></para>
              </entry>
              <entry>
                <para> Smallest value</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal condition="western">sum</literal></para>
              </entry>
              <entry>
                <para> Sum of all the elements</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal condition="western">stdev</literal></para>
              </entry>
              <entry>
                <para> Standard deviation</para>
              </entry>
            </row>
            <row>
              <entry>
                <para> <literal condition="western">var</literal></para>
              </entry>
              <entry>
                <para> Variance</para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>The scalar aggregate functions in AQL take an input array and produce a scalar result. The value for the result is the aggregate function applied to the entire array.</para>
      <para>For example:</para>
      <screen>SELECT max (SELECT a1 FROM a);</screen>
      <para>Each array aggregate function accepts one attribute of appropriate type. For example, to compute the maximum value of an attribute, that attribute type must support inequality and equality functions. So, for the max aggregate, the data types that can be used are</para>
      <blockquote>
        <para>integers (int8, int16, int32, int64, uint8, uint16, uint32, uint64) and floating point (double,float) types.</para>
      </blockquote>
      <para>count here is an aggregate function that takes an array as input and returns a scalar value in its output.</para>
      <para>Below is a query that counts all the measurements of array A:</para>
      <screen>SELECT count(A);</screen>
      <para><emphasis role="bold">Note</emphasis>: While all aggregates can be calculated in this manner over the entire array typically on one attribute, the<emphasis> count</emphasis> function is an exception. In the AFL version, you can use a dimension name as an optional input into the count function.</para>
      <itemizedlist>
        <listitem>
          <para> When <literal condition="western">count()</literal> is used without any arguments, the result is a count of the number of non-empty elements in the array.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para> When <literal condition="western">count</literal> is supplied with a dimension name, count counts the number of non-null occurrences of that attribute within the array.</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
  <sect1 remap="h2">
    <title>aggregate</title>
    <para><emphasis role="bold">Summary</emphasis>: Group elements and find statistical properties of the group</para>
    <para>The <code>aggregate</code> operator takes an array as input, groups the array by  specified dimension or dimensions, and computes a given statistic for each group. The statistics available are:</para>
    <informaltable frame="none">
      <tgroup cols="2">
        <colspec colname="c1" colwidth="50*"/>
        <colspec colname="c2" colwidth="50*"/>
        <tbody>
          <row>
            <entry>
              <para><emphasis role="bold">Name</emphasis></para>
            </entry>
            <entry>
              <para><emphasis role="bold">Operation Performed</emphasis></para>
            </entry>
          </row>
          <row>
            <entry>
              <para><code> avg</code></para>
            </entry>
            <entry>
              <para> Average value</para>
            </entry>
          </row>
          <row>
            <entry>
              <para><code> count</code></para>
            </entry>
            <entry>
              <para> Number of nonempty elements</para>
            </entry>
          </row>
          <row>
            <entry>
              <para><code> max</code></para>
            </entry>
            <entry>
              <para> Largest value</para>
            </entry>
          </row>
          <row>
            <entry>
              <para><code> min</code></para>
            </entry>
            <entry>
              <para> Smallest value</para>
            </entry>
          </row>
          <row>
            <entry>
              <para><code> sum</code></para>
            </entry>
            <entry>
              <para> Sum of all elements</para>
            </entry>
          </row>
          <row>
            <entry>
              <para><code> stdev</code></para>
            </entry>
            <entry>
              <para> Standard deviation</para>
            </entry>
          </row>
          <row>
            <entry>
              <para><code> var</code></para>
            </entry>
            <entry>
              <para> Variance</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>The aggregate operator returns a scalar value for each statistic.</para>
    <para><emphasis role="bold">Signature</emphasis>: </para>
    <para><literal condition="western">aggregate</literal>(<emphasis>array, aggregate_name_1(attribute)</emphasis></para>
    <para> [,<emphasis> aggregate_name_2(attribute)</emphasis>,...<emphasis> aggregate_name_N(attribute)</emphasis>] </para>
    <para> [,<emphasis> dimension_1, dimension_2,</emphasis>...<emphasis> dimension_M</emphasis> ])</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <orderedlist>
      <listitem>
        <para> Create a 3-by-3 array called m3x3: <programlisting>store ( build ( &lt;val:double&gt; [x=0:2,3,0,y=0:2,3,0], x*3+y), m3x3);</programlisting><screen>[
[(0),(1),(2)],
[(3),(4),(5)],
[(6),(7),(8)]
]</screen></para>
      </listitem>
      <listitem>
        <para> Find the sums of each column: <screen>[(9),(12),(15)]</screen></para>
      </listitem>
      <listitem>
        <para> Find the average value, number of nonempty elements, largest element, smallest element, sum of all elements, variance, and standard deviation of the array: <programlisting>aggregate(m3x3,avg(val),count(val),max(val),min(val),sum(val),var(val),stdev(val));</programlisting><screen>[(4,9,8,0,36,7.5,2.73861)]</screen></para>
      </listitem>
    </orderedlist>
    <note>
      <para>You can also use the standalone statistical aggregate  operators <code>avg</code>, <code>count</code>, <code>max</code>, <code>min</code>, <code>sum</code>, <code>var</code>, and <code>stdev</code> that are explained in the next sections.</para>
    </note>
    <sect2 remap="h3">
      <title>avg</title>
      <para><emphasis role="bold">Summary</emphasis>: Arithmetic mean</para>
      <para>Calculate the average value of the specified attribute in the array. The result is an array with single element containing average value. If the input array contains only one attribute, then attribute name can be omitted.</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>avg(<emphasis> array</emphasis> [ ,<emphasis> attribute-name : attribute_identifier</emphasis> [,<emphasis> dimension1 : dimension_identifier</emphasis> [,<emphasis> dimension2 : dimension_identifier</emphasis> ]]] )</para>
      <para>The first argument is the array to be aggregated over. The second argument is the name of the attribute to use. Additional dimension arguments are optional. If present, the list of dimensions specified in the avg operator is used to perform a group-by average. The result is organized as an array with the remaining dimensions from the source array, after grouping has been performed based on the group-by dimensions.</para>
      <para><emphasis role="bold">Example</emphasis>: The following command returns the average value of a over all elements of array.</para>
      <screen>avg(m3x3, val);

[(4)]</screen>
      <para>This example calculates the average value of an attribute after grouping over all values of the dimension x. The second example below results in a one-dimensional array whose dimension is the remaining dimension y from the input.</para>
      <screen>avg(m3x3, val, y);

[(3),(4),(5)]</screen>
    </sect2>
    <sect2 remap="h3">
      <title>count</title>
      <para><emphasis role="bold">Summary</emphasis>: Cell count</para>
      <para>Counts non-empty cells of the input array. When dimensions are provided they are used to do a group-by and a count per resulting group is returned.</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>count(<emphasis> array</emphasis> [,<emphasis> dimension1 : dimension_identifier</emphasis> [,<emphasis> dimension2 : dimension_identifier</emphasis>]] )</para>
      <para><emphasis role="bold">Example</emphasis>:</para>
      <screen>count(m3x3);

[(9)]

count(m3x3,x);

[(3),(3),(3)]</screen>
      <para>Note that cells of value 0 or null are not considered empty:</para>
      <screen>create array A &lt;a:int32 null&gt; [x=0:0,1,0];
count(A);

[(0)]

store(build(A,x),A);
count(A);

[(1)]

store(build(A,null),A);
count(A);

[(1)]</screen>
      <para>This is different than the behavior of the aggregate operator with the count option. count(array_name) is a shorthand for aggregate(array_name, count(*)). For example:</para>
      <orderedlist>
        <listitem>
          <para> Create an array with a single attribute and three cells: </para>
        </listitem>
      </orderedlist>
      <screen>create empty array A &lt;a:int32 null default 0&gt; [x=1:3,3,0];</screen>
      <orderedlist>
        <listitem>
          <para> Put &quot;1&quot; in cell 1, &quot;null&quot; in cell 2, and make cell 3 empty: </para>
        </listitem>
      </orderedlist>
      <screen>store(build_sparse(A, iif(x=1,1,null), x&lt;&gt;3),A);

[{1}(1),{2}(null)]</screen>
      <orderedlist>
        <listitem>
          <para> Return the count of nonempty cells: </para>
        </listitem>
      </orderedlist>
      <screen>aggregate(A, count(*));

[(2)]</screen>
      <orderedlist>
        <listitem>
          <para> Return the number of values where attribute is not null: </para>
        </listitem>
      </orderedlist>
      <screen>aggregate(A, count(a));

[(1)]</screen>
    </sect2>
    <sect2 remap="h3">
      <title>max</title>
      <para><emphasis role="bold">Summary:</emphasis> Maximum value</para>
      <para>Calculate maximum of the specified attribute in the array. Result is an array with single element containing maximum of specified attribute.</para>
      <para>If input array contains only one attribute, then attribute name can be omitted. Again, if dimensions are provided, they are used to produce groups and the maximum of each group is returned.</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>max(<emphasis> array</emphasis> [ ,<emphasis> attribute-name : attribute_identifier</emphasis> [,<emphasis> dimension1 : dimension_identifier</emphasis> [,<emphasis> dimension2 : dimension_identifier</emphasis> ]]] )</para>
      <para><emphasis role="bold">Example</emphasis>:</para>
      <screen>max(m3x3);

[(8)]

max(m3x3,val,x);

[(2),(5),(8)]</screen>
    </sect2>
    <sect2 remap="h3">
      <title>min</title>
      <para><emphasis role="bold">Summary</emphasis>: Minimum value</para>
      <para>Calculates the minimum value of the specified attribute in the array. Result is an array with single element containing minimum of specified attribute. If input array contains only one attribute, then attribute name can be omitted. If an attribute list is specified, the result is an array with the remaining dimensions from the source array, and the minimum is evaluated over groups, where each group is the set of all elements matching the group by dimension(s).</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>min(<emphasis> array</emphasis> [ ,<emphasis> attribute-name : attribute_identifier</emphasis> [,<emphasis> dimension1 : dimension_identifier</emphasis> [,<emphasis> dimension2 : dimension_identifier</emphasis> ]]] )</para>
      <para><emphasis role="bold">Example</emphasis>:</para>
      <screen>min(m3x3);

[(0)]

min(m3x3,val,y);

[(0),(1),(2)]</screen>
    </sect2>
    <sect2 remap="h3">
      <title>sum</title>
      <para><emphasis role="bold">Summary</emphasis>: Sum attribute values</para>
      <para>Calculate sum of the specified attribute in the array. Result is an array with single element containing sum of specified attribute. If input array contains only one attribute, then attribute name can be omitted. Again, similar group by semantics as with the other aggregates, if a dimension list is present.</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>sum(<emphasis> array</emphasis> [ ,<emphasis> attribute-name : attribute_identifier</emphasis> [,<emphasis> dimension1 : dimension_identifier</emphasis> [,<emphasis> dimension2 : dimension_identifier</emphasis> ]]] )</para>
      <para><emphasis role="bold">Example</emphasis>:</para>
      <screen>sum(m3x3);

[(36)]

sum(m3x3,val,x);

[(3),(12),(21)]</screen>
    </sect2>
    <sect2 remap="h3">
      <title>var</title>
      <para><emphasis role="bold">Summary</emphasis>: Variance of attribute values</para>
      <para>Calculate the variance of the specified attribute in the array. Result is an array with single element containing the variance of specified attribute. If input array contains only one attribute, then attribute name can be omitted. Again, similar group by semantics as with the other aggregates is supported, if a dimension list is present.</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>var(<emphasis> array</emphasis> [ ,<emphasis> attribute-name : attribute_identifier</emphasis> [,<emphasis> dimension1 : dimension_identifier</emphasis> [,<emphasis> dimension2 : dimension_identifier</emphasis> ]]] )</para>
      <para><emphasis role="bold">Example</emphasis>:</para>
      <screen>var(m3x3);

[(7.5)]

var(m3x3,val,x);

[(1),(1),(1)]</screen>
      <para>Variance accepts numeric attributes only. The result is the sample variance of the attribute values.</para>
    </sect2>
    <sect2 remap="h3">
      <title>stdev</title>
      <para><emphasis role="bold">Summary</emphasis>: Standard deviation of attribute values</para>
      <para>Calculate the standard deviation of the specified attribute in the array. Result is an array with single element containing the standard deviation of specified attribute. If input array contains only one attribute, then attribute name can be omitted. Again, similar group by semantics as with the other aggregates is supported, if a dimension list is present.</para>
      <para><emphasis role="bold">Signature</emphasis>:</para>
      <para>stdev(<emphasis> array</emphasis> [ ,<emphasis> attribute-name : attribute_identifier</emphasis> [,<emphasis> dimension1 : dimension_identifier</emphasis> [,<emphasis> dimension2 : dimension_identifier</emphasis> ]]] )</para>
      <para><emphasis role="bold">Example</emphasis>:</para>
      <screen>stdev(m3x3);

[(2.73861)]

stdev(m3x3,val,y);

[(3),(3),(3)]</screen>
      <para>Standard deviation accepts numeric attributes only. The result is the population standard deviation of the attribute values.</para>
    </sect2>
  </sect1>
  <sect1 remap="h2">
    <title>regrid</title>
    <para><emphasis role="bold">Summary</emphasis>: Compute aggregates for a sub-grid</para>
    <para>Partition (divide) the cells in the input array into blocks, and for each block, apply a specific aggregate operation over the value(s) of some attribute in each block.</para>
    <para><literal condition="western">regrid</literal> does not allow grids to span array chunks and requires the chunk size to be a multiple of the grid size in each dimension.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>regrid ( array, grid_1, grid_2,.. grid_N, aggregate_call_1 [, aggregate_call_2,...aggregate_call_N] )</para>
    <para>The first input to the regrid operator can be:</para>
    <orderedlist>
      <listitem>
        <para> An array. </para>
      </listitem>
      <listitem>
        <para> An array operator, that is, an operator that outputs a SciDB array. </para>
      </listitem>
    </orderedlist>
    <para>The number of grids to be input should be equal to the number of dimensions of the array.</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen>store ( build ( &lt;val:double&gt; [x=0:3,4,0,y=0:3,4,0], x*4+y), m4x4);

[
[(0),(1),(2),(3)],
[(4),(5),(6),(7)],
[(8),(9),(10),(11)],
[(12),(13),(14),(15)]
]

regrid(m4x4, 2,2, sum(val));

[[(10),(18)],[(42),(50)]]

regrid(m4x4, 2,2, sum(val),max(val));

[[(10,5),(18,7)],[(42,13),(50,15)]]</screen>
  </sect1>
  <sect1 remap="h2">
    <title>window</title>
    <para><emphasis role="bold">Summary</emphasis>: Compute aggregates over a window</para>
    <para>Compute one or more aggregates of any of an array&apos;s attributes over a moving window.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <screen>window(array, grid1, grid2,.. gridN, aggregate_call1 [, aggregate_call2,...\
aggregate_callN])</screen>
    <para>Each <literal condition="western">aggregate_call</literal> argument consists of a call to an aggregate and an optional alias. For example:</para>
    <screen>sum(val) as output</screen>
    <para>will sum the attribute called <literal condition="western">val</literal> and place it in <literal condition="western">output</literal>.</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen>create array m4x4 &lt;val1:double,val2:int32&gt; [x=0:3,4,0,y=0:3,4,0];
load(m4x4, &apos;/tmp/m4x4_2attr&apos;);
[
[(0,100),(1,99),(2,98),(3,97)],
[(4,96),(5,95),(6,94),(7,93)],
[(8,92),(9,91),(10,90),(11,89)],
[(12,88),(13,87),(14,86),(15,85)]
]
window(m4x4,2,2, max(val1),sum(val2));
[
[(0,100),(1,199),(2,197),(3,195)],
[(4,196),(5,390),(6,386),(7,382)],
[(8,188),(9,374),(10,370),(11,366)],
[(12,180),(13,358),(14,354),(15,350)]]</screen>
    <para>The resulting schema for the output of <literal condition="western">window</literal> is:</para>
    <screen> &lt;val1_sum:double NULL, val2_max:int32 NULL&gt;[x=0:3,4,0, y=0:3,4,0]</screen>
    <para>You can also use an alias with the aggregate call:</para>
    <screen>window(m4x4,2,2, max(val1) as z, sum(val2) as w);</screen>
    <para>The window is defined by a size in each dimension, for example, the window in the above example is 3-by-3.</para>
    <para>The starting position of the window centroid is the first element of the array. At the edges of the array the window aggregate only contains elements that are included in the array. The centroid of the window moves in stride-major order from lowest to highest value in each dimension. The output array has the same shape (no overlap) as the input array. Each element of the output array contains the aggregates computed over the corresponding window location over the input array.</para>
    <para>SciDB uses array overlap to perform the window operation on each chunk locally. If necessary a repart operator is implicitly included in the execution plan.</para>
  </sect1>
</chapter>
