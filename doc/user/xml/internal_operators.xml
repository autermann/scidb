<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "docbookV4.5/docbookx.dtd" []>
<chapter remap="h1">
  <title>Internal Commands</title>
  <para>The commands in this chapter are for internal debugging purposes. They are not guaranteed or tested for general customer use.</para>
  <sect1 remap="h2">
    <title>cancel</title>
    <para><emphasis role="bold">Summary</emphasis>: Cancel a currently running query by query id.</para>
    <para><emphasis role="bold">Signature</emphasis>: cancel(<emphasis> query_id : integer</emphasis> )</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen>cancel(12345);</screen>
    <para>The query id can be obtained from the SciDB log or via the list() command. SciDB maintains query context information for each completed and in-progress query in the server. If the user issues a &quot;ctrl-C&quot; or abort from the client, the query is cancelled and its context is removed from the server.</para>
    <para>In-progress queries are aborted by issuing a cancel() command with the query ID. Context information is also removed by this command.</para>
    <para>This query context can also be removed for completed queries by issuing a cancel() command.</para>
    <para>Query context information maintained by the server is not persistent and is lost on server restart.</para>
  </sect1>
  <sect1 remap="h2">
    <title>diskinfo</title>
    <para><emphasis role="bold">Summary</emphasis>: Check disk capacity</para>
    <para>Get information about storage space. Returns an array with the following attributes:</para>
    <itemizedlist>
      <listitem>
        <para> used </para>
      </listitem>
      <listitem>
        <para> available </para>
      </listitem>
      <listitem>
        <para> clusterSize </para>
      </listitem>
      <listitem>
        <para> nFreeClusters </para>
      </listitem>
      <listitem>
        <para> nSegments </para>
      </listitem>
    </itemizedlist>
    <para><emphasis role="bold">Signature</emphasis></para>
    <screen>diskinfo()</screen>
  </sect1>
  <sect1 remap="h2">
    <title>echo</title>
    <para><emphasis role="bold">Summary</emphasis>: Print a string</para>
    <para>Accepts a string and returns a single-element array containing the string.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>echo(<emphasis> string</emphasis> )</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen>echo(&apos;Hello world&apos;);

[(&quot;Hello world&quot;)]</screen>
  </sect1>
  <sect1 remap="h2">
    <title>explain_logical/explain_physical</title>
    <para><emphasis role="bold">Summary</emphasis>: Show query plan</para>
    <para>The operators explain_logical and explain_physical can be used to emit a human-readable plan string for a particular query without running the query itself. SciDB first constructs a logical plan, optimizes it and then translates it into a physical plan.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>explain_logical(<emphasis> query: string</emphasis>,<emphasis> language: string</emphasis> ) explain_physical (<emphasis> query: string</emphasis>,<emphasis> language: string</emphasis> )</para>
    <para>where language corresponds to the language of the query string and is either<emphasis> afl</emphasis> or<emphasis> aql</emphasis>.</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen>explain_physical(&apos;store(join(a, b), c)&apos;,&apos;afl&apos;)</screen>
    <para>Note that the output of the explain operators is a single-element array that contains the plan string. The plan text format is intended for SciDB developers and experts and is subject to change in the future.</para>
  </sect1>
  <sect1 remap="h2">
    <title>reduce_distro</title>
    <para><emphasis role="bold">Summary</emphasis>: Reduce the distribution of a replicated array</para>
    <para>Given an array that is distributed with psReplication - quickly reduce the distribution to a different schema by masking certain chunks. For internal use.</para>
    <para><emphasis role="bold">Signature</emphasis>:</para>
    <para>reduce_distro(<emphasis> array</emphasis>,<emphasis> partitioning_schema: integer</emphasis> )</para>
    <para><emphasis role="bold">Example</emphasis>:</para>
    <screen>reduce_distro(\&quot;target@1:label\&quot;,2);

[(&quot;a&quot;),(&quot;b&quot;),(&quot;e&quot;),(&quot;f&quot;),(&quot;l&quot;),(&quot;o&quot;),(&quot;x&quot;),(&quot;z&quot;)]</screen>
  </sect1>
  <sect1 remap="h2">
    <title>setopt</title>
    <para>Set/get configuration option value at runtime. Option value should be specified as string. If new value is not specified, then values of this configuration option at all nodes are printed. If new value is specified, then value of option is updated at all odes and result array contains old and new values of the option at all nodes.</para>
    <para><emphasis role="bold">Signature</emphasis></para>
    <screen>setopt ( option-name [ , new-option-value ] ) </screen>
    <para><emphasis role="bold">Example</emphasis></para>
    <screen>setopt(&apos;threads&apos;, &apos;4&apos;)</screen>
  </sect1>
  <sect1 remap="h2">
    <title>sg</title>
    <para><emphasis role="bold">Summary</emphasis>: Scatter or Gather an array.</para>
    <para>The <literal condition="western">sg</literal> operator is used internally to redistribute or repartition the elements of an array between SciDB processing nodes. <literal condition="western">sg</literal> by itself does not perform any computation and its use in user queries can lead to inefficiencies and is discouraged.</para>
    <para><literal condition="western">sg</literal> redistributes chunks of the input array across cluster nodes according to a specified policy. sg is not a user-visible operator, but it is heavily used by the system internally. It is a physical operator for data movement within the system and users are not expected to invoke it directly. For example, the scidb optimizer inserts an sg operator after load to redistribute array data using round robin distribution. The optimizer may also insert sg operators to assist with aggregations, operators that don&apos;t preserve shape or operators that don&apos;t preserve distribution.</para>
    <para><emphasis role="bold">Signature</emphasis></para>
    <screen>sg ( &apos;&apos;array,&apos;&apos; [ &apos;&apos;partitioning schema&apos;&apos; [, &apos;&apos;node id&apos;&apos; [, &apos;&apos;result array \
name&apos;&apos;
   [, &apos;&apos;store_flag&apos;&apos; [, &apos;&apos;offset_x&apos;&apos;, &apos;&apos;offset_y&apos;&apos;, ... ] ] ] ] ]) </screen>
    <para><emphasis role="bold">Arguments</emphasis>:</para>
    <informaltable frame="none">
      <tgroup cols="3">
        <colspec colname="c1" colwidth="33*"/>
        <colspec colname="c2" colwidth="33*"/>
        <colspec colname="c3" colwidth="33*"/>
        <tbody>
          <row>
            <entry>
              <para> <emphasis role="bold">Argument name</emphasis></para>
            </entry>
            <entry>
              <para> <emphasis role="bold">Description</emphasis></para>
            </entry>
            <entry>
              <para> <emphasis role="bold">Comments</emphasis></para>
            </entry>
          </row>
          <row>
            <entry>
              <para> input_array</para>
            </entry>
            <entry>
              <para> array to be redistributed.</para>
            </entry>
            <entry>
              <para> May also be the output of another operator like scan, filter, etc.</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> partitioning schema</para>
            </entry>
            <entry>
              <para> integer constant specifying partitioning schema.</para>
            </entry>
            <entry>
              <para> Possible values are shown in the table below.</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> node number</para>
            </entry>
            <entry>
              <para> a node number to send all chunks.</para>
            </entry>
            <entry>
              <para> Used only with psLocalNode. Ignored for other partitioning schemas.</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> result array</para>
            </entry>
            <entry>
              <para> a name of result array.</para>
            </entry>
            <entry>
              <para> If omitted, the result of sg is nameless and temporary with query duration.</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> store_flag</para>
            </entry>
            <entry>
              <para> a boolean indicator used to specify whether sg should store the result array.</para>
            </entry>
            <entry>
              <para> By default, true if result array name is given. If store_flag is true, the result of sg is persisted as a new array with given name. If store_flag is false, the result is a temporary named array that can be referenced elsewhere in the query.</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> offset</para>
            </entry>
            <entry>
              <para> a distribution offset vector.</para>
            </entry>
            <entry>
              <para> For internal use.</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>The partition schema is one of the following types.</para>
    <informaltable frame="none">
      <tgroup cols="3">
        <colspec colname="c1" colwidth="33*"/>
        <colspec colname="c2" colwidth="33*"/>
        <colspec colname="c3" colwidth="33*"/>
        <tbody>
          <row>
            <entry>
              <para> partition schema</para>
            </entry>
            <entry>
              <para> Description</para>
            </entry>
            <entry>
              <para> Comment</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> 0</para>
            </entry>
            <entry>
              <para> psReplication</para>
            </entry>
            <entry>
              <para> replicate array on every node of cluster</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> 1</para>
            </entry>
            <entry>
              <para> psRoundRobin</para>
            </entry>
            <entry>
              <para> distribute chunks by round robin</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> 2</para>
            </entry>
            <entry>
              <para> psLocalNode</para>
            </entry>
            <entry>
              <para> send every local chunk to specified node</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> 3</para>
            </entry>
            <entry>
              <para> psByRow</para>
            </entry>
            <entry>
              <para> distribute every chunk to node according to chunk coordinate of dimension 0</para>
            </entry>
          </row>
          <row>
            <entry>
              <para> 4</para>
            </entry>
            <entry>
              <para> psByCol</para>
            </entry>
            <entry>
              <para> distribute every chunk to node according to chunk coordinate of dimension 1</para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para><emphasis role="bold">Examples</emphasis>:</para>
    <para>Create a query to distribute array by round robin onto every node:</para>
    <screen>sg(seq_info, 1, -1, seq_info_sg);</screen>
    <para>Create a query to gather whole array on node 0 in memory array (will not be stored on disk):</para>
    <screen>sg(seq_info_sg, 2, 0); </screen>
  </sect1>
</chapter>
