<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=ISO-8859-1">
  <style type="text/css"><!--
BODY { font-family: serif }
H1 { font-family: sans-serif }
H2 { font-family: sans-serif }
H3 { font-family: sans-serif }
H4 { font-family: sans-serif }
H5 { font-family: sans-serif }
H6 { font-family: sans-serif }
SUB { font-size: smaller }
SUP { font-size: smaller }
PRE { font-family: monospace }
--></style>
  <title></title>
</head>
<body>
<h1><a name="1">Introduction to SciDB</a></h1>
<p> SciDB is an all-in-one data management and advanced analytics
platform. It provides massively scalable complex analytics inside a
next-generation database with data versioning and provenance to support
the needs of commercial and scientific applications. SciDB is an open
source software platform that runs on a grid of commodity hardware or
in a cloud.</p>
<p> Paradigm4 Enterprise SciDB with Paradigm4 Extensions is an
enterprise distribution of SciDB with additional linear algebra, high
availability, and client connector features.</p>
<p> Unlike conventional relational databases designed around a row or
column-oriented table data model, SciDB is an array database. The
native array data model provides compact data storage and high
performance operations on ordered data such as spatial (location-based)
data, temporal (timeseries) data, and matrix-based data for linear
algebra operations.</p>
<p> This document is a User's Guide, written for scientists and
developers in various application areas who want to use SciDB as their
scalable data management and analytic platform.</p>
<p> This chapter introduces the key technical concepts in SciDB -- its
array data model, basic system architecture including distributed data
management, salient features of the local storage manager, and the
system catalog. It also provides an introduction to SciDB's array
languages -- Array Functional Language (AFL) and Array Query Language
(AQL) -- and an overview of transactions in SciDB.</p>
<h2 id="ArrayDataModel"><a name="1_1">Array Data Model</a></h2>
<p> SciDB uses multidimensional arrays as its basic storage and
processing unit. A user creates a SciDB array by specifying<em>
dimensions</em> and<em> attributes</em> of the array.</p>
<p><strong> Dimensions</strong></p>
<p> An n-dimensional SciDB array has dimensions d1, d2, ..., dn. The
size of the dimension is the number of ordered values in that
dimension. For example, a 2-dimensional array may have dimensions<em> i</em>
and<em> j</em>, each with values (1, 2, 3, ..., 10) and (1, 2, ..., 30)
respectively.</p>
<p> Basic array dimensions are 64-bit integers. SciDB also supports
arrays with one or more noninteger dimensions, such as variable-length
strings (<em>alpha</em>,<em> beta</em>,<em> gamma</em>, ...) or
floating-point values (1.2, 2.76, 4.3, ...).</p>
<p> When the total number of values or cardinality of a dimension is
known in advance, the SciDB array can be declared with a<em> bounded</em>
dimension. However, in many cases, the cardinality of the dimension may
not be known at array creation time. In such cases, the SciDB array can
be declared with an<em> unbounded</em> dimension.</p>
<p><strong> Attributes</strong></p>
<p> Each combination of dimension values identifies a cell or element
of the array, which can hold multiple data values called attributes
(a1, a2, ..., am). Each data value is referred to as an<em> attribute</em>,

and
belongs
to
one
of
the supported datatypes in SciDB.</p>
<p> At array creation time, the user must specify:<br>
</p>
<ul>
  <li>An array name.</li>
  <li>An array type.</li>
  <li>Array dimensions. The name and size of each
dimension must be declared.<br>
  </li>
  <li>Array attributes of the array. The name and datatype of
the each attribute must be declared.</li>
</ul>
<p><strong> Dimensions vs. Attributes</strong></p>
<p> An important part of SciDB database design is selecting which
values will be dimensions and which will be attributes. Dimensions form
a<em> coordinate</em> system for the array. Adding dimensions to an
array generally improves the performance of many types of queries by
speeding up access to array data. Hence, the choice of dimensions
depends on the types of queries expected to be run. Some guidelines for
choosing dimensions:</p>
<ul>
  <li>Dimensions provide selectivity and efficient access to sub-arrays
of data within an array. Any coordinate along which such selection
queries must be performed constitute a good choice of dimension.</li>
</ul>
<ul>
  <li>Array aggregation operators including group-by, window, or
grid aggregates specify<em> coordinates</em> along which grouping
must be performed. Such values must be present as dimensions of the
array. For spatial and temporal applications, the space or time
dimension is often a good choice of dimension.</li>
</ul>
<ul>
  <li>In the case of 2-dimensional arrays common in linear algebra
applications, rows represent observations and columns represent
variables, factors, or components. Matrix operations such as multiply,
covariance, inverse, and best-fit linear equation solution require a
2-dimensional array structure.</li>
</ul>
<p> In the absence of these factors, choosing to represent values as
attributes is generally a good idea. However, SciDB offers the
flexibility to transform data from one array definition to another even
after it has been loaded. This step is referred to as<em> redimensioning</em>
the array and is especially useful when the same data set must be used
for different types of analytic queries. Redimensioning is used to
transform attributes to dimensions and vice-versa.</p>
<p> Once you have created a SciDB database and defined the arrays, you
must prepare and load data into it. Loaded data is then available to be
accessed and queried using SciDB's built-in analytics capabilities.
Unlike traditional relational database environments where complex
analytics is separate from data storage and data must be transferred
between the two environments, SciDB provides both storage and analytics
in a single integrated analytic database.</p>
<h2 id="BasicArchitecture"><a name="1_2">Basic Architecture</a></h2>
<p> SciDB uses a<em> shared-nothing</em> architecture is shown in the
illustration below.</p>
<p> SciDB is deployed on a cluster of servers, each with processing,
memory, and local storage, interconnected using a standard ethernet and
TCP/IP network. Each physical server hosts a SciDB node that is
responsible for local storage and processing.</p>
<p> External applications, when they connect to a SciDB database,
connect to one of the nodes in the cluster. While all nodes in the
SciDB cluster participate in query execution and data storage, one node
is the special<em> coordinator</em> and orchestrates query execution
and result fetching. It is the responsibility of the coordinator node
to mediate all communication between the SciDB external client and the
entire SciDB database. The rest of the system nodes are referred to as
worker nodes and work on behalf of the coordinator for query processing.</p>
<p> <a style="border: medium none ; padding: 0pt;"><img
 style="border: 0px solid ; width: 669px; height: 471px;" alt=""
 src="graphics/scidb_architecture.png"></a></p>
<p> SciDB's scale-out architecture is ideally suited for hardware grids
as well as clouds, where additional severs may be added to scale the
total capacity.</p>
<h3 id="ChunkingandScalability"><a name="1_2_1">Chunking and Scalability</a>
</h3>
<p> When data is loaded, it is partitioned and stored on each node of
the SciDB database. SciDB uses<em> chunking</em>, a partitioning
technique for multi-dimensional arrays where each node is responsible
for storing and updating a subset of the array locally, and for
executing queries that use the locally stored data. By distributing
data uniformly across all nodes, SciDB is able to deliver scalable
performance on computationally or I/O intensive analytic operations on
very large data sets.<br>
</p>
<p>The details of chunking are shown in this section. Remember that you
do not need to manage chunk distribution beyond specifying chunk size.<br>
</p>
<p> Chunking is specified for each array as follows. Each dimension of
an array is divided into chunks. For example, an array with dimensions <tt>
i</tt> and <tt>j</tt>, where <tt>i</tt> is of length 10 and chunk
size 5 and <tt>j</tt> is of length 30 and chunk size 10 would be
chunked as follows:</p>
<p> <span style="border: medium none ; padding: 0pt;"><img
 style="border: 0px solid ; width: 347px; height: 337px;" alt=""
 src="graphics/chunked_dimensions.png">
</span></p>
<p> An array A&lt;a: int32&gt;[i=1:10,5,0, j=1:30,10,0] is chunked as
follows. C<sub>ij</sub> refers to the chunks of the array A as shown
below.</p>
<p> C<sub>11</sub> -&gt; <tt>i</tt>=1:5, <tt>j</tt>=1:10
<br>
C<sub>12</sub> -&gt; <tt>i</tt>=1:5, <tt>j</tt>=10:20
<br>
C<sub>13</sub> -&gt; <tt>i</tt>=1:5, <tt>j</tt>=20:30
<br>
</p>
<p> C<sub>21</sub> -&gt; <tt>i</tt>=6:10, <tt>j</tt>=1:10
<br>
C<sub>22</sub> -&gt; <tt>i</tt>=6:10, <tt>j</tt>=10:20
<br>
C<sub>23</sub> -&gt; <tt>i</tt>=6:10, <tt>j</tt>=20:30</p>
<p> Chunks are arranged in row-major order in this example, and stored
within the cluster using a round-robin distribution as follows. Suppose
a cluster has nodes 1 through 4, the placement of data is shown below.</p>
<p> C<sub>11</sub> -&gt; node 1
<br>
C<sub>12</sub> -&gt; node 2
<br>
C<sub>13</sub> -&gt; node 3
<br>
</p>
<p> C<sub>21</sub> -&gt; node 4
<br>
C<sub>22</sub> -&gt; node 1
<br>
C<sub>23</sub> -&gt; node 2
<br>
</p>
<p> This scheme is generalized to arrays with more dimensions by
arranging the chunks in left-to-right dimension order.</p>
<p> Once you have created a SciDB database and defined the arrays, you
must prepare and load data into it. Loaded data is then available to be
accessed and queried using the built-in analytics capabilities. Unlike
traditional relational database environments where complex analytics is
separate from data storage and data must be transferred between the two
environments, SciDB provides both in a single integrated analytic
database.</p>
<h3 id="ChunkOverlap"><a name="1_2_2">Chunk Overlap</a></h3>
<p> It is sometimes advantageous to have neighboring chunks of an array
overlap with each other. Overlap is specified for each dimension of an
array. For example, consider an array A: follows:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">A&lt;a: int32&gt;[i=1:10,5,1, j=1:30,10,5]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Array has has two dimensions, <tt>i</tt> and <tt>j</tt>.
Dimension <tt>
i</tt> is of length 10, chunk size 5, and had chunk overlap 1.
Dimension <tt>j</tt> has length 30, chunk size 10, and chunk overlap
5. This overlap causes SciDB to store adjoining cells in each dimension
from the<em> overlap area</em> along with the chunk.</p>
<p> </p>
<p>Some advantages of chunk overlap are:<br>
</p>
<ul>
  <li>Speeding up nearest-neighbor
queries, where each chunk may need access to a few elements from its
neighboring chunks,</li>
  <li>Detecting data clusters or data features that straddle more than
one chunk.<br>
  </li>
</ul>
<p>SciDB supports operators that can be
used to add or change the chunk overlap within an existing array.</p>
<h2 id="SciDBstoragemanagement"><a name="1_3">SciDB storage management</a>
</h2>
<h3 id="LocalStorage"><a name="1_3_1">Local Storage</a></h3>
<p> Each local node further divides logical chunk of an array into
per-attribute chunks, a technique referred to as vertical partitioning.
All basic array processing steps -- storage, query processing, and data
transfer between nodes -- use single-attribute chunks</p>
<p> SciDB uses run-length encoding internally to compress repeated
values or commonly occurring patterns typical in big data applications.
Frequently accessed chunks are maintained in the storage manager cache
and accelerate query processing by eliminating expensive disk fetches
for repeatedly accessed data.</p>
<h3 id="VersionsandDeltaEncoding"><a name="1_3_2">Versions and Delta
Encoding</a></h3>
<p> SciDB uses a "no overwrite" storage model. No overwrite means that
data is never overwritten; each store() or update query writes a new
full chunk or a new<em> delta chunk</em>. Delta chunks are calculated
by
differencing the new version with the prior version and only storing
the difference. The SciDB
storage manager stores "reverse" deltas -- this means that the most
recent version is maintained as a full chunk, and prior versions are
maintained as a list or chain of reverse deltas. The delta chain is
stored in the "reserve" portion of each chunk, an additional area over
and above the total size of the chunk. If the reserve area for the
chunk fills up, a new chunk is allocated within the same segment or a
new segment and linked into the delta chain.</p>
<h3 id="Storageallocationandreclaim"><a name="1_3_3">Automatic Storage
Allocation
and Reclaim</a></h3>
<p> The local storage manager manages space allocation, placement, and
reclaim within the local storage manager using<em> segments</em>. A
storage segment is a contiguous portion of the storage file reserved
for successive chunks of the same array. This is designed to optimize
queries issued on a very large array to use sequential disk I/O and
hence maximize the rate of data transfer during a query.</p>
<p> Segments also serve as the unit of storage reclaim, so that as
array chunks are created, written, and ultimately removed, a segment is
reclaimed and reallocated for new chunks or arrays once all its member
chunks have been removed. This allows for reuse of storage space.</p>
<p> In addition to the main persistent data store, SciDB also uses
temporary data files or "scratch space" used during query execution.
This is specified during initialization and start-up as the <tt>
tmp-path</tt> configuration setting. Temporary files are managed using
the operating system's<em> tempfile</em> mechanism. Data written to
tempfile only stay for the lifetime of a query. They are removed upon
successful completion or abort of the query.</p>
<h2 id="SystemCatalog"><a name="1_4">System Catalog</a></h2>
<p> SciDB relies on a centralized system catalog that is a repository
of the following information:</p>
<ul>
  <li>Array-related metadata such as array definitions, array versions,
and
associations between arrays and other related objects,</li>
  <li>Cluster configuration information,</li>
  <li>SciDB extensions such as plug-in libraries that encapsulate
user-defined types, functions, and operators.</li>
</ul>
<h2 id="ArrayLanguages"><a name="1_5">Array Languages</a></h2>
<p> SciDB provides two query language interfaces.</p>
<ul>
  <li>AFL, the array functional language, and</li>
  <li>AQL, the array query language</li>
</ul>
<h3 id="ArrayFunctionalLanguage"><a name="1_5_1">Array Functional
Language</a></h3>
<p> AFL represents the full set of data management and analytic
capabilities available in the form of operators, ranging from data
loading, basic data selection and projection, aggregates, join and
merge, multi-dimensional aggregates,<em> shape changing</em> operators
to transform data from one array definition to another, as well as
complex analytics such as matrix and linear algebra.</p>
<p> SciDB Array Functional Language (AFL) adopts a functional
programming language syntax over an underlying algebra of array
operators. The general form of an AFL statement looks like this:</p>
<center>
<table style="width: 1417px; height: 37px;" border="1" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">  operator_A ( array_inputs)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> A unary operator accepts one array input. A binary operator accepts
two array inputs.</p>
AFL supports combining multiple operators in a single statement or
query. An AFL query should be read from the inside out. The first
operator executed is the inner-most operator; the output of the
innermost operator then becomes the input for the next-innermost
operator.<br>
<br>
In the query here, the output of <tt>operator_A (
array_name )</tt> is another logical array that becomes the input to
the outermost operator, operator_B. The output of B is then returned to
the client issuing the query:<br>
<br>
<center>
<table style="width: 1417px; height: 37px;" border="1" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">  operator_B ( operator_A ( array_inputs ), constants and expressions )<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> For example, whenever an operator signature uses an<em> array</em>
input it
implies that the input to the operator can be a stored array (using an
array identifier) or the result of another operator. For example,
SciDB's <tt>list</tt> operator returns an array containing the
string-value names of all arrays in the current SciDB instance:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">list();<br>[("A"),("target"),("target_new")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> SciDB's <tt>concat</tt> operator can take two arrays as input, but
it can also take the output of the list operator as input:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">concat(list(),list());<br><br>[("A"),("target"),("target_new"),<br>("A"),("target"),("target_new")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> While<em> operators</em> are the main construct in AFL and used to
compose queries or statements, the language also supports<em> types</em>,<em>
functions</em>, and<em> expressions</em>.</p>
<ul>
  <li> <span style="font-weight: bold;">Types</span> in AFL are
analogous to data types in SQL and may be either
basic types which are available in SciDB, or as user-defined types,
which may be loaded as extensions into SciDB.</li>
  <li> <span style="font-weight: bold;">Functions</span> in AFL are
scalar functions. An AFL function is a<em>
cell-level</em> function and takes as input one or more attribute
values or
expressions over attribute values from an array cell. SciDB supports a
number
of built-in functions covering a range of arithmetic, logical, string,
time, system, and other categories. SciDB also provides a framework for
creating and registering user-defined functions, analogous to SQL
databases.</li>
  <li> <span style="font-weight: bold;">Expressions</span> combine
constants, variables (or array
attributes), and functions over attribute values. Expressions are used
in special
operators such as<em> apply</em>,<em> filter</em>, and<em> project</em>
.</li>
</ul>
<h3><a name="1_5_2">Array Query Language</a></h3>
<p> SciDB's Array Query Language (AQL) is a high-level declarative
language for working with SciDB arrays. It is similar to the SQL
language for relational databases, but uses an array-based data model
and a more comprehensive analytical query set compared with standard
relational databases.</p>
<p> The AQL language includes two classes of queries:</p>
<ul>
  <li><strong>Data Definition Language</strong> (DDL) : queries to
define arrays and load data.</li>
  <li><strong>Data Manipulation Language</strong> (DML) : queries to
access and operate on array data.</li>
</ul>
<p> The DDL commands in AQL are very similar to AFL, however AQL uses a
declarative SQL-style invocation. As of this release, AQL represents a
partial subset of SciDB capabilities available today whereas the AFL
interface provides the entire set of operators available in SciDB since
AFL covers both user and developer operations.</p>
<p> Both AQL and AFL statements are handled by the SciDB query compiler
which translates and optimizes incoming statements into an execution
plan. The plan is expressed in terms of physical "operators," many of
which have direct analogs in AFL.</p>
<h2 id="DatabaseConcepts"><a name="1_6">Database Concepts</a></h2>
<h3 id="ACIDandTransactions"><a name="1_6_1">ACID and Transactions</a></h3>
<p> SciDB supports transactions in the database. Each AQL or AFL
statement constitutes a single transaction. SciDB supports updates.</p>
<p> A transaction may involve many scan, projection, and analytic
operators on one or more arrays, and ultimately store the result in a
new or pre-existing array.</p>
<p> SciDB combines traditional ACID semantics with versioned,
append-only array storage. When using versioned arrays, write
transactions create new versions of the array -- they do not modify
pre-existing versions of the array. Such write and read queries are
guaranteed to have ACID semantics as defined below:</p>
<p><strong> Atomicity,</strong> or "all or none" semantics. A SciDB
update transaction once completed will successfully commit all its
updates or none at all. Any partial updates will be rolled back. This
includes updates to array storage on each node in the cluster as well
as the system catalog. A transaction interrupted by user-initiated
abort (ctrl+C of a client session), or an error during execution of a
query will result in transaction rollback and no change to array
storage or catalog.</p>
<p><strong> Consistency</strong>. SciDB uses array-level locking.
Update transactions such as AQL UPDATE and AFL store and
redimension_store transactions hold an exclusive write lock on the
array for the entire duration of the transaction. Update transactions
create a new version of the array. Read queries are allowed to proceed
concurrently with other reads.</p>
<p><strong> Isolation</strong>. If multiple update transactions are
made to the same array, only one of them is allowed to proceed, and the
other transaction will block until the first has completed. Updates to
different arrays can proceed concurrently in SciDB.</p>
<p><strong> Durability.</strong> When a write or remove transaction
(AFL or AQL transactions involving load, store, redimension_store, or
remove) completes successfully, its results are committed to stable
storage. A transient power failure or reboot of the node does not
result in loss of committed data.</p>
<h2 id="Clientsandconnectors"><a name="1_7">Clients and connectors</a></h2>
<p> The SciDB software package that you downloaded contains a special
command line utility called<em> iquery</em> which provides an
interactive shell and supports both AFL and AQL. For more information
about iquery, see <span style="text-decoration: underline;"><a
 href="#3_1">Using the iquery
Client</a>.</span></p>
<p> Client applications connect to SciDB using an appropriate connector
package which implements the client-side of the SciDB client-server
protocol. Once connected via the connector, the user may issue queries
written in either AFL or AQL, and fetch the result of the query using
an iterator interface.</p>
<h2 id="ASCIIdataformats"><a name="1_8">ASCII data formats</a></h2>
<p> SciDB uses ASCII formats for loading and saving (or unloading)
data. iquery also uses the same ASCII formats to print results
retrieved from the server.</p>
<p> Two formats for data sets are allowed. One format is suitable for
dense arrays (cases
where the vast majority of the elements in the array contain actual
values) and one format is suitable for sparse arrays (cases where many
of the
elements are absent).</p>
<p> Dense array format is shown here. array A&lt;a: int32, b:
string&gt;[i=0:2,1,0, j=0:2,3,0]</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">[(10, 'abc'), (9, 'bac'), (8, 'cab')];<br>[(1, 'xyz'), (2, 'yzx'), (3, 'zyx')];<br>[(7, 'bbb'), (14, 'bbb'), (21, 'bbb')]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Array data is displayed as a sequence of chunks within a flat
file. Each chunk must appear within square braces, <tt>[]</tt>. Chunks
are separated by a semi-colon, <tt>;</tt>.</p>
<p> Cells within a chunk appear within parentheses <tt>()</tt>, and
attributes within the same cell are separated by commas. Whitespace and
carriage returns are ignored.</p>
<p> The same array can be represented visually as follows:</p>
<p> <span style="border: medium none ; padding: 0pt;"><img
 style="border: 0px solid ; width: 194px; height: 189px;" alt=""
 src="graphics/array_model_with_data.png">
</span></p>
<p> The same data in sparse format has the following format:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">[{0,0} (10,'abc'), {0,1} (9,'bac'), {0,2} (8,'cab')];<br>[{1,0} (1,'xyz'), {1,1} (2,'yzx'), {1,2} (3,'zyx')];<br>[{2,0} (7,'bbb'), {2,1} (14,'bbb'), {2,2} (21,'bbb')]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> In dense format the dimension values are implicit in the ordering
of the attributes. In the sparse format, the dimension indices,
delimited by curly braces {}, are explicitly included in the ASCII file.</p>
<p> More details on ASCII external file formats are in the chapter <a
 class="wiki" href="#5">Loading Data into a SciDB Array</a>.</p>
<h2 id="DocumentRoadmap"><a name="1_9">Document Roadmap</a></h2>
<p> The remainder of the chapters in this document are organized as
follows.</p>
<ul>
  <li>Chapter 2, <a class="wiki" href="#2">
SciDB Installation and Administration</a>, is intended for database and
systems administrators who want to offer SciDB as a service to
application developers.</li>
</ul>
<ul>
  <li>Chapter 3, <a class="wiki" href="#3">
Getting Started with SciDB Development</a>, describes the <tt>iquery</tt>
command-line client for SciDB and helps the beginner-level user get
started with SciDB.</li>
</ul>
<ul>
  <li>Chapters 4 through 14 cover array-oriented tasks such as creating
arrays, loading data, and querying content using SciDB's Array
Functional Language (AFL).</li>
</ul>
<ul>
  <li>Chapter 15, <a class="wiki" href="#15">
Array Query Language Reference (AQL)</a>, covers SciDB's Array Query
Language (AQL).</li>
</ul>
<ul>
  <li>Chapter 16, <a class="wiki" href="#16">
SciDB Plugins: Extending SciDB Functionality</a>, shows how to code
user-defined objects as SciDB plugins.</li>
</ul>
<ul>
  <li>Chapter 17, <a class="wiki" href="#17">
Connectors</a>, describes client connectors for SciDB.</li>
</ul>
<ul>
  <li>Two appendices offer alphabetical lists of AFL operators and
SciDB functions.</li>
</ul>
<h2 id="ConventionsUsedinthisDocument"><a name="1_10">Conventions Used
in this Document</a></h2>
<p> Code to be typed in verbatim is shown in <tt>fixed-width font</tt>.

Code
that
is
to
be
replaced with an actual string is shown in<em>
italics</em>.</p>
<p> Arguments to operators and functions are shown as<em>
argument_name:argument_datatype</em> where appropriate.</p>
<p> Optional arguments are shown in square brackets [].</p>
<p> AFL queries are available through the SciDB command-line client <tt>
iquery</tt>. For this document, all code examples that do not start
with <tt>iquery</tt> are written as if the iquery client is running in
AFL mode. To set iquery to AFL mode, use the following commands:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scidb.py startall hostname<br>iquery<br>AQL% set lang afl<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can then enter queries at the AFL prompt:</p>
<blockquote>
  <p> <tt>AFL%</tt><em> AFL statement</em><tt>;</tt></p>
</blockquote>
<p> All AFL statements end with a semicolon. You can also run code
examples in this document using standalone iquery statements as:</p>
<blockquote>
  <p> <tt>iquery -aq "</tt><em>single-line code statement</em><tt>"</tt></p>
</blockquote>
<p> Note that the semicolon is not required at the end of a quoted
query, though it can be present.</p>
<h2 id="WheretoGetMoreHelp"><a name="1_11">Where to Get More Help</a></h2>
<p> The SciDB forums (<a href="http://www.scidb.org/forum/">
http://www.scidb.org/forum/</a>) are an excellent resource for
questions that are not answered in this document. In addition, you can
request an invitation to the SciDB Developer's List at <a
 class="ext-link"
 href="http://lists.scidb.org/cgi-bin/mailman/listinfo/dev">
<!--span class=&quot;icon&quot;-->&nbsp;http://lists.scidb.org/cgi-bin/mailman/listinfo/dev</a>
.</p>
<hr noshade="noshade">
<h1 id="SciDBInstallationandAdministration"><a name="2">SciDB
Installation and Administration</a></h1>
<h2 id="InstallingSciDB"><a name="2_1">Installing SciDB</a></h2>
<p> SciDB binaries are currently available for the following Linux
platforms:</p>
<ul>
  <li>Red Hat Enterprise Linux 5.4</li>
  <li>Fedora 11</li>
  <li>Ubuntu 11.04</li>
</ul>
<p> For virtual machine based installs, you can use VMWare Player for
desktop testing and Citrix XenServer for production use. You can also
use Oracle VirtualBox. VirtualBox installations are recommended only
for small-scale testing. For full screen mode with Ubuntu on
VirtualBox, install the GuestAdditions package and restart your
VirtualBox.</p>
<h3 id="PreparingthePlatform"><a name="2_1_1">Preparing the Platform</a></h3>
<h4 id="LinuxUserAccount">Linux User Account</h4>
<p> Create a Linux user account,<strong> scidb</strong>. This account
must have sudo privileges. It is preferable for it to have NOPASSWD
permissions as well.</p>
<p> Modify the <tt>/etc/sudoers</tt> file as follows:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">## Allow root to run any commands anywhere<br>root    ALL=(ALL)       ALL<br>scidb   ALL=(ALL)       NOPASSWD: ALL<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> SciDB is started and stopped as user<strong> scidb</strong>. This
user account is also the owner of all processes and files created by
SciDB.</p>
<h4 id="PostgresInstallationandConfiguration">Postgres Installation and
Configuration</h4>
<p> SciDB has been tested with Postgres 8.4.X. A suitable version of
Postgres (8.4.6 or 8.4.7) is typically available on most Linux
platforms.</p>
<p> Install the postgresql-contrib package:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sudo apt-get install postgresql-contrib<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can use <tt>yum</tt> for Red Hat and Fedora.</p>
<p> By default, Postgres is configured to allow only local access via
Unix-domain sockets. In a clustered environment, the Postgres DBMS
needs to be configured to allow access from the different nodes in the
system. You can fix this by modifying the <tt>pg_hba.conf</tt> file
(usually at <tt>/etc/postgresql/8.4/main/</tt> or <tt>
/var/lib/pgsql/data/</tt>).</p>
<p> Add the following line to the file:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">host    all         all         10.0.0.1/8            trust<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Change all instances of 'ident' to 'trust':</p>
<p> (assuming your local network is 10.x.x.x) and restart Postgres.
This configuration might pose security issues, though. You can read <a
 class="ext-link"
 href="http://www.postgresql.org/docs/8.4/interactive/client-authentication.html">
<!--span class=&quot;icon&quot;-->&nbsp;here</a> on the security
details to make a more secure installation, by listing specific host IP
addresses, user names, and role mappings.</p>
<p> You might also need to set the <tt>postgresql.conf</tt> file to
have it listen on the relevant port and ip address, as it might be
turned off or limited to <tt>localhost</tt> by default.</p>
<p> If you are running a cluster on multiple servers, you will also
need to modify the <tt>postgresql.conf</tt> file to allow connections:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"># - Connection Settings -<br>listen_addresses = '*'<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can verify that a PostgreSQL instance is running on the
coordinator with the <tt>status</tt> command"</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sudo /etc/init.d/postgresql-8.4 status<br>sudo /etc/init.d/postgresql-8.4 start<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Add postgres startup scripts to the Linux init scripts to start
Postgres automatically after a reboot.</p>
<p><strong> NOTES:</strong></p>
<ul>
  <li>Red Hat 5.4 includes support for postgresql 8.1. We recommend
upgrading to version 8.4.7.</li>
  <li>Configure Postgres to start automatically during system boot-up.
You can do this by modifying the appropriate rc scripts or by using the
chkconfig command.</li>
  <li>The python-crypto (64-bit) and python-paramiko packages are
required for SciDB on Red Hat 5.4.</li>
</ul>
<h4 id="RemoteExecutionConfigurationssh">Remote Execution Configuration
(ssh)</h4>
<p> SciDB uses ssh for remote execution of cluster management commands.
The Linux user account used by SciDB must have password-less ssh access
from the coordinator to the workers, as well as from the coordinator to
itself.</p>
<p> There are several methods to configure password-less ssh between
nodes. We recommend the following simple method.</p>
<ol>
  <li>Create key.
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">ssh-keygen<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<ol start="2">
  <li>Copy key to each worker node. Also copy key to the localhost (or
coordinator).
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">ssh-copy-id scidb@worker<br><br>ssh-copy-id scidb@localhost<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<ol start="3">
  <li>Login to remote host. Note that no password is required now.
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">ssh scidb@worker<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<h4 id="Sharedfilesystem">Shared file system</h4>
<p> To run SciDB in a cluster environment, export /opt/scidb directory
on the coordinator node using NFS or samba. Mount this on all worker
nodes using the same directory path (/opt/scidb) as the mount point.
The coordinator and worker nodes access binaries, shared libraries,
plugins, configuration files from /opt/scidb.</p>
<h3 id="InstallSciDBfrombinarypackage"><a name="2_1_2">Install SciDB
from binary package</a></h3>
<p> If you are installing a downloaded pre-built binary package, you
can install it using <tt>dpkg</tt> for Ubuntu and <tt>rpm</tt> or <tt>yum</tt>
for Red Hat. We currently provide packages for Ubuntu and RPMs for Red
Hat and Fedora.</p>
<h4 id="Ubuntu">Ubuntu</h4>
<p><strong> Install</strong></p>
<ol>
  <li>First, you should download and install the python-paramiko and
python-crypto packages if they haven't been installed before:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">sudo apt-get install python-paramiko<br>sudo apt-get install python-crypto<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<ol start="2">
  <li>Next, install the libscidbclient package (and debug symbols, if
desired):
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">sudo dpkg  -i libscidbclient-RelWithDebInfo-11.12.0.nnnn-final-Ubuntu-11.04-amd64.deb<br>(optional) sudo dpkg -i libscidbclient-dbg-RelWithDbgInfo-11.12.0.nnnn-final-Ubuntu-11.04-amd64.deb<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<ol start="3">
  <li>Then install the SciDB package (and debug symbols, if desired):
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">sudo dpkg -i scidb-RelWithDebInfo-11.12.0.nnnn-final-Ubuntu-11.04-amd64.deb<br>(optional) sudo dpkg -i scidb-dbg-RelWithDebInfo-11.12.0.nnnn-final-Ubuntu-11.04-amd64.deb<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p> Note: dpkg does not resolve dependencies and you may need to
manually install the dependencies or use apt-get to resolve any unmet
dependencies on the system. This could happen on either the
libscidbclient or SciDB package install. Example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sudo dpkg -i scidb-RelWithDebInfo-11.12....deb    # Fails due to unmet dependencies<br>sudo apt-get -f install                           # installs missing dependencies<br>sudo dpkg -i scidb-RelWithDebInfo-11.12....deb    # Succeeds now<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Uninstall</strong></p>
<ol>
  <li>Uninstall the package using this.
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">sudo dpkg -r scidb-dbg<br>sudo dpkg -r scidb<br><br>sudo dpkg -r libscidbclient-dbg<br>sudo dpkg -r libscidbclient<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<h4 id="RedHatandFedora">Red Hat and Fedora</h4>
<p> You can use <tt>rpm</tt>, <tt>yum</tt> or other tools to install
on Red Hat. First, you need to install the libscidbclient package (and
debug symbols, if desired):</p>
<p><strong> Install</strong> Install the SciDB client package (debug
symbols package is optional)</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sudo rpm --force -ivh libscidbclient-RelWithDebInfo-11.12*.rpm <br>(optional) sudo rpm --force -ivh libscidbclient-dbg-RelWithDebInfo-11.12*.rpm<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Next, install the SciDB server package (and debug symbols, if
desired).</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sudo rpm --force -ivh scidb-11.12*.rpm<br>(optional) sudo rpm --force -ivh scidb-dbg-*.rpm<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Uninstall</strong></p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sudo rpm -e scidb-dbg<br>sudo rpm -e scidb<br><br>sudo rpm -e libscidbclient-dbg<br>sudo rpm -e libscidbclient<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h4 id="EnvironmentVariables">Environment Variables</h4>
<p> To start and run SciDB, configure the environment of the user
account of the SciDB process (we suggest creating a special user <tt>
scidb</tt> for this purpose). The following lines should be added to
the user's shell configuration file (often <tt>.profile</tt> or <tt>.bashrc</tt>
):</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">export SCIDB_VER=11.12<br>export PATH=/opt/scidb/$SCIDB_VER/bin:/opt/scidb/$SCIDB_VER/share/scidb:$PATH<br>export LD_LIBRARY_PATH=/opt/scidb/$SCIDB_VER/lib:$LD_LIBRARY_PATH<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="Buildfromsource"><a name="2_1_3">Build from source</a></h3>
<p> If you have chosen to start from sources, please follow the
directions in this section. If you have successfully installed SciDB
from a binary distribution, you can skip to the next section.</p>
<p> The following software packages are required to build SciDB from
sources.</p>
<ul>
  <li>cmake (2.8.3 or newer)</li>
  <li>boost (1.42. Newer boost versions are not currently supported.)</li>
  <li>protobuf6</li>
  <li>libpqxx (3.0 or higher)</li>
  <li>flex (2.5.35 or newer)</li>
  <li>bison (2.4 or higher)</li>
  <li>log4cxx</li>
  <li>apr</li>
  <li>apr-util</li>
  <li>cppunit</li>
  <li>readline 6</li>
  <li>bz2-dev</li>
  <li>swig (2.0 or higher)</li>
  <li>paramiko (for Python)</li>
  <li>crypto (for Python)</li>
  <li>subversion</li>
  <li>doxygen (optional)</li>
</ul>
<p> On Ubuntu, install these packages using:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sudo apt-get update<br><br>sudo apt-get install -y build-essential cmake libboost1.42-all-dev \<br>postgresql-8.4 libpqxx-3.0 libpqxx3-dev libprotobuf6 libprotobuf-dev \<br>protobuf-compiler doxygen flex bison  \<br>liblog4cxx10 liblog4cxx10-dev libcppunit-1.12-1 libcppunit-dev \<br>libbz2-dev postgresql-contrib  \<br>subversion libreadline6-dev libreadline6 \<br>python-paramiko python-crypto<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Download, build and install swig from <a class="ext-link"
 href="http://sourceforge.net/projects/swig/files/swig/">
<!--span class=&quot;icon&quot;-->&nbsp;sources</a>.</p>
<p> Download the latest scidb source package.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">wget https://p4-releases.s3.amazonaws.com/scidb-11.12.0.xxxx.tgz<br>tar xzf scidb...tgz<br>cd scidb-11.12<br><br>cmake .<br>make <br>sudo make install <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> To start and run SciDB, you need to configure the environment of
the user who will run the SciDB instances as follows. The following
lines should be added to your shell's configuration file. For example
if your shell is Unix bash, this goes in the .bashrc file, or the
.bash_profile:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">export SCIDB_VER=11.12<br>export PATH=/opt/scidb/$SCIDB_VER/bin:/opt/scidb/$SCIDB_VER/share/scidb:$PATH<br>export LD_LIBRARY_PATH=/opt/scidb/$SCIDB_VER/lib:$LD_LIBRARY_PATH<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="ConfiguringSciDB"><a name="2_2">Configuring SciDB</a></h2>
<p> This chapter demonstrates how to configure SciDB prior to
initialization, including checking that the PostgreSQL DBMS is running,
that the SciDB configuration file (usually <tt>
/opt/scidb/11.12/etc/config.ini</tt>) is set up, and that logging is
configured.</p>
<h3 id="SciDBConfigurationFile"><a name="2_2_1">SciDB Configuration File</a>
</h3>
<p> You need to create a configuration file for SciDB. By default, it
is named <tt>config.ini</tt> and it resides in the <tt>etc</tt>
sub-directory of the installation tree. (By default it is <tt>
/opt/scidb/11.12/etc/config.ini</tt>.) The configuration file can have
multiple sections, one per service instance.</p>
<p> The configuration 'test1' below is an example of the configuration
for a single node, single instance system (coordinator only).</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">[test1]<br>node-0=localhost,0<br>db_user=test1user<br>db_passwd=test1passwd<br>install_root=/opt/scidb/11.12<br>metadata=/opt/scidb/11.12/share/scidb/meta.sql<br>pluginsdir=/opt/scidb/11.12/lib/scidb/plugins<br>logconf=/opt/scidb/11.12/share/scidb/log4cxx.properties<br>base-path=/home/scidb/data<br>base-port=1239<br>interface=eth0<br>no-watchdog=true<br>redundancy=2<br>merge-sort-buffer=1024<br>network-buffer=1024<br>mem-array-threshold=1024<br>smgr-cache-size=1024<br>execution-threads=16<br>result-prefetch-queue-size=4<br>result-prefetch-threads=4<br>chunk-segment-size=10485760<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="ClusterConfigurationExample"><a name="2_2_2">Cluster
Configuration Example</a></h3>
<p> The following example of a cluster configuration is called
'monolith'. This cluster consists of eight systems/nodes of equivalent
specifications and running the same version of Red Hat Enterprise Linux:</p>
<ul>
  <li>Intel Xeon X5660 2.8GHz six-core processor</li>
  <li>4GB of RAM</li>
  <li>1TB 6.0Gb/sec SATA hard drive</li>
  <li>1Gbps network connectivity</li>
  <li>RHEL 5.4</li>
</ul>
<p> In this example, the 'monolith' cluster is running one instance of
SciDB on each physical node. Each node is specified by its IP address
and the number of 'worker' instances to be run on that node. A node is
essentially a physical machine and an instance refers to SciDB
workers/processes on each system. The coordinator is a special instance
of worker node; in addition to its duties of a worker, it performs
additional cluster management and coordination duties. The coordinator
node is not counted as a 'worker' in the <tt>config.ini</tt> and it is
assumed to always be on node-0.</p>
<p> We have also specified some of the most common configuration
options such as where data will be stored on disk (base_path), which
port to use (base-port), which network interface SciDB should use
(interface), etc.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">[monolith]<br># node-id=IP, number of worker nodes<br>node-0=10.0.20.231,0<br>node-1=10.0.20.232,1<br>node-2=10.0.20.233,1<br>node-3=10.0.20.234,1<br>node-4=10.0.20.235,1<br>node-5=10.0.20.236,1<br>node-6=10.0.20.237,1<br>node-7=10.0.20.238,1<br>db_user=monolith<br>db_passwd=monolith<br>install_root=/opt/scidb/11.12<br>metadata=/opt/scidb/11.12/<br>share/scidb/meta.sql<br>pluginsdir=/opt/scidb/11.12/lib/scidb/plugins<br>logconf=/opt/scidb/log4cxx.properties.trace<br>base-path=/data/monolith_data<br>base-port=1239<br>interface=eth0<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The install package contains a sample configuration file, <tt>
sample_config.ini</tt>, which is used for SciDB testing. The sample
file is an example of a configuration file containing multiple
configurations, one for a single instance and one for a dual instance,
but on the same node.</p>
<p> The following table describes the basic configuration file contents
and how to set them:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <th colspan="2" style="text-align: left;"><strong>Basic
Configuration</strong> </th>
    </tr>
    <tr>
      <th><strong> Key</strong></th>
      <th><strong> Value</strong></th>
    </tr>
    <tr>
      <td> cluster name</td>
      <td> Name of the SciDB cluster. The cluster name must appear as a
section heading in the config.ini file, e.g.,<em> [cluster1]</em></td>
    </tr>
    <tr>
      <td> node-N</td>
      <td> The host name or IP address used by node N and the number of
worker instances on it. Node 0 always has the coordinator node running
as instance 0, and may have additional worker instances running as well.</td>
    </tr>
    <tr>
      <td> db_user</td>
      <td> Username to use in the catalog connection string. This
example uses<em> test1user</em></td>
    </tr>
    <tr>
      <td> db_passwd</td>
      <td> Password to use in the catalog connection string. This
example uses<em> test1passwd</em></td>
    </tr>
    <tr>
      <td> install_root</td>
      <td> Path name of install root. Must be the same on all nodes.
When using a multi-node environment, configuring this using NFS will
reduce the number of installations needed.</td>
    </tr>
    <tr>
      <td> metadata</td>
      <td> Metadata definition file. The recommended NFS configuration
makes this visible under the same path name on master and worker
processes.</td>
    </tr>
    <tr>
      <td> pluginsdir</td>
      <td> The folder or directory in which plugins are stored. Must be
visible under the same path name to all workers.</td>
    </tr>
    <tr>
      <td> logconf</td>
      <td> Config file for SciDB log. Edit this to set a different
filename or log level (default file name is<em> INFO</em> and default
file name is scidb.log.</td>
    </tr>
  </tbody>
</table>
<p> The following table describes the cluster configuration file
contents and how to set them:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <th colspan="2" style="text-align: left;"><strong>Cluster
Configuration</strong></th>
    </tr>
    <tr>
      <th><strong> Key</strong></th>
      <th><strong> Value</strong></th>
    </tr>
    <tr>
      <td> base-path</td>
      <td> The root data directory for each SciDB instance. Note that
this directory will be the same for all nodes (all instances read from
the same config.ini). When each SciDB node is initialized, it creates
it's own sub-directories for it's local data. E.g., if the base is <tt>/scidb</tt>,
then




      <tt>/scidb/000/0</tt> will hold the data and logs for the
coordinator, while <tt>/scidb/001/1</tt> will hold data for the first
worker instance on the first worker node.</td>
    </tr>
    <tr>
      <td> base-port</td>
      <td> base port number. Connections to the coordinator (and
therefore to the system) are via this number, while worker instances
communicate at base-port + instance number. The default number that <tt>iquery</tt>
expects is 1239.</td>
    </tr>
    <tr>
      <td> interface</td>
      <td> Ethernet interface used for SciDB used on all nodes - master
and workers. Used to bind SciDB to the correct local interface.</td>
    </tr>
    <tr>
      <td> ssh-port</td>
      <td> (optional) the port which ssh uses for communications within
the cluster. The default value is 22.</td>
    </tr>
    <tr>
      <td> key-file-list</td>
      <td> (optional) a comma-separated list of filenames that include
keys for ssh authentication.</td>
    </tr>
    <tr>
      <td> tmp-path</td>
      <td> (optional) a directory to use as temporary space.</td>
    </tr>
    <tr>
      <td> no-watchdog</td>
      <td> default=false, Set this to true if you do not want automatic
restart of the SciDB node on software crash.</td>
    </tr>
  </tbody>
</table>
<p> The following table describes the configuration file elements for
tuning your system performance:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <th colspan="2" style="text-align: left;"><strong>Performance
Configuration</strong></th>
    </tr>
    <tr>
      <th><strong> Key</strong></th>
      <th><strong> Value</strong></th>
    </tr>
    <tr>
      <td> save-ram</td>
      <td> (optional) 'True', 'true', 'on' or 'On' will enable this
option. Off by default.</td>
    </tr>
    <tr>
      <td> merge-sort-buffer</td>
      <td> (optional) Size of memory buffer used in merge sort. Default
is 512 MB.</td>
    </tr>
    <tr>
      <td> mem-array-threshold</td>
      <td style="text-align: left;">(optional) Memory footprint for
temporary arrays. Default is 1024 MB.</td>
    </tr>
    <tr>
      <td> chunk-reserve</td>
      <td> Percentage of chunk preallocated to store chunk deltas.
Default is 10%. Setting this parameter to 0 disables the delta
mechanism.</td>
    </tr>
    <tr>
      <td> chunk-segment-size</td>
      <td> Size in bytes of a storage segment. A storage segment is a
unit of allocation and reclaim used by storage manager. (1) Place
chunks belonging to the same array within the same segment for
sequential reads, (2) Reclaim space from removed arrays. If set to
zero, then segments are not used and storage is allocated chunk at a
time, and space will not be reclaimed.</td>
    </tr>
    <tr>
      <td> execution-threads</td>
      <td> Size of thread pool available for query execution. Shared
pool of threads used by all queries for network IO and some query
execution tasks. Default is 4.</td>
    </tr>
    <tr>
      <td> result-prefetch-threads</td>
      <td> Per-query number of result chunks to prefetch. Default is 4.</td>
    </tr>
    <tr>
      <td> result-prefetch-queue-size</td>
      <td> Per-query number of result chunks to prefetch. Default is 4.</td>
    </tr>
    <tr>
      <td> smgr-cache-size</td>
      <td> (optional) Size of buffer cache. Default is 256 MB</td>
    </tr>
  </tbody>
</table>
<p> In our example shown above, the db_user field is set to<em>
test1user</em> and db_passwd is set to<em> test1passwd</em>. Due to a
current limitation in the system, use of the same user name with
different cluster configurations might cause problems, so it is
preferable to generate unique user names for each cluster
configuration. These are Postgres user names, not system users. The
Postgres database created is the same as the section header,<em> test1</em>
.</p>
<h3 id="LoggingConfiguration"><a name="2_2_3">Logging Configuration</a></h3>
<p> SciDB uses Apache's log4cxx (<a class="ext-link"
 href="http://logging.apache.org/log4cxx/">
<!--span class=&quot;icon&quot;-->&nbsp;http://logging.apache.org/log4cxx/</a>)
for
logging.</p>
<p> The logging configuration file, specified by the <tt>logconf</tt>
variable in <tt>config.ini</tt>, contains the following Apache log4cxx
logger settings:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">###<br># Levels: TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL<br>###<br>log4j.rootLogger=DEBUG, file<br><br>log4j.appender.file=org.apache.log4j.RollingFileAppender<br>log4j.appender.file.File=scidb.log<br>log4j.appender.file.MaxFileSize=10000KB<br>log4j.appender.file.MaxBackupIndex=2<br>log4j.appender.file.layout=org.apache.log4j.PatternLayout<br>log4j.appender.file.layout.ConversionPattern=%d [%t] [%-5p]: %m%n<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="SystemCatalogInitialization"><a name="2_2_4">System Catalog
Initialization</a></h3>
<p> This step is required only if user <tt>scidb</tt> does<strong> not</strong>
have<em> sudo</em> privileges. If this is the case, ask your system
administrator to run this script as the <tt>postgres</tt> user:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sudo -u postgres /opt/scidb/11.12/bin/scidb-prepare-db.sh<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This script does the following:</p>
<ol class="lowerroman">
  <li>creates a new role or account (say<em> test1user</em>) with
password (say<em> test1passwd</em>)</li>
  <li>creates a database for testing scidb (say<em> test1</em>) using
the role created in the first step</li>
  <li>creates a schema in that newly created Postgres database to hold
the SciDB catalog data.</li>
</ol>
<h2 id="InitializingandStartingSciDB"><a name="2_3">Initializing and
Starting SciDB</a></h2>
<h3 id="Thescidb.pyScript"><a name="2_3_1">The scidb.py Script</a></h3>
<p> To begin a SciDB session, use the <tt>scidb.py</tt> script. In a
standard SciDB build, this script is located at:</p>
<blockquote>
  <p> <tt>/opt/scidb/</tt><em>version.number</em><tt>/bin</tt></p>
</blockquote>
<p> The syntax for the <tt>scidb.py</tt> script is:
<br>
</p>
<blockquote>
  <p> <tt>scidb.py</tt><em> command</em><em> db</em><em> conffile</em></p>
</blockquote>
<p> The options for the<em> command</em> argument are:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <td> initall</td>
      <td> Initialize the Postgres database.<strong> Warning</strong>:
This will remove any existing SciDB arrays from the current namespace.</td>
    </tr>
    <tr>
      <td> startall</td>
      <td> Start a SciDB instance</td>
    </tr>
    <tr>
      <td> stopall</td>
      <td> Stop the current SciDB instance</td>
    </tr>
    <tr>
      <td> status</td>
      <td> Show the status of the current SciDB instance</td>
    </tr>
    <tr>
      <td> dbginfo</td>
      <td> Collect debugging information by getting all logs, cores,
and install files</td>
    </tr>
    <tr>
      <td> dbginfo-lt</td>
      <td> Show stack and log information from debug</td>
    </tr>
    <tr>
      <td> version</td>
      <td> Show SciDB version number</td>
    </tr>
  </tbody>
</table>
<p> The <tt>db</tt> argument is the name of the SciDB instance you
want to create.</p>
<p> The configuration file is set by default to <tt>
/opt/scidb/11.12/etc/config.ini</tt>. If you want to use a custom
configuration file for a particular SciDB instance, use the <tt>
conffile</tt> argument.</p>
<p> Run the following command to initialize SciDB on all nodes. If the
SciDB user has sudo privileges, everything will be done automatically
(otherwise see the previous section for additional Postgres
configuration steps):</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scidb.py initall test1<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Note: This will reinitialize the SciDB database. Any arrays that
you have created in previous SciDB sessions will be removed and the
memory recovered.</p>
<p> To start the set of local SciDB instances specified in your
config.ini file, use the following command:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scidb.py startall test1<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This will report the status of the various nodes:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scidb.py status test1<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> and this will shut it down:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scidb.py stopall test1<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> SciDB logs are written to the file <tt>scidb.log</tt> in the
appropriate directories for each instance: &lt;base-path&gt;/000/0 for
the coordinator and &lt;base-path&gt;/M/N the worker node M instance N.</p>
<h2 id="UpgradingSciDB"><a name="2_4">Upgrading SciDB</a></h2>
<p> Note: test1 in the following examples refers to the name of the
SciDB database. All of the following steps are performed as Linux user<strong>
scidb</strong>.</p>
<ul>
  <li>Shutdown SciDB on all nodes in the cluster.
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">scidb.py stopall test1<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ul>
<ul>
  <li>Download and install the latest SciDB package using the standard
package manager on your platform (rpm or dpkg).</li>
</ul>
<blockquote>
  <blockquote>
    <p> If you are installing a downloaded pre-built binary package,
you can install it using <tt>dpkg</tt> for Ubuntu and <tt>rpm</tt> or
    <tt>yum</tt> for Red Hat. We currently provide packages for Ubuntu
and RPMs for Red Hat and Fedora.</p>
  </blockquote>
</blockquote>
<h3 id="Ubuntu1"><a name="2_4_1">Ubuntu</a></h3>
<ol>
  <li>First, install the libscidbclient package (and debug symbols, if
desired):
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">sudo dpkg -i libscidbclient-RelWithDbgInfo-11-12*.deb<br>(optional) sudo dpkg -i libscidbclient-dbg-RelWithDbgInfo-11-12*.deb<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<ol start="2">
  <li>Then install the SciDB package (and debug symbols, if desired):
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">sudo dpkg -i scidb-RelWithDebInfo-11.12-*.deb <br>(optional) sudo dpkg -i scidb-dbg-RelWithDebInfo-11.12-*.deb <br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<h3 id="RedHatandFedora1"><a name="2_4_2">Red Hat and Fedora</a></h3>
<ol>
  <li>First, you need to install the libscidbclient package (and debug
symbols, if desired):
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">sudo rpm --force -Uvh libscidbclient-RelWithDebInfo-11.12*.rpm <br>(optional) sudo rpm --force -Uvh libscidbclient-dbg-RelWithDebInfo-11.12*.rpm<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Next, install the SciDB server package (and debug symbols, if
desired).
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">sudo rpm --force -Uvh scidb-11.12*.rpm<br>(optional) sudo rpm --force -Uvh scidb-dbg-*.rpm<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<ul>
  <li>Copy over the previous config.ini from your earlier version.
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">cp /opt/scidb/11.12/etc/config.ini /opt/scidb/11.12/etc/config.ini<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ul>
<h3 id="AdditionalSteps"><a name="2_4_3">Additional Steps</a></h3>
<ul>
  <li>Modify the config.ini file that you just copied. Change all
references to your previous version to the new version (ex:
install_root=/opt/scidb/11.12)</li>
</ul>
<ul>
  <li>Edit your environment and update PATH and LD_LIBRARY_PATH.
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">export SCIDB_VER=11.12<br>export PATH=/opt/scidb/$SCIDB_VER/bin:/opt/scidb/$SCIDB_VER/share/scidb:$PATH<br>export LD_LIBRARY_PATH=/opt/scidb/$SCIDB_VER/lib:$LD_LIBRARY_PATH<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ul>
<ul>
  <li><strong>NOTE:</strong> SciDB 11.12 does not accept storage files
from earlier versions. You must re-initialize and re-load data.
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">which scidb.py # Make sure you are running 11.12<br>scidb.py initall test1<br>scidb.py startall test1<br>scidb.py status test1<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ul>
<hr noshade="noshade">
<h1 id="GettingStartedwithSciDBDevelopment"><a name="3">Getting Started
with SciDB Development</a></h1>
<h2 id="UsingtheiqueryClient"><a name="3_1">Using the iquery Client</a></h2>
<p> The <tt>iquery</tt> executable is the basic command line tool for
communicating with SciDB. <tt>iquery</tt> is the default SciDB client
used to issue AQL and AFL commands. Start the <tt>iquery</tt> client
by typing <tt>iquery</tt> at the command line when a SciDB session is
active:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scidb.py startall scidb_server<br>iquery<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> By default, <tt>iquery</tt> opens an AQL command prompt:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">AQL%<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can then enter AQL queries at the command prompt. To switch to
AFL queries, use the set command:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">AQL% set lang afl;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> AQL statements end with a semicolon (;).</p>
<p> To see the internal <tt>iquery</tt> commands reference type <tt>help</tt>
at the prompt:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">AQL% help;<br>set            - List current options<br>set lang afl   - Set AFL as querying language<br>set lang aql   - Set AQL as querying language<br>set fetch      - Start retrieving query results<br>set no fetch   - Stop retrieving query results<br>set timer      - Start reporting query setup time<br>set no timer   - Stop reporting query setup time<br>set verbose    - Start reporting details from engine<br>set no verbose - Stop reporting details from engine<br>quit or exit   - End iquery session<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can pass an AQL query directly to <tt>iquery</tt> from the
command line using the -q flag:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -q "my AQL statement"<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can also pass a file containing an AQL query to <tt>iquery</tt>
with the -f flag:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -f my_input_filename<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> AQL is the default language for <tt>iquery</tt>. To switch to AFL,
use the -a flag:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -aq "my AFL statement"<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Each invocation of <tt>iquery</tt> connects to the SciDB
coordinator node, passes in a query, and prints out the coordinator
node's response. <tt>iquery</tt> connects by default to SciDB on port
1239. If you use a port number that is not the default, specify it
using the "-p"
option with <tt>iquery</tt>. For example, to use port 9999 to run an
AFL query contained in the file <tt>my_filename</tt></p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -af my_input_filename -p 9999<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The query result will be printed to stdout. Use -r flag to redirect
the output to a file:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -r my_output_filename -af my_input_filename<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> By default, the output will be formatted as a SciDB array. The
output array may be formatted as sparse, in which case the block number
for a cell will be printed, or dense, in which case the attributes will
be printed.</p>
<p> To change the output format, use the -o flag:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -o csv -r my_output_filename.csv -af my_input_filename<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Available options for output format are csv, csv+, lcsv, lcsv+,
sparse, and lsparse.</p>
<p> To see a list of the <tt>iquery</tt> switches and their
descriptions, use <tt>iquery -h</tt> or <tt>iquery --help</tt>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -h<br>Available options::<br>  -c [ --host ] arg       Host of one of the cluster nodes. Default is <br>                          'localhost'.<br>  -p [ --port ] arg       Port for connection. Default is 1239.<br>  -q [ --query ] arg      Query to be executed.<br>  -f [ --query-file ] arg File with query to be executed.<br>  -r [ --result ] arg     Filename with result array data.<br>  -o [ --format ] arg     Output format: auto, csv, csv+, lcsv+, sparse, <br>                          lsparse. Default is 'auto'.<br>  -v [ --verbose ]        Print debug info. Disabled by default.<br>  -t [ --timer ]          Query setup time.<br>  -n [ --no-fetch ]       Skip data fetching. Disabled by default.<br>  -a [ --afl ]            Switch to AFL query language mode. AQL by default.<br>  -u [ --plugins ] arg    Path to the plugins directory.<br>  -h [ --help ]           Show help.<br>  -V [ --version ]        Show version info.<br>  --ignore-errors         Ignore execution errors in batch mode.<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The <tt>iquery</tt> interface is case sensitive.</p>
<p><strong> Example</strong>:</p>
<ul>
  <li>Create an array called random_numbers with:
    <ul>
      <li>2 dimensions, x = 9 and y = 10</li>
      <li>one double attribute called num</li>
      <li>random numerical values in each cell
        <center>
        <table border="1" bordercolor="#d7d7d7" width="95%"
 align="center">
          <tbody>
            <tr>
              <td bgcolor="#f7f7f7">
              <pre class="wiki">iquery -aq "store(build(&lt;num:double&gt;[x=0:8,1,0, y=0:9,1,0], random()),random_numbers)" <br></pre>
              </td>
            </tr>
          </tbody>
        </table>
        </center>
      </li>
    </ul>
  </li>
  <li>Save the numerical values in random_numbers in csv format to a
file called /tmp/random_values.csv:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">iquery -o csv -r /tmp/random_values.csv -aq "scan(random_numbers)"<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ul>
<h2 id="iqueryConfiguration"><a name="3_2">iquery Configuration</a></h2>
<p> You can use a configuration file to save and restore your <tt>iquery</tt>
configuration. The file is stored in ~/.config/scidb/iquery.conf. Once
you have created this file it will load automatically the next time you
start <tt>iquery</tt>. The allowed options are:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <td> host</td>
      <td> Host name for the cluster node. Default is <tt>
localhost</tt>.</td>
    </tr>
    <tr>
      <td> port</td>
      <td> Port for connection. Default is 1239.</td>
    </tr>
    <tr>
      <td> afl</td>
      <td> Start AFL command line</td>
    </tr>
    <tr>
      <td> timer</td>
      <td> Report query run-time (in seconds).</td>
    </tr>
    <tr>
      <td> verbose</td>
      <td> Print debug information.</td>
    </tr>
    <tr>
      <td> format</td>
      <td> Set the format of query output. Options are csv, csv+, lcsv,
lcsv+, sparse, and lsparse.</td>
    </tr>
    <tr>
      <td> plugins</td>
      <td> Path to the plugins directory</td>
    </tr>
  </tbody>
</table>
<p> For example, your iquery.conf file might look like this:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">{<br>"host":"mynodename",<br>"port":9999,<br>"afl":true,<br>"timer":false,<br>"verbose":false,<br>"format":"csv+",<br>"plugins":"./plugins"<br>}<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The opening and closing braces at the beginning and end of the file
must be present and each entry (except the last one) should be followed
by a comma.</p>
<h2 id="Exampleiquerysession"><a name="3_3">Example iquery session</a></h2>
<p> This example demonstrates how to use iquery to perform simple array
tasks:</p>
<ul>
  <li>Create a SciDB array</li>
  <li>Prepare an ASCII load file in the SciDB<em> dense</em> load file
format</li>
  <li>Load data from that file into the array.</li>
  <li>Execute basic queries on the array</li>
  <li>Join two arrays containing related data</li>
</ul>
<ol>
  <li>Create an array, <tt>target</tt>, in which you are going to
place the values from the csv file:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">iquery -aq "create array target &lt;name:string, mpg:double&gt;[x=0:*,1,0]"<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Starting from a csv file, prepare a SciDB load file.</li>
</ol>
<p><em> datafile.csv:</em></p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">Model,MPG<br>CRV, 23.5<br>Prius, 48.7<br>Explorer, 19.6<br>Q5, 26.8<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Convert the file to SciDB format with the command csv2scidb:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">csv2scidb -p SN -s 1 &lt; /tmp/datafile.csv &gt; /tmp/datafile.scidb<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Note</strong>: <tt>csv2scidb</tt> is a separate data
preparation utility provided with SciDB. To see all options available
for csv2scidb, type <tt>csv2scidb --help</tt> at the command line.</p>
<ol start="3">
  <li>Use the load command to load the SciDB-formatted file you just
created into <tt>target</tt>:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">iquery -aq "load(target, '/tmp/datafile.scidb')"<br>[("CRV",23.5),("Prius",48.7),("Explorer",19.6),("Q5",26.8)]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p> By default, iquery always re-reads or retrieves the data that has
just written to the array. To suppress the print to screen when you use
the load command, use the -n flag in iquery:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -naq "load(target, '/tmp/datafile.scidb')"<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<ol start="4">
  <li>Now, suppose you want to convert miles-per-gallon to kilometers
per liter. Use the apply function to perform a calculation on the
attribute values <tt>mpg</tt>:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">iquery -aq "apply(target,kpl,mpg*.4251)"<br>[("CRV",23.5,9.98985),("Prius",48.7,20.7024),("Explorer",19.6,8.33196),("Q5",26.8,11.3927)]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p> Note that this does not update <tt>target</tt>. Instead, SciDB
creates an result array with the new calculated attribute <tt>kpl</tt>.

To
create
an
array
containing
the kpl attribute, use the <tt>store</tt>
command:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -aq "store(apply(target,kpl,mpg*.4251),target_new)"<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<ol start="5">
  <li>Suppose you have a related data file, datafile_price.csv:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">Make,Model,Price<br>Honda,CRV,26700<br>Toyota,Prius,31000<br>Ford, Explorer,42000<br>Audi,Q5,45000<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p> You want to add the data on price and make to your array. Use
csv2scidb to convert the file to SciDB data format:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">csv2scidb -p SSN -s 1 &lt; /tmp/datafile_price.csv &gt; /tmp/datafile_price.scidb<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Create an array called storage:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -aq "create array storage &lt;make:string, model:string, price:int64&gt;[x=0:*,1,0]"<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Load the datafile_price.scidb file into storage:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -naq "load(storage, '/tmp/datafile_price.scidb')"<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<ol start="6">
  <li>Now, you want to combine the data in these two files so that each
entry has a make, and model, a price, an mpg, and a kpl. You can join
the arrays, with the <tt>join</tt> operator:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">iquery -aq "join(storage,target_new)"<br>[("Honda","CRV",26700,"CRV",23.5,9.98985),<br>("Toyota","Prius",31000,"Prius",48.7,20.7024),<br>("Ford"," Explorer",42000,"Explorer",19.6,8.33196),<br>("Audi","Q5",45000,"Q5",26.8,11.3927)]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p> Note that attributes 2 and 4 are identical. Before you store the
combined data in an array, you want to get rid of duplicated data.</p>
<ol start="7">
  <li>You can use the project operator to specify attributes in a
specific order:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">iquery -aq project(target_new,mpg,kpl)<br>[(23.5,9.98985),(48.7,20.7024),(19.6,8.33196),(26.8,11.3927)]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p> Attributes that are not specified are not included in the output.</p>
<p> Now use the <tt>join</tt> and <tt>project</tt> operators to put
the car data together. For easier reading, use csv as the query output
format:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -o csv -aq "join(storage,project(target_new,mpg,kpl))"<br>make,model,price,mpg,kpl<br>"Honda","CRV",26700,23.5,9.98985<br>"Toyota","Prius",31000,48.7,20.7024<br>"Ford"," Explorer",42000,19.6,8.33196<br>"Audi","Q5",45000,26.8,11.3927<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<hr noshade="noshade">
<h1 id="CreatingandRemovingSciDBArrays"><a name="4">Creating and
Removing SciDB Arrays</a></h1>
<p> SciDB stores data as a collection of chunked multi-dimensional
nested arrays. Just as a relational table is the basic data structure
of relational algebra and SQL, SciDB uses multi-dimensional arrays as
the basis for linear algebra and complex analytics.</p>
<p> A SciDB database is organized into arrays that have:</p>
<ul>
  <li>A<em> name</em>. Each array in a SciDB database has an identifier
that distinguishes it from all other arrays in the same database.</li>
</ul>
<ul>
  <li>A<em> schema</em>, which is the array structure. The schema
contains array dimensions and attributes.</li>
</ul>
<ul>
  <li>We use the term<em> shape</em> in reference to an array's
collection of dimensions. To have the same or compatible shapes, two
arrays must have the same number and order of dimensions and the
corresponding dimensions in the two arrays must have the same type and
size.</li>
</ul>
<ul>
  <li>Each<em> dimension</em> consists of a list of index values. At
the most basic level the dimension of an array is represented using
64-bit unsigned integers. The number of index values in a dimension is
referred to as the dimension's size (or occasionally its extent). SciDB
support arrays with noninteger dimensions by mapping noninteger
values into the basic unsigned 64-bit integer dimension type.</li>
</ul>
<ul>
  <li><em>Cell</em> or<em> element</em>. Each combination of dimension
values identifies a single element or cell in the array. Each cell may
be empty or is occupied by one or more attributes.</li>
</ul>
<ul>
  <li><em>Attribute</em>. Each cell contains a list of named, typed
attributes.</li>
</ul>
<h2 id="Creatingandremovingarrays"><a name="4_1">Creating and removing
arrays</a></h2>
<p> Arrays are created and removed using the<em> create array</em> and<em>
remove</em> commands described below.</p>
<h2 id="createarray"><a name="4_2">create array</a></h2>
<p><strong> Summary</strong>: Create a SciDB array</p>
<p> The CREATE ARRAY statement is used to a create new array. The
statement specifies the array name and the array schema. The array
schema is a description of the array properties which includes the array<em>
shape</em> (the number of dimensions and their sizes), and the array<em>
attributes</em> (the data items that appear in each cell).</p>
<p><strong> Signature</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE [array_type] ARRAY <br>    array_name <br>    &lt; attribute_name : type_name [ NULL | NOT NULL ] [, ...] &gt; <br>    [ dimension_name = start: end|*, chunk_size, chunk_overlap [, ...] ]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> SciDB arrays have the following elements.</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <td><strong> Array Feature</strong></td>
      <td><strong> Optional</strong> </td>
      <td><strong> Description</strong></td>
    </tr>
    <tr>
      <td> array_name</td>
      <td> No</td>
      <td style="text-align: left;">The string name of the array. The
array name uniquely identifies the array in the SciDB instance. You
cannot use the same array name twice in one SciDB instance. Array names
should not contain the characters <tt>@</tt> or <tt>:</tt> as these
characters are reserved for mapping arrays.</td>
    </tr>
    <tr>
      <td> EMPTY flag</td>
      <td> Yes</td>
      <td> By default, all arrays have all cells present. Users can
optionally specify 'EMPTY', in which case some cells may be omitted.</td>
    </tr>
    <tr>
      <td> attribute_name</td>
      <td> No</td>
      <td> Name of an attribute. No two attributes in the same array
can share a name.</td>
    </tr>
    <tr>
      <td> type_name</td>
      <td> No</td>
      <td> Type identifier. One of the data types supported by SciDB.
Use the <tt>list('types')</tt> command to see the list of available
data types.</td>
    </tr>
    <tr>
      <td style="text-align: left;">NULL flag</td>
      <td> Yes</td>
      <td> By default, all attributes are 'NOT NULL', i.e. they will
have a value. Optionally, users can specify 'NULL' to indicate
attributes that are allowed to contain null values.</td>
    </tr>
    <tr>
      <td> dimension_name</td>
      <td> No</td>
      <td> Each dimension has a name. Just like attributes, each
dimension must be named, and dimension names cannot be repeated in the
same array</td>
    </tr>
    <tr>
      <td> start (integer)</td>
      <td> No</td>
      <td> The starting coordinate of a dimension</td>
    </tr>
    <tr>
      <td> end (integer)</td>
      <td> No</td>
      <td> The ending coordinate of a dimension, or * if unknown</td>
    </tr>
    <tr>
      <td> chunk_size</td>
      <td> No</td>
      <td style="text-align: left;">The length of the data chunk along
a dimension.</td>
    </tr>
    <tr>
      <td> chunk_overlap</td>
      <td> No</td>
      <td> The length of overlap along a dimension. Overlap specifies
the extended chunk, including additional cells from adjoining chunks in
the array that are colocated with a given chunk. Like chunk sizes,
overlap is an internal storage management concept, and does not change
the result of an operator. In this release, some operators rely on
overlap, as described later in this document.</td>
    </tr>
  </tbody>
</table>
<h2 id="Basicexamples"><a name="4_3">Basic examples</a></h2>
<p> This sections contains several examples of creating arrays using
the CREATE ARRAY statement.</p>
<p><em> Example One:</em></p>
<p> Create a 2-dimensional array that has:</p>
<ol class="lowerroman">
  <li>Dimension names 'x' and 'y',</li>
  <li>Equal length dimensions ranging between 0 and 49 (having length
50)</li>
  <li>Chunks each of size 10 in each dimension</li>
  <li>No chunk overlap</li>
  <li>One integer attribute named 'Val'</li>
</ol>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> CREATE ARRAY Example_One &lt; Val: int32 &gt; [ X=0:49,10,0, Y=0:49,10,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><em> Example Two:</em></p>
<p> Create a 3-dimensional array with dimension indices</p>
<ol class="lowerroman">
  <li>having names X, Y and Z,</li>
  <li>with values for the X and Y dimensions ranging between 0 and 9
(length 10) and the Z dimension ranging over 0:99 (length = 100)</li>
  <li>stored entirely within a single chunk of size 10x10x100.</li>
  <li>with no overlap.</li>
</ol>
<p> and two attributes A and B being a string and a double-precision
value:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> CREATE ARRAY Example_Three &lt; A: string, B: double &gt; [ X=0:9,10,0, Y=0:9,10,0, Z=0:99,100,0 ]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><em> Example Three:</em></p>
<p> The following is a 2-dimensional array with dimensions</p>
<ol class="lowerroman">
  <li>having names I and J, with I ranging over 0 to 99 and J over 0 to
199, and</li>
  <li>broken into<em> chunks</em> of size 10x20</li>
</ol>
<p> The array's cells contain a pair of attribute values, A and B,
having types int32 and float.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> CREATE ARRAY Example_Four &lt;A:int32, B:float&gt; [I=0:99,10,0, J=0:199,20,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><em> Example Four:</em></p>
<p> The following is a 2-dimensional array with dimensions</p>
<ol class="lowerroman">
  <li>having names I and J, with I ranging over 0 to 9 and J over 0 to
9, and</li>
  <li>fitting into a single<em> chunk</em> of size 10x10</li>
</ol>
<p> Our example has two attributes, A and B, having types int32 and
double.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> CREATE ARRAY Example_Five &lt; A: int32, B: double &gt; [ I=0:9,10,0, J=0:9,10,0 ]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="show"><a name="4_4">show</a></h2>
<p><strong> Summary:</strong> The show operator can be used to review
the schema of an array that is stored within SciDB.</p>
<p><strong> Signature</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">show( array )<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create empty array A &lt;a:int32&gt; [x=0:2,3,0];<br><br>show(A);<br>[("A&lt;a:int32 NOT NULL,empty_indicator:indicator NOT NULL&gt; [x=0:2,3,0]")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="Emptyarrays"><a name="4_5">Empty arrays</a></h2>
<p> The EMPTY keyword in the CREATE statement indicates that some cells
may be absent.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE EMPTY ARRAY A_10 &lt;x:double null, y:double null&gt;[i=1:10,5,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Note that EMPTY is fundamentally different than NULL. EMPTY is a
property of an entire cell and indicates that the entire cell has been
omitted, i.e. is not present. In contrast, NULL is a property of a cell
value. A cell that contains one or more null values is not considered
empty.</p>
<p> If the array is not designated EMPTY at creation time, then
unspecified cells within existing chunks assume the default value
(which in the current version is 0 for numerical attributes and empty
string for string and character attributes). However, chunks that are
missing entirely are always treated as regions of empty cells.</p>
<h2 id="Dimensions"><a name="4_6">Dimensions</a></h2>
<h3 id="Unboundeddimensions"><a name="4_6_1">Unbounded Dimensions</a></h3>
<p> An array dimension can be created as an unbounded dimension by
declaring the high boundary as open using '*'. Examples of unbounded
dimensions include<em> I=0:*,10,0</em> or<em> J=-7:*,100,0.</em> In the
first example,<em> I</em> has a low boundary of 0 and an open high
boundary and<em> J</em> has a low boundary of -7 and an open high
boundary.</p>
<p> A regular array does not allow chunks to be loaded into chunk
addresses that fall outside the region defined by the create array
definition. However, with an array having unbounded dimensions, chunks
can be incrementally loaded into the array into new chunks of the array
and there is no limit on the array dimensions, other than storage
resources available in the system. The array boundaries are dynamically
updated as new data is added to it.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY open_array &lt;a:int64&gt;[x=0:*,5,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> An example of incremental loading into an unbounded array is
described in the<em> load</em> section. Loading data into an unbounded
array causes new array versions to be created.</p>
<h3 id="Non-integerdimensionsandMappingarrays"><a name="4_6_2">
noninteger dimensions and Mapping arrays</a></h3>
<p> Regular arrays in SciDB use the int64 data type for dimensions.
SciDB also supports arrays with noninteger dimensions. These arrays
map dimension<em> values</em> of a declared type to an internal int64
array<em> position</em>. Mapping is done through special mapping arrays
internal to SciDB.</p>
<p> Below is an example of an array with a noninteger dimension:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY non_int_array &lt;a:int64&gt;[ID(string)=10,5,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This command will create an array with a noninteger dimension,
named ID, that has 10 unique string dimension values mapped internally
to positions 0,.., 9, and uses chunks of 5 elements each, with no
overlap.</p>
<p> The most common way to store data into such an array is to use
redimension_store. This AFL command is described in detail in a later
chapter.</p>
<p> However, any output array that has a schema compatible with this
array can be stored into it.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY another_non_int_array &lt;a:int64&gt;[ID(string)=10,5,0]<br>store(another_non_int_array,non_int_array)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> SciDB stores the mapping from value to position for these special
arrays (with noninteger dimensions) using a mapping array. The name of
the mapping array is "array@ID:dimname". This mapping array is used by
SciDB array operators to translate from dimension value to an integer
dimension position in the array. The mapping array is fully replicated
at every node in a cluster SciDB configuration.</p>
<p> For example, when data is stored into the above array, we see the
following new mapping array created for it. This array maps each string<em>
identifier</em> to a corresponding integer array<em> position.</em></p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> show("non_int_array@1:ID");<br>[("non_int_array@1:ID&lt;value:string NOT NULL&gt; [no=0:9,10,0]")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> If the base array is created as a standard versioned array, the
corresponding mapping arrays are also versioned. Hence, the mapping
array shown above corresponds to array version 1, and array version 2 of<em>
non_int_array</em> has mapping array<em> non_int_array@2:ID</em>
.</p>
<h2 id="remove"><a name="4_7">remove</a></h2>
<p><strong> Summary</strong>: Remove an array from a SciDB instance</p>
<p><strong> Syntax</strong>:
<br>
<tt>remove(</tt><em>array_name</em>);</p>
<p> The remove command removes a SciDB array and all of its versions
from the SciDB namespace. The remove operation is preserved even if
there is a node failure. This means that if a remove operation throws
an error, the array will still be removed.</p>
<hr noshade="noshade">
<h1 id="LoadingDataintoaSciDBArray"><a name="5">Loading Data into a
SciDB Array</a></h1>
<p> The load, save, input and substitute commands are used while
loading and unloading data from SciDB into external load files in ASCII
format.</p>
<h2 id="load"><a name="5_1">load</a></h2>
<p> SciDB supports the load operator for loading data into an existing
SciDB array.</p>
<p><strong> Signature</strong>:</p>
<p> load (<em>array_name : array_identifier</em>,<em> data_file : string</em>
[,<em> nodeid : int</em>] )</p>
<p><em> array_name</em> is the array to be loaded.<em> data_file</em>
is the path to a file to use -- absolute or relative to the working
directory of the SciDB server. For a description of<em> nodeid</em>,
see below section on parallel load.</p>
<p> SciDB data load files must be organized according to the schema of
the target array.</p>
<p> Given an array defined as follows:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY Load_Example &lt; Val: int32 &gt; [X=1:100,25,0, Y=1:100,25,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Load files divide the data to be loaded into chunks. Load file
chunks correspond to array chunks as defined by the CREATE ARRAY
statement. So, for the example 2-dimensional array with the following
chunk layout</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">C11 C12 C13 C14<br>C21 C22 C23 C24<br>C31 C32 C33 C34<br>C41 C42 C43 C44<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The<em> chunks</em> in the load file must appear in the following
order:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">C11; C12; C13; C14; C21; C22; ...; C41; C42; C43; C44<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Each chunk may also be prefixed with an optional chunk header that
lists the dimension values of the starting element in that chunk. If
this chunk header is not present, the file is assumed to contain all of
the chunks in the order described above.</p>
<h3 id="Loadformats"><a name="5_1_1">Load formats</a></h3>
<p> SciDB supports two chunk formats in load files corresponding to<em>
dense</em> and<em> sparse</em> data sets. The sparse format is more
efficient when a majority of the cells in the array are absent and do
not contain attribute data. A SciDB array loaded from a data file that
has the sparse load format generates sparse chunks in array storage,
whereas one loaded from a dense file format creates chunks that use the
dense storage format.</p>
<h3 id="Denseloadformat"><a name="5_1_2">Dense load format</a></h3>
<p> In the following example we illustrate how a multi-chunk, dense
array is created and loaded.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY Two_Dim&lt;a: int32, c: char&gt;[I=0:7,4,0, J=0:7,4,0]<br>load(Two_Dim, '/tmp/2d-mc.txt')<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> In the dense representation, the dimension values for each cell are
implicit in the representation. Data is divided up into chunks, with
each chunk enclosed within a '[ ]' and separated by a semi-colon.</p>
<p> Cells within each chunk must appear in<em> left to right</em>
dimension order (e.g., row-major order for a two-dimensional array, or
generalized appropriately to higher dimensions). Each cell contains a
comma-separated list of attribute values placed within (). This 'dense'
representation can denote empty cells using '()'.</p>
<p> Contents of /tmp/2d-mc.txt:</p>
<div class="wikipage" style="font-size: 80%;">
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">[<br>[ (0, 'A'), (1, 'B'), (2, 'C'), (3, 'D')],<br>[ (8, 'I'), (9, 'J'), (10, 'K'), (11, 'L')],<br>[ (16, 'Q'), (17, 'R'), (18, 'S'), (19, 'T')],<br>[ (24, 'Y'), (25, 'Z'), (26, 'A'), (27, 'B')]<br>];<br>[<br>[ (4, 'E'), (5, 'F'), (6, 'G'), (7, 'H')],<br>[ (12, 'M'), (13, 'N'), (14, 'O'), (15, 'P')],<br>[ (20, 'U'), (21, 'V'), (22, 'W'), (23, 'X')],<br>[ (28, 'C'), (29, 'D'), (30, 'E'), (31, 'F')]<br>];<br>[<br>[ (32, 'G'), (33, 'H'), (34, 'I'), (35, 'J')],<br>[ (40, 'O'), (41, 'P'), (42, 'Q'), (43, 'R')],<br>[ (48, 'W'), (49, 'X'), (50, 'Y'), (51, 'Z')],<br>[ (56, 'E'), (57, 'F'), (58, 'G'), (59, 'H')]<br>];<br>[<br>[ (36, 'K'), (37, 'L'), (38, 'M'), (39, 'N')],<br>[ (44, 'S'), (45, 'T'), (46, 'U'), (47, 'V')],<br>[ (52, 'A'), (53, 'B'), (54, 'C'), (55, 'D')],<br>[ (60, 'I'), (61, 'J'), (62, 'K'), (63, 'L')]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
</div>
<p> For the simpler case of a one-dimensional array, the dense load
file format looks like this:</p>
<div class="wikipage" style="font-size: 80%;">
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">[ (36, 'K'), (37, 'L'), (38, 'M'), (39, 'N')]; <br>[ (44, 'S'), (45, 'T'), (46, 'U'), (47, 'V')];<br>[ (52, 'A'), (53, 'B'), (54, 'C'), (55, 'D')];<br>[ (60, 'I'), (61, 'J'), (62, 'K'), (63, 'L')] <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
</div>
<h3 id="Sparseloadformat"><a name="5_1_3">Sparse load format</a></h3>
<p> The sparse load format allows a large number of cells can be
unspecified.</p>
<p> The sparse load format lists the data by chunks--there is a
semi-colon between the chunks--and within each chunk the data is
organized as a list of comma-separated cells, where each cell includes
the coordinates and the attributes of the cell.</p>
<p> For example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array sparse_example&lt;a:double&gt; [x=0:8,2,0,y=0:3,2,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This array is a 2-D array contained within several 2x2 chunks. The
following is an example file '/tmp/sparse_load.txt':</p>
<div class="wikipage" style="font-size: 80%;">
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">cat  /tmp/sparse_load.txt<br>[[ <br>{0,0} (11)<br>{1,0} (21)<br>{0,1} (12)<br>]];<br>[[ <br>{0,2} (13)<br>]];<br>[[ <br>{2,0} (31)<br>{3,0} (41)<br>{2,1} (32)<br>{3,1} (42)<br>]];<br>[[ <br>{2,2} (33)<br>{3,3} (44)<br>]];<br>[[ <br>{7,0} (81)<br>{6,1} (72)<br>{7,1} (82)<br>]];<br>[[ <br>{6,2} (73)<br>{7,2} (83)<br>{7,3} (84)<br>]];<br>[[ <br>{8,0} (91)<br>]];<br>[[ <br>{8,2} (93)<br>{8,3} (94)<br>]]<br><br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
</div>
<p> You would use the following load syntax to load this file into the <tt>
sparse_example</tt> array:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> load(sparse_example, '/tmp/sparse_load.txt')<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Notes:</strong></p>
<ol class="lowerroman">
  <li>The last chunk in the load file should<strong> not</strong> have
a ';' chunk delimiter.</li>
  <li>The SciDB loader ignores additional newline or space characters
in the load file.</li>
  <li>Choosing a particular load file format has no bearing on how data
is stored internally in SciDB.</li>
  <li>In addition to storing the data, load and store operators also
return the data back to the client (or next operator in the query).
When the data is voluminous, this may not be desired and the output of
the query should be suppressed. For instance, the iquery executable
that accompanies SciDB includes the "-n" option for this purpose.</li>
  <li>Note that unspecified cells can have various interpretations,
depending on how the array is declared. See the section on <a
 href="file:///#Emptyarrays">
empty arrays</a>.</li>
</ol>
<h3 id="OptimizingChunkSizetoLoadFormat"><a name="5_1_4">Optimizing
Chunk Size to Load Format</a></h3>
<p> The size and density of the load file determines the optimum chunk
size for its storage array. Chunks should contain on order of 500,000
elements. The number of bits in an element also affects the optimum
chunk size. Chunks that have long strings (greater than 30 characters)
may need to set the chunk size to less than 500,000 elements for
optimum performance.</p>
<h3 id="DatatypeSupport"><a name="5_1_5">Datatype Support</a></h3>
<p> SciDB supports the following datatypes for attributes and
dimensions. Not all SciDB functions support all datatypes. To see if a
function supports a particular datatype, use the <tt>list('functions')</tt>
operator.</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <th>Data type</th>
      <th>Description</th>
    </tr>
    <tr>
      <td> binary</td>
      <td> Machine-readable binary file</td>
    </tr>
    <tr>
      <td> bool</td>
      <td> Boolean TRUE (1) or FALSE (0)</td>
    </tr>
    <tr>
      <td> char</td>
      <td> Single-character</td>
    </tr>
    <tr>
      <td> datetime</td>
      <td> Date and time</td>
    </tr>
    <tr>
      <td> datetimetz</td>
      <td> Timezone</td>
    </tr>
    <tr>
      <td> double</td>
      <td> Double precision decimal</td>
    </tr>
    <tr>
      <td> float</td>
      <td> Floating-point number</td>
    </tr>
    <tr>
      <td> indicator</td>
      <td> Datatype indicator</td>
    </tr>
    <tr>
      <td> int8</td>
      <td> Signed 8-bit integer</td>
    </tr>
    <tr>
      <td> int16</td>
      <td> Signed 16-bit integer</td>
    </tr>
    <tr>
      <td> int32</td>
      <td> Signed 32-bit integer</td>
    </tr>
    <tr>
      <td> int64</td>
      <td> Signed 64-bit integer</td>
    </tr>
    <tr>
      <td> string</td>
      <td> Character string</td>
    </tr>
    <tr>
      <td> uint8</td>
      <td> Unsigned 8-bit integer</td>
    </tr>
    <tr>
      <td> uint16</td>
      <td> Unsigned 16-bit integer</td>
    </tr>
    <tr>
      <td> uint32</td>
      <td> Unsigned 32-bit integer</td>
    </tr>
    <tr>
      <td> uint64</td>
      <td> Unsigned 64-bit integer</td>
    </tr>
    <tr>
      <td> void</td>
      <td> Return nothing</td>
    </tr>
  </tbody>
</table>
<h4 id="DateandTimeOffsets">Date and Time Offsets</h4>
<p> SciDB offers timestamp datatypes so that you can customize date and
time formats.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array time_and_date &lt;mytime:datetime&gt;[i=0:0,1,0];<br>store(build(time_and_date,now()),time_and_date);<br><br>[("2011-12-13 18:41:14")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The time zone data type uses offsets indicating a relative time to
the date and time to The <tt>datetimetz</tt> formats are:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">YYYY/MM/DD hh:mm:ss +/-hh:mm<br>DD.MM.YYYY hh:mm::ss +/-hh:mm<br>YYYY-MM-DD hh:mm:ss.fff +/-hh:mm<br>YYYY-MM-DD hh.mm.ss.fff +/-hh:mm<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can cast datetime to datetimetz by appending an offset:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">apply(time_and_date,dst,append_offset(mytime,3600));<br><br>[("2011-12-13 18:41:14","2011-12-13 19:41:14 +01:00")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> To append an offset and apply it to the time, use apply_offset:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array timedate_and_timezone &lt;mytime:datetime, myzone:datetimetz&gt;[i=0:1,1,0];<br>store(apply(time_and_date,myzone,apply_offset(mytime,3600)),timedate_and_timezone);<br><br>[("2011-12-13 18:41:14","2011-12-13 19:41:14 +01:00")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> To cast a datetimetz to datetime, use the strip_offset function:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">apply(timedate_and_timezone,dst,strip_offset(myzone));<br><br>[("2011-12-13 18:41:14",<br>"2011-12-13 19:41:14 +01:00",<br>"2011-12-13 19:41:14")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> To remove offsets applied to a datetime and cast to datetime, use
the togmt function:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">apply(timedate_and_timezone,dst,togmt(myzone));<br><br>[("2011-12-13 18:41:14",<br>"2011-12-13 19:41:14 +01:00",<br>"2011-12-13 18:41:14")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> To return just the offset from a datetimetz, use the get_offset
function:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">apply(timedate_and_timezone,seconds,get_offset(myzone));<br><br>[("2011-12-13 18:41:14",<br>"2011-12-13 19:41:14 +01:00",<br>3600)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> To return the current time with the current offset, use the tznow
function:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">apply(timedate_and_timezone,est,tznow());<br><br>[("2011-12-13 18:41:14", <br>"2011-12-13 19:41:14 +01:00",<br>"2011-12-13 17:07:59 -05:00")]<br><br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can compare timestamps with the relational operators =,
&lt;&gt;, &gt; , &lt;, &lt;=, &gt;=. SciDB compares times after the
offset is applied. So "2010-10-10, 13:00:00 +1:00" is equal to
"2010-10-10, 12:00:00 +0:00".</p>
<h3 id="MissingData"><a name="5_1_6">Missing Data</a></h3>
<p> Suppose you have a numerical data set that is missing some values:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">less m4x4_missing.txt<br><br>[<br>[(0,100),(1,99),(2,98),(3,97)],<br>[(4),(5,95),(6,94),(7,93)],<br>[(8,92),(9,91),(),(11,89)],<br>[(12,88),(13),(14,86),(15,85)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The array m4x4_missing has two issues: the second values in the
cells (1,0) and (3,1) are missing, and cell (2,2) is completely empty.
You can tell SciDB how you want to handle the missing data with various
array options.</p>
<p> First, consider the case of the completely empty cell, (2,2). By
default, SciDB will add zeros to empty cells. If you want SciDB to
substitute zeros in all empty cells at load time, create the array with
the desired numerical data attributes and load the data set:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array m4x4_missing &lt;val1:double,val2:int32&gt;[x=0:3,4,0,y=0:3,4,0]; <br>load(m4x4_missing,'/tmp/m4x4_missing.txt'); <br><br>[ <br>[(0,100),(1,99),(2,98),(3,97)],<br>[(4,0),(5,95),(6,94),(7,93)], <br>[(8,92),(9,91),(0,0),(11,89)],<br>[(12,88),(13,0),(14,86),(15,85)] <br>] <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This means that cell (2,2) has values (0,0). If the missing data is
a string, it will be replaced with an empty string:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">remove(m4x4_missing); <br>create array m4x4_missing &lt;val1:string,val2:string&gt; [x=0:3,4,0,y=0:3,4,0]; <br>load(m4x4_missing,<br>'/tmp/m4x4_missing'); <br><br>[<br>[("0","100"),("1","99"),("2","98"),("3","97")],<br>[("4",""),("5","95"),("6","94"),("7","93")],<br>[("8","92"),("9","91"),("",""),("11","89")],<br>[("12","88"),("13",""),("14","86"),("15","85")] <br>] <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> To change the default value, that is, the value the SciDB
subtitutes for the missing data, set the default clause of the
attribute option:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array m4x4_missing &lt;val1:double default=3.14159,val2:int32 default 5468&gt;[x=0:3,4,0,y=0:3,4,0];<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> If you want to preserve missing data as empty cells, use the <tt>
empty</tt> option for the create array statement:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">remove(m4x4_missing);<br>create empty array m4x4_missing &lt;val1:double,val2:int32&gt; [x=0:3,4,0,y=0:3,4,0];<br>load(m4x4_missing, '/tmp/m4x4_missing');<br><br>[<br>[(0,100),(1,99),(2,98),(3,97)],<br>[(4,0),(5,95),(6,94),(7,93)],<br>[(8,92),(9,91),(),(11,89)],<br>[(12,88),(13,0),(14,86),(15,85)]<br>]<br>remove(m4x4_missing);<br>create empty array m4x4_missing &lt;val1:string,val2:string&gt; [x=0:3,4,0,y=0:3,4,0];<br>load(m4x4_missing, '/tmp/m4x4_missing');<br><br>[<br>[("0","100"),("1","99"),("2","98"),("3","97")],<br>[("4",""),("5","95"),("6","94"),("7","93")],<br>[("8","92"),("9","91"),(),("11","89")],<br>[("12","88"),("13",""),("14","86"),("15","85")]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> In this case, cell (2,2) is left empty.</p>
<p> In addition to completely empty cells, SciDB arrays can handle
individual missing attribute values within nonempty cells. To
substitute 0 for missing numerical attribute values, create the array
and load the data:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">remove(m4x4_missing);<br>create array m4x4_missing &lt;val1:double,val2:int32&gt;[x=0:3,4,0,y=0:3,4,0]; <br>load(m4x4_missing,'/tmp/m4x4_missing'); <br><br>[ <br>[(0,100),(1,99),(2,98),(3,97)],<br>[(4,0),(5,95),(6,94),(7,93)], <br>[(8,92),(9,91),(0,0),(11,89)],<br>[(12,88),(13,0),(14,86),(15,85)] <br>] <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> In the above array, the val2 of cell (1,0) and cell (3,1) are set
to 0 during the load process. To set the value to NULL, set the NULL
flag of the attribute:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">remove(m4x4_missing);<br>create array m4x4_missing &lt;val1:double null,val2:int32 null&gt; [x=0:3,4,0,y=0:3,4,0];<br>load(m4x4_missing,'/tmp/m4x4_missing'); <br><br>[[(0,100),(1,99),(2,98),(3,97)],<br>[(4,null),(5,95),(6,94),(7,93)],<br>[(8,92),(9,91),(),(11,89)],<br>[(12,88),(13,null),(14,86),(15,85)]]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Missing data may also be specified with NA. For example,</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">less /tmp/na_test.txt<br><br>[<br>[(NA,100),(1,99),(2,98),(3,97)],<br>[(4,5),(5,95),(6,94),(7,93)],<br>[(8,92),(9,91),(12,12),(11,89)],<br>[(12,88),(7,13),(14,86),(15,85)]<br>]<br>create array na_test &lt;val1:double default 3.14159, val2:double default 3.14159&gt; [x=0:3,4,0, y=0:3,4,0];<br>load(na_test,'/tmp/na_test.txt');<br><br>[<br>[(NA,100),(1,99),(2,98),(3,97)],<br>[(4,5),(5,95),(6,94),(7,93)],<br>[(8,92),(9,91),(12,12),(11,89)],<br>[(12,88),(7,13),(14,86),(15,85)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> NA may appear in cells that are missing values. NA will not be
replaced with the default value at load.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">less /tmp/na_test_missing.txt<br><br>[<br>[(NA,100),(1,99),(2,98),(3,97)],<br>[(,NA),(5,95),(6,94),(7,93)],<br>[(NA,),(9,91),(12,12),(11,89)],<br>[(NA),(7,13),(14,86),(15,85)]<br>]<br><br>load(na_test,'/tmp/na_test_missing.txt');<br><br>[<br>[(NA,100),(1,99),(2,98),(3,97)],<br>[(3.14159,NA),(5,95),(6,94),(7,93)],<br>[(NA,3.14159),(9,91),(12,12),(11,89)],<br>[(NA,3.14159),(7,13),(14,86),(15,85)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> If you apply a function to a SciDB attribute that is NA SciDB will
return NA:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">apply(na_test_missing,val3,sin(val1));<br><br>[<br>[(NA,100,NA),(1,99,0.841471),(2,98,0.909297),(3,97,0.14112)],<br>[(3.14159,NA,2.65359e-06),(5,95,-0.958924),(6,94,-0.279415),(7,93,0.656987)],<br>[(NA,3.14159,NA),(9,91,0.412118),(12,12,-0.536573),(11,89,-0.99999)],<br>[(NA,3.14159,NA),(7,13,0.656987),(14,86,0.990607),(15,85,0.650288)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> See the next section, "Null attribute format" for more information
on NULL attributes and default clauses.</p>
<h3 id="NULLattributeformat"><a name="5_1_7">NULL attribute format</a></h3>
<p> Both the dense and sparse array formats can include special codes
for NULL attributes. For example, if a faulty instrument occasionally
fails to report a reading, that attribute could be represented in a
SciDB array as NULL. If an erroneous instrument reports readings that
are out of valid bounds for an attribute, that may also be represented
as NULL.</p>
<p> NULL must be represented using the token 'null' or '?' in place of
the attribute value.</p>
<p> In addition, NULL values can be tagged with a "missing reason code"
to help a SciDB application distinguish among different types of null
values -- for example, assigning a unique code to the following types
of errors: "instrument error", "cloud cover", or "not enough data for
statistically significant result". Or, in the case of financial market
data, data may be missing because "market closed", "trading halted", or
"data feed down".</p>
<p> Missing reason codes allow an application to optionally treat each
kind of null as a special case, e.g. to supply or calculate a
context-sensitive default value.</p>
<p> The examples below show how to represent missing data in the load
file.<em> ?</em> or<em> null</em> represent null values, and<em> ?2</em>
represents null value with a reason code of<em> 2</em>.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">[[ ( 10, 4.5, "My String", 'C'), (10, 5.1, ?1, 'D'), (?2, 5.1, "Another String", ?) ...<br><br>or<br><br>[[ ( 10, 4.5, "My String", 'C'), (10, 5.1, ?1, 'D'), (?2, 5.1, "Another String", null) ...<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The <tt>substitute</tt> operator described later in this chapter
can be used to replace missing values with user-defined values looked
up from another SciDB array.</p>
<p> The default clause of the NULL flag allows you to set a custom
value for missing data:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">less /tmp/default_value.txt<br>[(1),(),(3)]<br>create array D &lt;a:int32 null default 7&gt; [x=0:2,3,0];<br>load(D,'/tmp/default_value.txt');<br>[(1),(7),(3)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can set the default value to value that is legal in the
datatype of the attribute. You can also use a function.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">remove(D);<br>create array D &lt;a: double default sin(3*3.14/2)&gt; [x=0:2,3,0];<br>load(D,'/tmp/default_value.txt);<br>[(1),(-0.999997),(3)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="Loadinganunboundedarray"><a name="5_1_8">Loading an unbounded
array</a></h3>
<p> An unbounded array is one declared to have one or more unbounded
dimensions. With an unbounded dimension there is no declared limit on
the<em> high</em> value. SciDB allows an array to be expanded along
unbounded dimensions and new chunks can be appended to an unbounded
array after the initial load beyond the current maximum size of the
dimension.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY open_array &lt;a:int64&gt;[x=0:*,5,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Load data in three phases into<em> open_array</em> described in the
create statement above.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">load(open_array, '/tmp/load_1.txt')<br>load(open_array, '/tmp/load_2.txt')<br>load(open_array, '/tmp/load_3.txt')<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The load files are shown below and described in more detail in the
sections on <tt>input</tt> and <tt>load</tt>. Initial load from
/tmp/load_1.txt</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">[(0), (1), (2), (3), (4)];[(5), (6), (7), (8), (9)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Additional loads:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">/tmp/load_2.txt<br>{10}[(15), (16), (17), (18), (19)]<br>/tmp/load_3.txt<br>{15}[(10), (11), (12), (13), (14)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="Loadinginparallel"><a name="5_1_9">Loading in parallel</a></h3>
<p> The optional<em> nodeid</em> parameter instructs the load command
to open and load data from a particular instance of SciDB. Possible<em>
nodeid</em> values are:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <th>nodeid</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>0</td>
      <td>Coordinator</td>
    </tr>
    <tr>
      <td>1..N</td>
      <td>Node id of a node in the cluster, obtained form the system
catalog table<em> node</em></td>
    </tr>
    <tr>
      <td>-1</td>
      <td>All nodes in the cluster</td>
    </tr>
  </tbody>
</table>
<p> Specifying "-1" for the nodeid causes a parallel load to all nodes
in the cluster. The file path of the load file must be the same on all
nodes in the cluster, but each node must be given distinct chunks to
load. If multiple nodes attempt to load the same chunk during the, the
load command will fail. Conversely, if any particular node cannot open
the file, the load will continue after logging a warning.</p>
<p> If your SciDB installation has 4 nodes (say, node1, node2, node3,
and node4) and the load must load 20 chunks, you can place chunks 1-5
on node1, chunks 6-10 on node2, and so on. The following load command
will simultaneously load all 20 chunks into the array in roughly 1/4th
the time compared to a coordinator load.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">load (Array, '/tmp/load.data', -1);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="LoadingthroughaUnixpipe"><a name="5_1_10">Loading through a
Unix pipe</a></h3>
<p> All the above methods of loading SciDB can also be done via a Unix
pipe (instead of load files). Pipes avoid creating and storing SciDB
load files from source files.</p>
<h3 id="csv2scidb"><a name="5_1_11">csv2scidb</a></h3>
<p> CSV is a common data exchange format. Many systems produce data in
CSV format. SciDB provides a utility called<em> csv2scidb</em> to
convert a csv file into a 1-dimensional array. This array must later be
transformed using other SciDB operators such as redimension and
redimension_store discussed later in this document.</p>
<p> Consider the csv file /tmp/observations.csv:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">String_One,15354,01-01-2005 10:11:32,31.7257<br>String_One,15354,01-01-2005 10:11:35,404.0464<br>String_One,15354,01-01-2005 10:11:38,926.4216<br>String_One,,01-01-2005 10:11:41,16.7285<br>...<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> csv2scidb can be used to re-format this file into a dense SciDB
load file ready to be loaded into the 1-dimensional array<em> Raw_Load</em>.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">iquery -anq "create array Raw_Load&lt;s: string, dt: dateTime, r: double&gt;[1:*, 134340,0]"<br>mkfifo /tmp/load_pipe<br>cat /tmp/observations.csv  | awk -F, '{print $1","$3","$4}' <br>   | csv2scidb -c 134340 -p SSN &gt; /tmp/load_pipe &amp; <br>iquery -anq "load (Raw_Load, '/tmp/load_pipe')"<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The following arguments to csv2scidb are shown here.<em> -c</em> is
used to specify the chunk size, and<em> -p</em> is used to specify a
parse format for the file (S = string, N = numerical, C = char). See<em>
csv2scidb --help</em> for more details on usage.</p>
<h2 id="input"><a name="5_2">input</a></h2>
<p><strong> Summary:</strong> Input is used to read a file from the
filesystem, interpret the contents as cells in an array and return the
result. Input has the exact same signature as load.</p>
<p><strong> Signature</strong>:</p>
<p> input (<em>array_name : array_identifier</em>,<em> data_file :
string</em> [,<em> nodeid : int</em>] )</p>
<p> Input works exactly the same way as load, except it does NOT store
the data. The store operator can be used to persist the output of the <tt>
input</tt> operator. This means that:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">store ( input (a, 'somefile' ), a) <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> is the same as</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">load ( a, 'somefile' )<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> and</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">store ( input (a, 'somefile' ), b)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="substitute"><a name="5_3">substitute</a></h2>
<p> Substitute null values in the input array, using their missing
reason code, if using the "?code" format, as index in the second
(substitution) array.</p>
<p><strong> Signature</strong>:</p>
<blockquote>
  <p> <tt>substitute</tt>(<em> array</em>,<em> mask: array</em> )</p>
</blockquote>
<p> For example, array foo contains two nulls (which is equivalent to
?0) and one ?1:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array foo &lt;val:int32 null&gt;[x=0:8,1,0];<br>load(foo,'/tmp/foo.txt');<br>scan(foo);<br><br>[(1),(2),(null),(4),(5),(null),(7),(?1)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can use substitute to replace ?0 with 20 and ?1 with 30, for
instance. We build an array where 0 maps to 20 and 1 maps to 30:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">build(&lt;val:double&gt; [x=0:1,2,0], iif( x = 0, 20, 30));<br><br>[(20),(30)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can use this build expression as part of substitute directly by
using an anonymous schema:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">substitute(foo,build(&lt;val:int32&gt; [x=0:1,2,0], iif( x = 0, 20, 30)));<br><br>[(1),(2),(20),(4),(5),(20),(7),(30)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The <tt>substitute</tt> operator does not store the new values or
create a new version of <tt>foo</tt>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">list('arrays');<br><br>[("foo"),("foo@1")]<br><br>scan(foo);<br><br>[(1),(2),(null),(4),(5),(null),(7),(?1)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Both input arguments to <tt>substitute</tt> must be
single-attribute arrays with the same attribute type.</p>
<h2 id="save"><a name="5_4">save</a></h2>
<p><strong> Summary</strong>: Unload array data to a file</p>
<p> Use the save operator to unload the data to an external file on the
file system. The format of the file is the same as the load file format
described above. If the internal chunk storage format of the array is
dense, this file is unloaded into a dense file format. And if the array
chunk storage format is sparse, the save output is in sparse file
format.</p>
<p><strong> Signature</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">save( ''array'', ''file_path : string'' )<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Array name refers to the array to be unloaded and saved. File path
is the path to a file to use -- if a relative path name is used this is
assumed to be relative to the working directory of the SciDB server.</p>
<p> In a cluster configuration, save operates as follows. For each node
in a cluster<em> save</em> creates a file with the same file name
containing only the chunks stored on that node. The entire array data
is obtained by concatenating saved files from all nodes.</p>
<hr noshade="noshade">
<h1 id="UpdatesandVersioning"><a name="6">Updates and Versioning</a></h1>
<p> SciDB uses a "no overwrite" storage model - i.e., data is never
overwritten, instead each store or update query writes a new version of
the array. Versions are stored efficiently within the storage manager
to minimize redundant storage. SciDB uses copy-on-write and delta
encoding to store only data that has changed between versions, often
resulting in efficient internal storage.</p>
<h2 id="store"><a name="6_1">store</a></h2>
<p><strong> Summary</strong>: Update a SciDB array</p>
<p> The AFL <tt>store</tt> command is a write operator, that is, one
of the AFL commands that can update an array. Each execution of <tt>store</tt>
causes a new version of the array to be created. When an array is
removed, so are all its versions.</p>
<p> store() can be used to save the resultant output array into an
existing/new array. It can also be used to duplicate an array (by using
the name of the source array in the first parameter and target_array in
the second parameter).</p>
<p><strong> Signature</strong>:</p>
<blockquote>
  <p> <tt>store</tt>(<em>input</em>,<em> array_name</em>)</p>
</blockquote>
<p> The<em> input</em> argument can be:</p>
<ol>
  <li>a previously created array, or</li>
  <li>a sub-query result</li>
</ol>
<p> The<em> array_name</em> argument can be:</p>
<ol>
  <li>name of a pre-existing array, or</li>
  <li>name of a non-existent array. In this case, the array takes the
schema of the input array or sub-query result.</li>
</ol>
<p><strong> Note</strong>: SciDB does not allow the array type (EMPTY
vs. non-EMPTY) to be altered after array creation. However, array data
can be copied from a non-EMPTY array to an EMPTY array if the array
dimensions and attributes are compatible.</p>
<p> The example below shows the contents of file /tmp/dense2.txt used
in the AFL examples below.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">{0,3}<br>[<br>[(140),  (150),  (160) ],<br>[(240),  (250),  (260) ],<br>[(340),  (350),  (360) ]<br>];<br>{3,0}<br>[<br>[ (410),  (420),  (430) ],<br>[ (510),  (520),  (530) ],<br>[ (610),  (620),  (630) ]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The input file shown above contains 2 chunks at {0,3} and {3,0}
that can be used to update a previously loaded array using:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">store(merge(input(updarr, '../tests/basic/data/dense2.txt'), updarr), updarr)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This creates a new version of the<em> updarr</em> array.</p>
<h2 id="ArrayVersions"><a name="6_2">Array Versions</a></h2>
<p> When an array is updated, a new array version is created. You can
refer to any version or dimension of an array with the following syntax:</p>
<blockquote>
  <p> <tt>array_name</tt> [@ <tt>version</tt> | <tt>datetime</tt>]
[: <tt>
dimension_name</tt>]</p>
</blockquote>
<p> For example, suppose you create an array and do two consecutive
load commands:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY A_versions &lt;x:double, y:double&gt;[i=1:10,5,0];<br>load(A_versions, '/tmp/dataset.txt')<br><br>[(1,100),(1,99),(2,98),(3,97),(4,17),<br>(5,95),(6,94),(7,93),(8,92),(9,91)]<br><br>load(A_versions, '/tmp/dataset2.txt');<br><br>[(100,100),(99,99),(98,98),(97,97),(17,17),<br>(5,95),(6,94),(7,93),(8,92),(9,91)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The two calls to <tt>load</tt> will create two versions of the
array. To see a listing of an array's versions, use the <tt>version</tt>
operator:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">versions(A_versions);<br><br>[(1,"2011-12-13 15:13:18"),<br>(2,"2011-12-13 15:13:26")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can use an operator on a prior version of an array using a
version qualifier appended to the @ symbol:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(A_versions@1);<br>[(1,100),(1,99),(2,98),(3,97),(4,17),<br>(5,95),(6,94),(7,93),(8,92),(9,91)]<br><br>scan(A_versions@2);<br>[(100,100),(99,99),(98,98),(97,97),(17,17),<br>(5,95),(6,94),(7,93),(8,92),(9,91)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Array versions can also be identified with a timestamp.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(A_versions@now());<br><br>[(100,100),(99,99),(98,98),(97,97),(17,17),<br>(5,95),(6,94),(7,93),(8,92),(9,91)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> SciDB timestamp format is "YYYY-MM-DD HH:MM:SS".</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(A_versions@datetime('2011-12-13 15:13:26'));<br><br>[(100,100),(99,99),(98,98),(97,97),(17,17),<br>(5,95),(6,94),(7,93),(8,92),(9,91)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> By default, the array name without a version identifier refers to
the latest version of the array.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(A_versions)<br><br>[(100,100),(99,99),(98,98),(97,97),(17,17),<br>(5,95),(6,94),(7,93),(8,92),(9,91)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<hr noshade="noshade">
<h1 id="BasicArrayOperations:ViewingandManipulatingYourData"><a name="7">Basic
Array
Operations:
Viewing
and
Manipulating
Your Data</a></h1>
<h2 id="apply"><a name="7_1">apply</a></h2>
<p><strong> Summary:</strong> Compute new attribute values</p>
<p> Use the apply operator to compute new values from attributes and
indexes of input arrays. The value(s) computed in the apply are
appended to the attributes in the input array.</p>
<p><strong> Signature</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">apply( array, new_attribute : attribute_identifier, expr_to_apply : expression )<br>apply( array, new_attribute1 : attribute_identifier1, expr_to_apply1 : expression1 <br>    [, new_attribute2 : attribute_identifier2, expr_to_apply2 : expression2] ...)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> For example, the query below will compute new attributes C and D,
whose values are given by the expressions A + 20 and A + 30. The
resulting array will have all the old attributes, as well as the new
attributes C and D.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">apply ( subarray ( my_array, 4, 4, 6, 6 ), C, A + 20, D, A + 30 );<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Queries with more than one apply statement can also nest them. This
is important if one apply statement uses the output of a previous apply
statement as input:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">apply ( apply ( subarray ( my_array, 4, 4, 6, 6 ), C, A + 20 ), D, C * 3);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="attribute_rename"><a name="7_2">attribute_rename</a></h2>
<p><strong> Summary</strong>: Change attribute name</p>
<p> Works similarly to cast but only changes the name of an attribute.
The new name is used in the result array, and the source array is not
changed.</p>
<p><strong> Signature</strong>:</p>
<p> attribute_rename (<em> array</em>,<em> old_name :
attribute_identifier</em>,<em> new_name : attribute_identifier</em> )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">attribute_rename(m3x3,val,foo)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="build"><a name="7_3">build</a></h2>
<p> Return a dense single-attribute array, assigning values to its
attributes using an expression. Expressions can refer to one of the
functions supported in SciDB, and to dimension values.</p>
<p><strong> Signature</strong>:</p>
<blockquote>
  <p> <tt>build</tt>(<em> array : array_identifier | anonymous_schema</em>
,<em> expression</em> )</p>
</blockquote>
<p> The build operator's first argument is:</p>
<ul>
  <li>the name of an array that is to be used as the template for the
operator's result, or</li>
  <li>an array schema ("anonymous_schema") to be used as the template
for the operator result</li>
</ul>
<p> <tt>build</tt> proceeds through the array, cell by cell, using the
value of the<em> exp : expression</em> to compute the value of each
cell. The expression can use any of the array's dimension values. On a
cluster configuration, build works in parallel on all nodes.</p>
<p><strong> Example 1</strong>: Create an identity matrix called
Build_Example_INT:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY Build_Example_INT &lt; A: int32 &gt; [ X=0:4,5,0, Y=0:4,5,0 ];<br>build (Build_Example_INT, iif(X=Y, 1, 0));<br><br>[<br>[(1),(0),(0),(0),(0)],<br>[(0),(1),(0),(0),(0)],<br>[(0),(0),(1),(0),(0)],<br>[(0),(0),(0),(1),(0)],<br>[(0),(0),(0),(0),(1)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Example 2</strong>: Build an array of monotonically
increasing values from an anonymous schema:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">build (&lt;val:int64&gt; [x=1:4,4,0,y=1:4,4,0], x*4+y-5);<br><br>[<br>[(0),(1),(2),(3)],<br>[(4),(5),(6),(7)],<br>[(8),(9),(10),(11)],<br>[(12),(13),(14),(15)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Note</strong>: The <tt>build</tt> operator does not store
data and does not change the given array; it only uses the given shape
to generate and return a result. To store the result of the build
operator you will need to use the <tt>store</tt> operator.</p>
<p><strong> Note</strong>: "The input array or anonymous schema input
to <tt>build</tt> should contain only a single attribute (although
multiple dimensions are allowed). Use the <tt>join</tt> operator with
the <tt>build</tt> operator to build multi-attribute arrays."</p>
<p><strong> Note</strong>: If an array is declared as EMPTY it cannot
be used as an input to build() operator. EMPTY arrays implicitly
include an attribute named "empty_indicator" and so are multi-attribute.</p>
<h2 id="build_sparse"><a name="7_4">build_sparse</a></h2>
<p> <tt>build_sparse</tt> works similarly to <tt>build</tt> but
returns an EMPTY type array and accepts a second expression that must
be boolean.</p>
<p><strong> Signature</strong>:</p>
<p> build_sparse(<em> array : array_identifier | anonymous_schema</em>,<em>
exp : expression</em>,<em> bexp : expression</em> )</p>
<p> The <tt>build_sparse</tt> operator's first argument is:</p>
<ul>
  <li>the name of an array that is to be used as the template for the
operator's result, or</li>
  <li>an array schema ("anonymous_schema") to be used as the template
for the operator result.</li>
</ul>
<p> The output of build_sparse contains empty cells wherever<em> bexp</em>
evaluates to false. Both expressions can access any of the array
coordinates.</p>
<p><strong> Example</strong>: Build a diagonal matrix called <tt>
sparse_diagonal</tt>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY sparse_diagonal &lt;a1: double&gt; [x=0:2,3,0, y=0:2,3,0]<br>build_sparse(sparse_diagonal, 1.0*x+100.0*y, x=y)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Build the same matrix template with an anonymous schema:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">build_sparse(&lt;a1: double&gt; [x=0:2,3,0, y=0:2,3,0], 1.0*x+100.0*y, x=y)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="cast"><a name="7_5">cast</a></h2>
<p><strong> Summary</strong>: Change the attribute or dimension names</p>
<p> The <tt>cast</tt> operator allows renaming an array or any of its
attributes and dimensions. A single cast invocation can be used to
rename multiple items at once -- one or more attribute names and/or one
or more dimension names. The input array and template arrays should
have the same numbers and types of attributes and the same numbers and
types of dimensions.</p>
<p> Note that the template-array need not have actual data and is only
used as a template from which attribute names and dimension names are
used. Note that the input array is not modified, rather, a new array is
created as a result of the cast operator. To store this newly created
array use the store operator.</p>
<p><strong> Signature</strong>:</p>
<p> cast (<em> array</em>,<em> template : array_identifier |
anonymous_schema</em> )</p>
<p> The <tt>cast</tt> operator's second argument is:</p>
<ul>
  <li>the name of an array and its schema to be used as the template
for the operator's result, or</li>
  <li>an array schema ("anonymous_schema") to be used as the template
for the operator result</li>
</ul>
<p><strong> Example 1</strong>:</p>
<ol>
  <li>Create an array called source with a attribute called val:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">create array source &lt;val:double&gt; [x=0:5,3,0];<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Use an anonymous schema to change the attribute name to value,and
the dimension name to i. Store the result in an array called target:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">store(cast(source, &lt;value:int64&gt;[i=0:5,3,0]),target);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p> <tt>target</tt> has the new names while <tt>source</tt> maintains
the old:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">show(target);<br><br>[("target&lt;value:double NOT NULL&gt; [i=0:5,3,0]")]<br><br>show(source);<br><br>[("source&lt;val:double NOT NULL&gt; [x=0:5,3,0]")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Example 2</strong>: One important application of <tt>cast</tt>
is the resolution of naming conflicts:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">store(build (&lt;a:int64&gt; [x=0:10,1,0], x), vector);<br><br>[(0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10)]<br><br>store(build (&lt;a:int64&gt; [x=0:10,1,0], -x), vector2);<br><br>[(0),(-1),(-2),(-3),(-4),(-5),(-6),(-7),(-8),(-9),(-10)]<br><br>apply(join(vector,vector2), b, a+a);<br>-- ERROR: a is ambiguous<br><br>apply(join(vector, cast (vector2, &lt;b:int64&gt;[x=0:10,1,0])), c, a+b);<br><br>[(0,0,0),(1,-1,0),(2,-2,0),(3,-3,0),(4,-4,0),(5,-5,0),(6,-6,0),(7,-7,0),(8,-8,0),(9,-9,0),(10,-10,0)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="project"><a name="7_6">project</a></h2>
<p><strong> Summary:</strong> Select array attributes</p>
<p> Project the input array on the specified attributes, in the
specified order. Attributes that are not specified are excluded from
the output.</p>
<p><strong> Signature</strong>:</p>
<p> project (<em> array</em>,<em> attribute1 : attribute_identifier</em>
[,<em> attribute-2 : attribute_identifier</em> ...] )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> project( subarray ( my_array, 4, 4, 6, 6 ), A);<br><br>(44)  (45)  (46)<br>(54)  (55)  (56)<br>(64)  (65)  (66)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> project( apply ( subarray ( my_array, 4, 4, 6, 6 ), C, A + 20 ), C);<br>(64.0)  (65.0)  (66.0)<br>(74.0)  (75.0)  (76.0)<br>(84.0)  (85.0)  (86.0)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="rename"><a name="7_7">rename</a></h2>
<p><strong> Summary</strong>: Rename an array</p>
<p> Signature:</p>
<p> rename( old_name : array_identifier, new_name : array_identifier )</p>
<p> The first argument is the name of the array to be renamed, and the
second argument is the new array name.</p>
<p> Example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">store ( build (&lt; A: int32 &gt; [ X=0:4,5,0, Y=0:4,5,0 ], iif(X=Y,1,0)), rename_example);<br>list ('arrays');<br>rename (rename_example, new_name);<br>project (new_name, A);<br><br>[[(1),(0),(0),(0),(0)],<br>[(0),(1),(0),(0),(0)],<br>[(0),(0),(1),(0),(0)],<br>[(0),(0),(0),(1),(0)],<br>[(0),(0),(0),(0),(1)]]<br><br><br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Notes</strong>:</p>
<ol>
  <li>Once a rename is done, the old array name can be re-used. Any
mapping arrays are also renamed.</li>
  <li>The <tt>rename</tt> operator should not be used concurrently
with another query on the same array. Perform the rename first, then
execute other queries on a renamed array.</li>
</ol>
<h2 id="scan"><a name="7_8">scan</a></h2>
<p><strong> Summary:</strong> Print attribute values</p>
<p> Scan returns the contents of the array whose name is passed in as
an argument.</p>
<p><strong> Signature</strong>:</p>
<p> scan(<em>array_identifier</em> )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(my_array);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The 'scan' operator expects an array identifier as its first
argument, and returns an array as a result of operation. This operator
is used to get a complete listing of the contents of an array stored in
the SciDB database. To see a particular version of an array, append the
version number to the array name:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(my_array@1);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<hr noshade="noshade">
<h1 id="DataSamplingOperators"><a name="8">Data Sampling Operators</a></h1>
<h2 id="bernoulli"><a name="8_1">bernoulli</a></h2>
<p><strong> Summary:</strong> Select cells at random</p>
<p> The bernoulli operator evaluates each cell by generating a random
number and seeing if it lies in the range (0, probability). If it does,
the cell is included.</p>
<p><strong> Signature</strong></p>
<blockquote>
  <p> <tt>bernoulli</tt>(<em>array</em> |<em> array_operator</em>,<em>
probability:double</em> [,<em> seed:int64</em> ] )</p>
</blockquote>
<p> The first parameter can be an array name or an array operator
(operator which outputs an array as result).</p>
<p> The sampling probability is the probability of inclusion. To repeat
results, use a seed value for the underlying random number generator.</p>
<h2 id="between"><a name="8_2">between</a></h2>
<p><strong> Summary</strong>: Select a subset of data within a
specified region</p>
<p> The between operator accepts an input array and a set of
coordinates specifying a region within the array. The output is an
array of the same shape as input, where all cells outside of the given
region are marked empty.</p>
<p><strong> Signature</strong>:</p>
<blockquote>
  <p> <tt>between</tt>(<em> array</em>,<em> low-boundary-coordinate-1:
value</em>, ...,<em> low-boundary-coordinate-N: value</em>,<em>
high-boundary-coordinate-1: value</em>, ...,<em>
high-boundary-coordinate-N: value</em> )</p>
</blockquote>
<p> Note that between is very similar to subarray, except that between
does not change the shape of the array, and does not change the
starting coordinates.</p>
<p> For example, consider the following array of integers:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">less /tmp/fbf.txt<br>[<br>[(0),(1),(4),(5)],<br>[(2),(3),(6),(7)],<br>[(8),(9),(12),(13)],<br>[(10),(11),(14),(15)]<br>]<br>create array fbf &lt;val1:int64&gt;[x=0:3,4,0, y=0:3,4,0];<br>load(fbf, '/tmp/fbf.txt');<br><br>[<br>[(0),(1),(4),(5)],<br>[(2),(3),(6),(7)],<br>[(8),(9),(12),(13)],<br>[(10),(11),(14),(15)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Between can be used to set all cells outside of the (1,1)-&gt;(2,2)
region to empty:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">between(fbf,1,1,2,2);<br><br>[<br>[(),(),(),()],<br>[(),(3),(6),()],<br>[(),(9),(12),()],<br>[(),(),(),()]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="filter"><a name="8_3">filter</a></h2>
<p><strong> Summary</strong>: Select subset of data by boolean
expression</p>
<p> The filter operator 'filters' out data in the array based on an
expression over the attribute and dimension values. Suppose we want to
filter out all the data from my_array, where the value of attribute A
doesn't equal 75. We would use the following query:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">filter( my_array, A &lt;&gt; 75);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The filter operator marks all cells in the input which do not
satisfy the predicate expression to 'empty'.</p>
<p><strong> Signature</strong>:</p>
<p> filter (<em> array</em>,<em> condition : expression</em> )</p>
<p> where 'condition' is a boolean expression.</p>
<p> The following examples illustrate both the functionality of the
filter operator, and also how operators in AFL can be combined into
query expressions.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">filter ( subarray ( my_array, 4, 4, 6, 6), A &gt; 46 );<br><br>(0,0.0,false)   (0,0.0,false)  (0,0.0,false)<br>(54,54.0,true)  (55,55.0,true)  (56,56.0,true)<br>(64,64.0,true)  (65,65.0,true)  (66,66.0,true)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">filter ( subarray ( my_array, 4, 4, 6, 6), A &gt; 46 and A &lt; 56);<br><br>(0,0.0,false)   (0,0.0,false)   (0,0.0,false)<br>(54,54.0,true)  (55,55.0,true)  (56,56.0,true)<br>(0,0.0,false)   (0,0.0,false)  (0,0.0,false)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The output of the filter is an array with the EMPTY attribute.</p>
<h2 id="lookup"><a name="8_4">lookup</a></h2>
<p><strong> Summary</strong>: Pattern selection</p>
<p> Lookup maps elements from the second array using the attributes of
the first array as coordinates into the second array. The result array
has the same shape as first array and the same attributes as second
array.</p>
<p><strong> Signature</strong>:</p>
<p> lookup (<em> pattern : array</em>,<em> source: array</em> )</p>
<p><strong> Example</strong>: suppose the array foo has coordinates 0
to 7 and the values 1 to 8:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(foo);<br><br>[(1),(2),(3),(4),(5),(6),(7),(8)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Suppose the array bar ranges from -10 to 10 and has values from 40
to 60:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(bar);<br><br>[(40),(41),(42),(43),(44),(45),(46),(47),(48),(49),<br> (50),(51),(52),(53),(54),(55),(56),(57),(58),(59),(60)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Then lookup(foo,bar) returns 8 values, corresponding to bar
positions from 1 to 8 :</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">lookup(foo,bar);<br><br>[(51),(52),(53),(54),(55),(56),(57),(58)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="sample"><a name="8_5">sample</a></h2>
<p><strong> Summary:</strong> Select random chunk</p>
<p> In sample, the selection is chunk-based. We evaluate each chunk for
inclusion based on the probability.</p>
<p> Users often want samples with repeatable results. To achieve this,
SciDB uses a<em> seed</em> value for the underlying random number
generator.</p>
<p><strong> Signature</strong>:</p>
<p> sample(<em> array</em>,<em> probability : double</em> [,<em> seed :
int64</em> ] )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">bernoulli(m4x4,0.3);<br><br>[<br>[(0),(1),(0),(3)],<br>[(0),(0),(0),(0)],<br>[(8),(0),(0),(0)],<br>[(12),(13),(0),(0)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<hr noshade="noshade">
<h1 id="SortingWindowingandAggregating:GroupingYourData"><a name="9">Sorting,
Windowing,
and
Aggregating:
Grouping
Your
Data</a></h1>
<h2 id="aggregate"><a name="9_1">aggregate</a></h2>
<p><strong> Summary</strong>: Group elements and find statistical
properties of the group</p>
<p> The aggregate operator takes an array as input, groups the array by
the specified dimension and computes a given statistic for each group.
The statistics available are:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <th> Name</th>
      <th> Operation Performed</th>
    </tr>
    <tr>
      <td> avg</td>
      <td> Average value</td>
    </tr>
    <tr>
      <td> count</td>
      <td> Number of nonempty elements</td>
    </tr>
    <tr>
      <td> max</td>
      <td> Largest value</td>
    </tr>
    <tr>
      <td> min</td>
      <td> Smallest value</td>
    </tr>
    <tr>
      <td> sum</td>
      <td> Sum of all elements</td>
    </tr>
    <tr>
      <td> stdev</td>
      <td> Standard deviation</td>
    </tr>
    <tr>
      <td> var</td>
      <td style="text-align: left;">Variance</td>
    </tr>
  </tbody>
</table>
<p> The aggregate operator returns a scalar value for each statistic.</p>
<p><strong> Signature</strong>:
<br>
<tt>aggregate</tt>(<em>array, aggregate_name_1(attribute)</em>
<br>
[,<em> aggregate_name_2(attribute)</em>,...<em>
aggregate_name_N(attribute)</em>]
<br>
[,<em> dimension_1,</em><em> dimension_2,</em>...<em> dimension_M</em>
])</p>
<p><strong> Example</strong>:</p>
<ol>
  <li>Create a 3-by-3 array called m3x3:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">store ( build ( &lt;val:double&gt; [x=0:2,3,0,y=0:2,3,0], x*3+y), m3x3);<br><br>[<br>[(0),(1),(2)],<br>[(3),(4),(5)],<br>[(6),(7),(8)]<br>]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Find the sums of each column:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">aggregate(m3x3,sum(val),y);<br><br>[(9),(12),(15)]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Find the average value, number of nonempty elements, largest
element, smallest element, sum of all elements, variance, and standard
deviation:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">aggregate(m3x3,avg(val),count(val),max(val),min(val),sum(val),var(val),stdev(val));<br><br>[(4,9,8,0,36,7.5,2.73861)]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p> You can also use the built-in aggregate operations avg, count, max,
min, sum, var, and stdev.</p>
<h3 id="avg"><a name="9_1_1">avg</a></h3>
<p><strong> Summary</strong>: Arithmetic mean</p>
<p> Calculate the average value of the specified attribute in the
array. The result is an array with single element containing average
value. If the input array contains only one attribute, then attribute
name can be omitted.</p>
<p><strong> Signature</strong>:</p>
<p> avg(<em> array</em> [ ,<em> attribute-name : attribute_identifier</em>
[,<em> dimension1 : dimension_identifier</em> [,<em> dimension2 :
dimension_identifier</em> ]]] )</p>
<p> The first argument is the array to be aggregated over. The second
argument is the name of the attribute to use. Additional dimension
arguments are optional. If present, the list of dimensions specified in
the avg operator is used to perform a group-by average. The result is
organized as an array with the remaining dimensions from the source
array, after grouping has been performed based on the group-by
dimensions.</p>
<p><strong> Example</strong>: The following command returns the average
value of a over all elements of array.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">avg(m3x3, val);<br><br>[(4)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This example calculates the average value of an attribute after
grouping over all values of the dimension x. The second example below
results in a one-dimensional array whose dimension is the remaining
dimension y from the input.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">avg(m3x3, val, y);<br><br>[(3),(4),(5)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="count"><a name="9_1_2">count</a></h3>
<p><strong> Summary</strong>: Cell count</p>
<p> Counts non-empty cells of the input array. When dimensions are
provided they are used to do a group-by and a count per resulting group
is returned.</p>
<p><strong> Signature</strong>:</p>
<p> count(<em> array</em> [,<em> dimension1 : dimension_identifier</em>
[,<em> dimension2 : dimension_identifier</em>]] )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">count(m3x3);<br><br>[(9)]<br><br>count(m3x3,x);<br><br>[(3),(3),(3)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Note that cells of value 0 or null are not considered empty:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array A &lt;a:int32 null&gt; [x=0:0,1,0];<br>count(A);<br><br>[(0)]<br><br>store(build(A,x),A);<br>count(A);<br><br>[(1)]<br><br>store(build(A,null),A);<br>count(A);<br><br>[(1)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This is different than the behavior of the aggregate operator with
the count option. count(array_name) is a shorthand for
aggregate(array_name, count(*)). For example:</p>
<ol>
  <li>Create an array with a single attribute and three cells:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">create empty array A &lt;a:int32 null default 0&gt; [x=1:3,3,0];<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Put "1" in cell 1, "null" in cell 2, and make cell 3 empty:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">store(build_sparse(A, iif(x=1,1,null), x&lt;&gt;3),A);<br><br>[{1}(1),{2}(null)]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Return the count of nonempty cells:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">aggregate(A, count(*));<br><br>[(2)]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Return the number of values where attribute is not null:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">aggregate(A, count(a));<br><br>[(1)]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<h3 id="max"><a name="9_1_3">max</a></h3>
<p><strong> Summary:</strong> Maximum value</p>
<p> Calculate maximum of the specified attribute in the array. Result
is an array with single element containing maximum of specified
attribute.</p>
<p> If input array contains only one attribute, then attribute name can
be omitted. Again, if dimensions are provided, they are used to produce
groups and the maximum of each group is returned.</p>
<p><strong> Signature</strong>:</p>
<p> max(<em> array</em> [ ,<em> attribute-name : attribute_identifier</em>
[,<em> dimension1 : dimension_identifier</em> [,<em> dimension2 :
dimension_identifier</em> ]]] )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">max(m3x3);<br><br>[(8)]<br><br>max(m3x3,val,x);<br><br>[(2),(5),(8)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="min"><a name="9_1_4">min</a></h3>
<p><strong> Summary</strong>: Minimum value</p>
<p> Calculates the minimum value of the specified attribute in the
array. Result is an array with single element containing minimum of
specified attribute. If input array contains only one attribute, then
attribute name can be omitted. If an attribute list is specified, the
result is an array with the remaining dimensions from the source array,
and the minimum is evaluated over groups, where each group is the set
of all elements matching the group by dimension(s).</p>
<p><strong> Signature</strong>:</p>
<p> min(<em> array</em> [ ,<em> attribute-name : attribute_identifier</em>
[,<em> dimension1 : dimension_identifier</em> [,<em> dimension2 :
dimension_identifier</em> ]]] )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">min(m3x3);<br><br>[(0)]<br><br>min(m3x3,val,y);<br><br>[(0),(1),(2)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="sum"><a name="9_1_5">sum</a></h3>
<p><strong> Summary</strong>: Sum attribute values</p>
<p> Calculate sum of the specified attribute in the array. Result is an
array with single element containing sum of specified attribute. If
input array contains only one attribute, then attribute name can be
omitted. Again, similar group by semantics as with the other
aggregates, if a dimension list is present.</p>
<p><strong> Signature</strong>:</p>
<p> sum(<em> array</em> [ ,<em> attribute-name : attribute_identifier</em>
[,<em> dimension1 : dimension_identifier</em> [,<em> dimension2 :
dimension_identifier</em> ]]] )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sum(m3x3);<br><br>[(36)]<br><br>sum(m3x3,val,x);<br><br>[(3),(12),(21)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="var"><a name="9_1_6">var</a></h3>
<p><strong> Summary</strong>: Variance of attribute values</p>
<p> Calculate the variance of the specified attribute in the array.
Result is an array with single element containing the variance of
specified attribute. If input array contains only one attribute, then
attribute name can be omitted. Again, similar group by semantics as
with the other aggregates is supported, if a dimension list is present.</p>
<p><strong> Signature</strong>:</p>
<p> var(<em> array</em> [ ,<em> attribute-name : attribute_identifier</em>
[,<em> dimension1 : dimension_identifier</em> [,<em> dimension2 :
dimension_identifier</em> ]]] )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">var(m3x3);<br><br>[(7.5)]<br><br>var(m3x3,val,x);<br><br>[(1),(1),(1)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Variance accepts numeric attributes only. The result is the sample
variance of the attribute values.</p>
<h3 id="stdev"><a name="9_1_7">stdev</a></h3>
<p><strong> Summary</strong>: Standard deviation of attribute values</p>
<p> Calculate the standard deviation of the specified attribute in the
array. Result is an array with single element containing the standard
deviation of specified attribute. If input array contains only one
attribute, then attribute name can be omitted. Again, similar group by
semantics as with the other aggregates is supported, if a dimension
list is present.</p>
<p><strong> Signature</strong>:</p>
<p> stdev(<em> array</em> [ ,<em> attribute-name : attribute_identifier</em>
[,<em> dimension1 : dimension_identifier</em> [,<em> dimension2 :
dimension_identifier</em> ]]] )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">stdev(m3x3);<br><br>[(2.73861)]<br><br>stdev(m3x3,val,y);<br><br>[(3),(3),(3)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Standard deviation accepts numeric attributes only. The result is
the population standard deviation of the attribute values.</p>
<h2 id="regrid"><a name="9_2">regrid</a></h2>
<p><strong> Summary</strong>: Compute aggregates for a sub-grid</p>
<p> Partition (divide) the cells in the input array into blocks, and
for each block, apply a specific aggregate operation over the value(s)
of some attribute in each block.</p>
<p> <tt>regrid</tt> does not allow grids to span array chunks and
requires the chunk size to be a multiple of the grid size in each
dimension.</p>
<p><strong> Signature</strong>:</p>
<p> regrid ( array, grid_1, grid_2,.. grid_N, aggregate_call_1 [,
aggregate_call_2,...aggregate_call_N] )</p>
<p> The first input to the regrid operator can be:</p>
<ol>
  <li>An array.</li>
  <li>An array operator, that is, an operator that outputs a SciDB
array.</li>
</ol>
<p> The number of grids to be input should be equal to the number of
dimensions of the array.</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">store ( build ( &lt;val:double&gt; [x=0:3,4,0,y=0:3,4,0], x*4+y), m4x4);<br><br>[<br>[(0),(1),(2),(3)],<br>[(4),(5),(6),(7)],<br>[(8),(9),(10),(11)],<br>[(12),(13),(14),(15)]<br>]<br><br>regrid(m4x4, 2,2, sum(val));<br><br>[[(10),(18)],[(42),(50)]]<br><br>regrid(m4x4, 2,2, sum(val),max(val));<br><br>[[(10,5),(18,7)],[(42,13),(50,15)]]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="sort"><a name="9_3">sort</a></h2>
<p><strong> Summary</strong>: Sort by attribute value</p>
<p> Sort a one-dimensional array by one or more attributes. The sort
attributes are specified using a 1-based attribute number.</p>
<p><strong> Signature</strong>:</p>
<p> sort ( array, attribute_name [ desc] [, .....] )</p>
<p> The first argument can be:</p>
<ol>
  <li>An array</li>
  <li>An array operator, that is, an operator that outputs a SciDB
array.</li>
</ol>
<p> The attribute name can optionally be followed by <tt>desc</tt> to
sort in descending order. Default is ascending order.</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">less /tmp/sd.txt<br>[(1,"a"),(2,"z"),(0,"b"),(3,"x"),(2,"f"),(6,"o"),(1.5,"e"),(2.7,"l")]<br><br>create array sd &lt;num:double,label:string&gt;[x=0:8,8,0];<br>load(sd,'/tmp/sd.txt');<br><br>[(1,"a"),(2,"z"),(0,"b"),(3,"x"),(2,"f"),(6,"o"),(1.5,"e"),(2.7,"l")]<br><br>sort(sd,num);<br><br>[(0,"b"),(1,"a"),(1.5,"e"),(2,"z"),(2,"f"),(2.7,"l"),(3,"x"),(6,"o")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> To sort in descending order, use the desc argument:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sort(sd,num desc);<br><br>[(6,"o"),(3,"x"),(2.7,"l"),(2,"z"),(2,"f"),(1.5,"e"),(1,"a"),(0,"b")]<br><br>sort(sd,label desc);<br><br>[(2,"z"),(3,"x"),(6,"o"),(2.7,"l"),(2,"f"),(1.5,"e"),(0,"b"),(1,"a")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="window"><a name="9_4">window</a></h2>
<p><strong> Summary</strong>: Compute aggregates over a window</p>
<p> Compute one or more aggregates of any of an array's attributes over
a moving window.</p>
<p><strong> Signature</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">window(array, grid1, grid2,.. gridN, aggregate_call1 [, aggregate_call2,...aggregate_callN])<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Each <tt>aggregate_call</tt> argument consists of a call to an
aggregate and an optional alias. For example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sum(val) as output<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> will sum the attribute called <tt>val</tt> and place it in <tt>
output</tt>.</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array m4x4 &lt;val1:double,val2:int32&gt; [x=0:3,4,0,y=0:3,4,0];<br>load(m4x4, '/tmp/m4x4_2attr');<br>[<br>[(0,100),(1,99),(2,98),(3,97)],<br>[(4,96),(5,95),(6,94),(7,93)],<br>[(8,92),(9,91),(10,90),(11,89)],<br>[(12,88),(13,87),(14,86),(15,85)]<br>]<br>window(m4x4,2,2, max(val1),sum(val2));<br>[<br>[(0,100),(1,199),(2,197),(3,195)],<br>[(4,196),(5,390),(6,386),(7,382)],<br>[(8,188),(9,374),(10,370),(11,366)],<br>[(12,180),(13,358),(14,354),(15,350)]]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The resulting schema for the output of <tt>window</tt> is:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> &lt;val1_sum:double NULL, val2_max:int32 NULL&gt;[x=0:3,4,0, y=0:3,4,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You can also use an alias with the aggregate call:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">window(m4x4,2,2, max(val1) as z, sum(val2) as w);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The window is defined by a size in each dimension, for example, the
window in the above example is 3-by-3.</p>
<p> The starting position of the window centroid is the first element
of the array. At the edges of the array the window aggregate only
contains elements that are included in the array. The centroid of the
window moves in stride-major order from lowest to highest value in each
dimension. The output array has the same shape (no overlap) as the
input array. Each element of the output array contains the aggregates
computed over the corresponding window location over the input array.</p>
<p> SciDB uses array overlap to perform the window operation on each
chunk locally. If necessary a repart operator is implicitly included in
the execution plan.</p>
<hr noshade="noshade">
<h1 id="CombiningArrays:PuttingthePiecesofYourDatabaseTogether"><a
 name="10">Combining Arrays: Putting the Pieces of Your Database
Together</a></h1>
<h2 id="concat"><a name="10_1">concat</a></h2>
<p><strong> Summary</strong>: Concatenate two arrays</p>
<p> Array should have the name number of dimensions. Concatenation is
performed by the left-most dimension. All other dimensions of the input
arrays must match. The left-most dimension of both arrays must have a
fixed size (not unbounded) and same chunking schema. Both inputs must
have the same attributes.</p>
<p> The inputs to concat can be:</p>
<ol>
  <li>An existing array.</li>
  <li>An array operator, that is, an operator that outputs a SciDB
array.</li>
</ol>
<p><strong> Signature</strong>:</p>
<blockquote>
  <p> <tt>concat</tt>(<em> left: array</em>,<em> right : array</em> )</p>
</blockquote>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">store(build(&lt;val:int64&gt;[x=0:3,100,0,y=0:4,100,0],x*5+y),four_by_five);<br><br>[<br>[(0),(1),(2),(3),(4)],<br>[(5),(6),(7),(8),(9)],<br>[(10),(11),(12),(13),(14)],<br>[(15),(16),(17),(18),(19)]<br>]<br><br>store(build(&lt;val:int64&gt;[x=0:1,100,0,y=0:4,100,0],20+x*2+y),two_by_five);<br>[<br>[(20),(21),(22),(23),(24)],<br>[(22),(23),(24),(25),(26)]<br>]<br><br>concat(four_by_five,two_by_five);<br><br>[<br>[(0),(1),(2),(3),(4)],<br>[(5),(6),(7),(8),(9)],<br>[(10),(11),(12),(13),(14)],<br>[(15),(16),(17),(18),(19)],<br>[(20),(21),(22),(23),(24)],<br>[(22),(23),(24),(25),(26)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Note that concat can be combined with transpose, adddim, deldim,
subarray, slice and other ops for more complex transformations.</p>
<h2 id="cross"><a name="10_2">cross</a></h2>
<p><strong> Summary</strong>: Cross-product join</p>
<p> The inputs to cross can be:</p>
<ol>
  <li>An existing array.</li>
  <li>An array operator, that is, an operator that outputs a SciDB
array.</li>
</ol>
<p> Calculates the full cross product join of two arrays, say A
(m-dimensional array) and B (n-dimensional array) such that the result
is an m+n dimensional array in which each cell is computed as the
concatenation of the attribute lists from corresponding cells in arrays
A and B. For example, consider a 2-dimensional array A with dimensions
i, j, and a 1-dimensional array B with dimension k. The cell at
coordinate position {i, j, k} of the output is computed as the
concatenation of cells {i, j} of A with cell at coordinate {k} of B.</p>
<p><strong> Signature</strong>:</p>
<p> cross(<em> left : array</em>,<em> right : array</em> )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array a&lt;a1: double&gt;[i=1:3,3,0, j=1:3,3,0];<br>create array b&lt;b1: double&gt;[k=1:2,2,0];<br><br>store(build(a, i+j), a);<br><br>[[(2),(3),(4)],<br>[(3),(4),(5)],<br>[(4),(5),(6)]]<br><br>store(build(b, 1.0/k), b);<br><br>[(1),(0.5)]<br><br>cross(a, b);<br><br>[[<br>[(2,1),(2,0.5)],<br>[(3,1),(3,0.5)],<br>[(4,1),(4,0.5)]<br>],<br>[<br>[(3,1),(3,0.5)],<br>[(4,1),(4,0.5)],<br>[(5,1),(5,0.5)]<br>],<br>[<br>[(4,1),(4,0.5)],<br>[(5,1),(5,0.5)],<br>[(6,1),(6,0.5)]<br>]]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The output is a 3-dimensional array with the following schema:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">&lt;a1:double NOT NULL, b1:double NOT NULL&gt;[i=1:3,3,0, j=1:3,3,0, k=1:2,2,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="cross_join"><a name="10_3">cross_join</a></h2>
<p><strong> Summary</strong>: Cross-product join with equality
predicates</p>
<p> Calculates the cross product join of two arrays, say A
(m-dimensional array) and B (n-dimensional array) with equality
predicates applied to pairs of dimensions, one from each input.
Predicates can only be computed along dimension pairs that are aligned
in their type, size, and chunking.</p>
<p> Assume p such predicates in the cross_join, then the result is an
m+n-p dimensional array in which each cell is computed by concatenating
the attributes as follows:</p>
<p> For a 2-dimensional array A with dimensions i, j, and a
1-dimensional array B with dimension k, cross_join(A, B, j, k) results
in a 2-dimensional array with coordinates {i, j} in which the cell at
coordinate position {i, j} of the output is computed as the
concatenation of cells {i, j} of A with cell at coordinate {k=j} of B.</p>
<p><strong> Signature</strong>:</p>
<p> cross_join(<em> left : array</em>,<em> right : array</em>,<em>
left_dim_1: dimension_identifier</em>,<em> right_dim_1 :
dimension_identifier</em> [,<em> left_dim_2: dimension_identifier</em>,<em>
right_dim_2: dimension_identifier</em>,... ] )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array a&lt;a1: double&gt;[i=1:3,3,0, j=1:3,3,0];<br>create array b&lt;b1: double&gt;[k=1:3,3,0];<br><br>store(build(a, i+j), a);<br><br>[[(2),(3),(4)],<br>[(3),(4),(5)],<br>[(4),(5),(6)]]<br><br>store(build(b, 1.0/k), b);<br><br>[(1),(0.5), (0.333)]<br><br>cross_join(a, b, j, k);<br><br>[<br>[(2,1),(3,0.5),(4,0.333333)],<br>[(3,1),(4,0.5),(5,0.333333)],<br>[(4,1),(5,0.5),(6,0.333333)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The result has schema:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">&lt;a:double NOT NULL, b:double NOT NULL&gt;[i=1:3,3,0, j=1:3,3,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="join"><a name="10_4">join</a></h2>
<p><strong> Summary</strong>: Join two arrays</p>
<p> Join combines the attributes of two input arrays at matching
dimension values.</p>
<p><strong> Signature</strong>:</p>
<p> join (<em> left : array</em>,<em> right : array</em> )</p>
<p> The following example illustrates a join between two different
subarray operators applied to the same underlying array. Note that join
combines attributes from cells at dimension addresses on its immediate
input arrays; not in the original inputs:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> subarray ( my_array AS M1, 4, 4, 6, 6 );<br><br>(44,44.0)  (45,45.0)  (46,46.0)<br>(54,54.0)  (55,55.0)  (56,56.0)<br>(64,64.0)  (65,65.0)  (66,66.0)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> subarray ( my_array AS M2, 6, 6, 8, 8 );<br><br>(66,66.0)  (67,67.0)  (68,68.0)<br>(76,76.0)  (77,77.0)  (78,78.0)<br>(86,86.0)  (87,87.0)  (88,88.0)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">join ( subarray ( my_array AS M1, 4, 4, 6, 6 ), <br>  subarray ( my_array AS M2, 6, 6, 8, 8 ) );<br><br>(44,44.0,66,66.0)  (45,45.0,67,67.0)  (46,46.0,68,68.0)<br>(54,54.0,76,76.0)  (55,55.0,77,77.0)  (56,56.0,78,78.0)<br>64,64.0,86,86.0)  (65,65.0,87,87.0)  (66,66.0,88,88.0)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The join result has the same dimension names as the first input.
The left and right arrays must have the same shape. If a cell in either
the left or right array is empty, the corresponding cell in the result
is also empty.</p>
<h2 id="merge"><a name="10_5">merge</a></h2>
<p><strong> Summary</strong>: Merge two arrays.</p>
<p> The inputs to merge can be:</p>
<ol>
  <li>An existing array.</li>
  <li>An array operator, that is, an operator that outputs a SciDB
array.</li>
</ol>
<p> The two input arrays should have the same shape as one another:
that is, the same attribute list and dimensions.</p>
<p> Merge combines elements from the input array the following way: for
each cell in the two inputs, if the cell of first (left) array is<em>
non-empty</em>, then the attributes from that cell are selected and
placed in the output. If the cell in the first array is marked as<em>
empty</em>, then the attributes of the corresponding cell in the second
array are taken. If the cell is<em> empty</em> in both input arrays,
the output's cell is set to<em> empty</em>.</p>
<p><strong> Signature</strong>:</p>
<p> merge(<em> left : array</em>,<em> right : array</em> )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(vec1);<br><br>[[(1,true)],[()],[(3,true)],[()],[(5,true)]]<br><br>scan(vec2);<br><br>[[()],[(5,true)],[()],[(7,true)],[()]]<br><br>merge(vec1,vec2);<br><br>[[(1,true)],[(5,true)],[(3,true)],[(7,true)],[(5,true)]]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<hr noshade="noshade">
<h1 id="ArraySchemas:ChangetheShapeandSizeofYourArrays"><a name="11">Array
Schemas:
Change
the
Shape
and
Size of Your Arrays</a></h1>
<p> In the case of some shape-changing operators that require a fully
qualified array schema, SciDB supports two ways to specify an array
schema.</p>
<ul>
  <li>You can create a new array with the desired output schema and
refer to it for the changed shape:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">show(src);<br>[("a1&lt;a:double NOT NULL&gt; [i=1:3,3,0,j=1:3,3,0]")]<br>reshape(src, foo)<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>You can specify a schema without a creating a named array. This
is called an<em> anonymous schema</em>:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">reshape(src, &lt;a: double&gt;[k=1:9,9,0]);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ul>
<h2 id="adddimanddeldim"><a name="11_1">adddim and deldim</a></h2>
<p><strong> Summary</strong>: Adding and deleting dimensions of an array</p>
<p> Change the structure of an array by adding or deleting a dimension.</p>
<p> The adddim operator prepends the existing dimensions for an array
with a new dimension, whose name is supplied as the second argument to
the operator.</p>
<p> The new dimension will have start = 0, length = 1, chunkSize = 1,
overlap = 0.</p>
<p> The <tt>deldim</tt> operator deletes the left-most dimension from
the array. Deleted dimension must have size = 1.</p>
<p><strong> Signature</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">adddim( array, new_dimension : dimension_name )<br>deldim( array )<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Examples</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">adddim(matrix, timestamp);<br>deldim(subarray(matrix, 1, 100, 1, 200));<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="redimensionandredimension_store"><a name="11_2">redimension and
redimension_store</a></h2>
<p><strong> Summary</strong>: Transform attributes to dimensions</p>
<p> The <tt>redimension</tt> and <tt>redimension_store</tt> operators
convert array attributes to dimensions. You can redimension the array
and apply aggregates to duplicate cells.</p>
<p><strong> Signature</strong>:</p>
<p> redimension(<em> array</em>,<em> target : array_identfier</em> )
<br>
redimension_store(<em> array</em>,<em> target : array_identfier</em> )
<br>
redimension_store ( source_array, target_array [, (aggregate_call_1 as
alias_1 ) ,... (aggregate_call_N as alias_N ) ] )</p>
<p> <tt>redimension</tt> does not create or update array storage or
metadata, and returns the transformed array result. redimension also
only works when transforming int64 attributes into dimensions.</p>
<p> <tt>redimension_store</tt> updates the target_array storage and
creates additional mapping arrays if necessary.</p>
<p> For both variants of redimension, the target array must have the
EMPTY flag set.</p>
<p> The input and target arrays must have compatible schemas, and both
commands determine the list of transformations (attribute to dimension)
by matching names in the attribute and dimension lists of the two
arrays. It is possible to omit certain attributes and dimensions from
the target array.</p>
<p><strong> Note</strong>: redimension supports noninteger dimensions
while redimension_store does not.</p>
<p><strong> Example 1</strong>: Count the even and odd values in an
array.</p>
<ol>
  <li>Create an array that has a single attribute "a".
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">create array A &lt;a:double&gt;[x=0:5,3,0,y=0:5,3,0];<br>store(build(A, x*3+y), A);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li> Apply a synthetic attribute "even_or_odd" that is 0 when a is
even and 1 when a is odd. Turn the even_or_odd attribute into a
dimension with the <tt>redimension</tt> command and perform a <tt>count</tt>
aggregate:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">redimension(apply(A, even_or_odd, iif(int64(a)%2=0,0,1)),<br>  &lt;count:uint64 null,empty_tag:indicator&gt;[even_or_odd=0:1,2,0], count(a) as count);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p> SciDB returns:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">[{0}(18),{1}(18)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This tells you that there are 18 even and 18 odd values in the
array.</p>
<p><em> Note</em>: the target array schema must contain the empty_tag
attribute and the datatype of the new <tt>count</tt> attribute must
match the output of the aggregate (uint64 and nullable).</p>
<p><strong> Example 2</strong>: Maintain one of the original dimensions
and use the aggregates <tt>sum</tt> and <tt>avg</tt> to find the sum
and average of the even and odd elements:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">redimension(apply(A, even_or_odd, iif(int64(a)%2=0,0,1)), <br>  &lt;sum:double null, avg:double null, empty_tag:indicator&gt;[x=0:5,3,0,even_or_odd=0:1,2,0], <br>  sum(a) as sum, avg(a) as avg);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> SciDB returns:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">[<br>[{0,0}(6,2),{0,1}(9,3),{1,0}(18,6),{1,1}(15,5),{2,0}(24,8),{2,1}(27,9)]<br>];<br>[<br>[{3,0}(36,12),{3,1}(33,11),{4,0}(42,14),{4,1}(45,15),{5,0}(54,18),{5,1}(51,17)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This means that for x=0, the sum of the even numbers is 6 and the
average is 2; the sum of the odd numbers is 9 and average is 3.</p>
<p><strong> Example 3</strong>: Instead of creating a schema, the
target schema can come from a pre-existing array:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create empty array dense_redim &lt;a:double&gt;[x=0:5,3,0]<br>redimension(dense,dense_redim)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> In this case, we don't use any aggregates and condense values. In
the original array, there are 6 values for x=0, and the result of the
query at x=0 will contain an unspecified value, chosen from one of the
6 possible candidates. This command does not change any data for the
array dense_redim - just reads the schema from it.</p>
<p> The two statements</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create empty array dense_redim &lt;a:double&gt;[x=0:5,3,0];<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> and</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array dense_redim &lt;a:double, empty_tag:indicator&gt;[x=0:5,3,0];<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> are equivalent.</p>
<h2 id="repart"><a name="11_3">repart</a></h2>
<p><strong> Summary</strong>: Change array chunking</p>
<p> Change partitioning (chunking) of the array. Target array must have
the same attributes and dimensions, but chunk size may be different.
Repart returns an array whose attributes are taken from the input
array, with the dimensions of the target.</p>
<p><strong> Signature</strong>:</p>
<p> repart(<em> array</em>,<em> target : array_identifier |
anonymous_schema</em> )</p>
<p> The input to <tt>repart</tt> can be:</p>
<ol>
  <li>An array</li>
  <li>A subquery that outputs a SciDB array</li>
</ol>
<p><strong> Example</strong>:</p>
<ol>
  <li>Create a 4-by-4 array with chunk size of 1 called <tt>source</tt>:





    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">create array source &lt;val:double&gt; [x=0:3,1,0,y=0:3,1,0];<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Add numerical values to source:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">store(build(source,x*3+y),source);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Repartition the array into 2-by-2 chunks and store the result in
an array called <tt>target</tt>:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">store(repart(source, &lt;values:double&gt; [x=0:3,2,0, y=0:3,2,0]),target);<br>show(target);<br><br>[("target&lt;val:double NOT NULL&gt; [x=0:3,2,0,y=0:3,2,0]")]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<h2 id="reshape"><a name="11_4">reshape</a></h2>
<p><strong> Summary</strong>: Change array shape</p>
<p> Change the shape of an array to that of another array or array
schema.</p>
<p><strong> Signature</strong>:</p>
<p> reshape(<em> array</em>,<em> target : array_identifier |
anonymous_schema</em> )</p>
<p> The first input to <tt>reshape</tt> can be:</p>
<ul>
  <li>An array</li>
  <li>A subquery that outputs a SciDB array</li>
</ul>
<p> The <tt>reshape</tt> operator's second argument is:</p>
<ul>
  <li>the name of an array and its schema to be used as the template
for the operator's result, or</li>
  <li>an array schema ("anonymous_schema") to be used as the template
for the operator result</li>
</ul>
<p><strong> NOTES:</strong></p>
<ol class="lowerroman">
  <li>The target array (or anonymous array schema) should have the same
number of attributes as the input array.</li>
  <li>The arrays must have fixed size dimensions. That is, reshape for
unbounded arrays is not supported.</li>
  <li>Size of the input and target array should be the same. That is,
both arrays should have the same number of<em> cells</em>. For example,
it is possible to reshape 2x2x2 array to 4x2, but not 3x3 to 2x2.</li>
</ol>
<p><strong> Example</strong>:</p>
<ol>
  <li>Create a 3-by-4 array called <tt>source</tt>:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">create array source &lt;val:double&gt; [x=0:2,1,0,y=0:3,1,0];<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Add numerical values to source:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">store(build(source,x*3+y),source)<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Reshape the array to 4-by-3 and store the result in an array
called <tt>
target</tt>:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">store(reshape(source, &lt;values:double&gt; [x=0:3,1,0, y=0:2,1,0]),target)<br>show(target);<br><br>[("target&lt;val:double NOT NULL&gt; [x=0:3,1,0,y=0:2,1,0]")]<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<h2 id="reverse"><a name="11_5">reverse</a></h2>
<p><strong> Summary</strong>: Invert the elements of an array by
reversing the values of each dimension.</p>
<p><strong> Signature</strong>:</p>
<p> reverse(<em> array</em> )</p>
<p> Assume that dense is a 2-dimensional array with the following
definition and contents:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY dense &lt;a: int32&gt;[x=0:5,3,0, y=0:5,3,0]<br><br>scan(dense)<br>[<br>[(66),(65),(64)],<br>[(56),(55),(54)],<br>[(46),(45),(44)]<br>];<br>[<br>[(63),(62),(61)],<br>[(53),(52),(51)],<br>[(43),(42),(41)]<br>];<br>[<br>[(36),(35),(34)],<br>[(26),(25),(24)],<br>[(16),(15),(14)]<br>];<br>[<br>[(33),(32),(31)],<br>[(23),(22),(21)],<br>[(13),(12),(11)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><em> reverse</em> returns an array in which each dimension is the
reverse of the corresponding dimension of the source array.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">reverse(dense)<br>[<br>[(11),(12),(13)],<br>[(21),(22),(23)],<br>[(31),(32),(33)]<br>];<br>[<br>[(14),(15),(16)],<br>[(24),(25),(26)],<br>[(34),(35),(36)]<br>];<br>[<br>[(41),(42),(43)],<br>[(51),(52),(53)],<br>[(61),(62),(63)]<br>];<br>[<br>[(44),(45),(46)],<br>[(54),(55),(56)],<br>[(64),(65),(66)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="slice"><a name="11_6">slice</a></h2>
<p><strong> Summary</strong>: Subplane of an array</p>
<p> Get a slice of the array. The result is a slice of the input array
corresponding to the given coordinate value(s). Number of dimensions of
the result array is equal to the number of dimensions of input array
minus number of specified dimension, and the coordinate value should be
a valid dimension value of the input array.</p>
<p><strong> Signature</strong>:</p>
<p> slice(<em> array</em>,<em> dimension1 : dimension_identifier</em>,<em>
coordinate1 : value</em> [ ,<em>dimensionN : dimension_identifier</em>,<em>
coordinate-value-N : value</em> ] )</p>
<p> The first input to <tt>slice</tt> can be:</p>
<ul>
  <li>An array</li>
  <li>A subquery that outputs a SciDB array</li>
</ul>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(m3x3);<br><br>[<br>[(0),(1),(2)],<br>[(3),(4),(5)],<br>[(6),(7),(8)]<br>]<br><br>slice(m3x3,x,1);<br><br>[(3),(4),(5)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="subarray"><a name="11_7">subarray</a></h2>
<p><strong> Summary</strong>:Select by dimension range</p>
<p> Subarray selects a block of cells from an input array. The result
is an array whose shape is defined by the 'bounding box' specified by
the subarray.</p>
<p><strong> Signature</strong>:</p>
<p> subarray (<em> array</em>,<em> low-boundary-coordinate-1: value</em>
, ...,<em> low-boundary-coordinate-N: value</em>,<em>
high-boundary-coordinate-1: value</em>, ...,<em>
high-boundary-coordinate-N: value</em> )</p>
<p> The first argument to the subarray operator is the array from which
the block is to be sampled. This argument can be:</p>
<ul>
  <li>An array</li>
  <li>A subquery that outputs a SciDB array</li>
</ul>
<p> The second parameter section specifies which block is to be
extracted. There are as many pairs of array index values in the
parameter block as the<em> input : array</em> has dimensions. For each
dimension, the operator requires the minimum index value for each
dimension first, followed by the maximum index value for each
dimension. In other words, if the<em> input : array</em> has two
dimensions, then the subarray operator requires four start and end
values.</p>
<p><strong> Example</strong>:</p>
<p> Suppose 'my_array' is a 2-dimensional array with two integer
attributes and dimensions x and y.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array my_array &lt;val1:int64, val2:int64&gt; [x=0:4,5,0,y=0:4,5,0];<br>load(my_array, '/tmp/my_array.txt');<br><br>[<br>[(1,3),(5,7),(9,11),(13,15),(17,19)],<br>[(21,23),(25,27),(29,31),(33,35),(37,39)],<br>[(41,43),(45,47),(49,51),(53,55),(57,59)],<br>[(61,63),(65,67),(69,71),(73,75),(77,79)],<br>[(81,83),(85,87),(89,91),(93,95),(97,99)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The first input to the subarray operator is the source array. The
rest of the inputs are the indexes of the subarray window. First, the
lower bound indexes for all dimensions in the input array, are given,
then the upper ones. The result of subarray is an array of smaller or
equal size, whose dimensions always start at 0 and span only the length
of the subarray region.</p>
<p> You can use the subarray operator as shown here:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">subarray( my_array, 1, 1, 2, 2)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This query will return a block of the input array where the initial
(top-left) cell is [ 1,1 ] and the final (bottom-right) cell is at [ 2,
2 ].</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">(11,11.0)  (12,12.0)<br>(21,21.0)  (22,22.0)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This query will return a block of the input array where the initial
(top-left) cell is [ 4,4 ] and the final (bottom-right) cell is at [
6,6 ].</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> subarray ( my_array, 4, 4, 6, 6);<br><br>(44,44.0)  (45,45.0)  (46,46.0)<br>(54,54.0)  (55,55.0)  (56,56.0)<br>(64,64.0)  (65,65.0)  (66,66.0)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> subarray ( my_array, 4, 3, 6, 7);<br><br>(43,43.0)  (44,44.0)  (45,45.0)  (46,46.0)  (47,47.0)<br>(53,53.0)  (54,54.0)  (55,55.0)  (56,56.0)  (57,57.0)<br>(63,63.0)  (64,64.0)  (65,65.0)  (66,66.0)  (67,67.0)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="thin"><a name="11_8">thin</a></h2>
<p><strong> Summary</strong>: Select elements from an array dimension</p>
<p><strong> Signature</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">thin( ''array'', ''start-1'', ''step-1'', ''start-2'', ''step-2'', ... )<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Select regularly spaced elements of the array in each dimension.
The selection criteria are specified by the starting dimension value<em>
start-i</em> and the number of cells to skip using<em> step-i</em> for
each dimension of the input array.</p>
<p><strong> Example</strong>:</p>
<ol>
  <li>Create a 2-dimensional array:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">create array A &lt;a:int32&gt; [x=0:8,6,0,y=0:8,8,1];<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Store numerical values in the array:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">store(build(A,(x*8+y),A));<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Select every other element from the first dimension:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">thin(A,1,3,0,2);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p> Note: The position specified by<em> start-1</em> must be within the
actual, rather than the relative position of the array indices. For
example, if the range of dimension x were 10:18, the thin command would
throw an out-of-range error.</p>
<h2 id="unpack"><a name="11_9">unpack</a></h2>
<p><strong> Summary</strong>: Change multidimensional array to single
dimension</p>
<p> Unpack array into a single-dimensional array creating new
attributes to represent source array dimension values. Result array has
a single zero-based dimension and arguments combining attributes of the
input array. The name for the new single dimension is passed to the
operator as the second argument.</p>
<p><strong> Signature</strong>:</p>
<p> <tt>unpack(</tt><em> array</em>,<em> attribute_name</em> <tt>)</tt></p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">show(m3x3);<br><br>[("m3x3&lt;val:double NOT NULL&gt; [x=0:2,3,0,y=0:2,3,0]")]<br><br>scan(m3x3);<br><br>[<br>[(0),(1),(2)],<br>[(3),(4),(5)],<br>[(6),(7),(8)]<br>]<br><br>unpack(m3x3,i);<br><br>[(0,0,0),(0,1,1),(0,2,2),(1,0,3),(1,1,4),<br>(1,2,5),(2,0,6),(2,1,7),(2,2,8)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The format for the output of the unpack operator is to begin by
enumerating the dimensions of the input, and then to append the
attribute values. Chunk size -- ie., the number of elements per chunk
is preserved from input to output. The resulting one-dimensional array
has chunk dimension equal to the count of cells in each input chunk.</p>
<p><strong> NOTE</strong>: unpack only supports arrays whose size is
evenly divisible by chunk size in every dimension. You cannot unpack an
array A &lt;a:int32&gt; [x=0:100,30,0]; but you can unpack an array A
&lt;a:int32&gt; [x=0:100,20,0].</p>
<h2 id="xgrid"><a name="11_10">xgrid</a></h2>
<p><strong> Summary</strong>: Expand single element to grid</p>
<p> Use this operator to scale an input array by repeating cells of the
original array specified number of times. This operator can be
considered as the inverse of the regrid operator. While regrid splits
an input array into hypercubes and calculates an aggregate function
over them, xgrid produces a hypercube from the single element of the
input array by repeating that element.</p>
<p><strong> Signature</strong>:</p>
<p> xgrid(<em> array</em>,<em> scale-1</em>, ...,<em> scale-N</em> )</p>
<p> The first argument to xgrid can be</p>
<ol>
  <li>An array.</li>
  <li>An array operator, that is, an operator that outputs a SciDB
array.</li>
</ol>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(m3x3);<br>[<br>[(0),(1),(2)],<br>[(3),(4),(5)],<br>[(6),(7),(8)]<br>]<br><br>xgrid(m3x3,2,2);<br><br>[<br>[(0),(0),(1),(1),(2),(2)],<br>[(0),(0),(1),(1),(2),(2)],<br>[(3),(3),(4),(4),(5),(5)],<br>[(3),(3),(4),(4),(5),(5)],<br>[(6),(6),(7),(7),(8),(8)],<br>[(6),(6),(7),(7),(8),(8)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<hr noshade="noshade">
<h1 id="MatrixAlgebra"><a name="12">Matrix Algebra</a></h1>
<h2 id="inverse"><a name="12_1">inverse</a></h2>
<p> The <tt>inverse</tt> operator produces the matrix inverse of a
square matrix. The input matrix must be invertible, i.e., the
determinant of the matrix must be nonzero. The inverse is calculated
using LU decomposition executed on a single node (the coordinator).</p>
<p><strong> Signature</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">inverse(array)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Example</strong>:</p>
<ol>
  <li>Create a 2-dimensional array <tt>inv_33</tt>.
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">create array inv_33 &lt; val : double &gt; [ I=1:3,3,0, J=1:3,3,0 ];<br>store(build(inv_33, 1.0/(I+J-1)), inv_33);<br>scan(inv_33);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Find the matrix inverse of <tt>inv_33</tt>:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">inverse(inv_33);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Remove <tt>inv_33</tt>:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">remove(inv_33);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p><strong> NOTES:</strong></p>
<ol>
  <li><tt>inverse</tt>() accepts a square matrix with double data type
attribute only. Other numeric attribute data types are not supported.</li>
  <li><tt>inverse</tt>() is not a parallel algorithm. For parallel
implementations of matrix inverse please refer to the <tt>solve</tt>()
and <tt>svd</tt>() operators.</li>
</ol>
<p><strong> See Also</strong>:</p>
<ul>
  <li><a class="ext-link"
 href="http://mathworld.wolfram.com/MatrixInverse.html"><!--span class=&quot;icon&quot;-->&nbsp;Matrix
Inverse</a> at Wolfram's
Mathworld</li>
</ul>
<h2 id="multiply"><a name="12_2">multiply</a></h2>
<p> The multiply operator performs matrix multiplication on two input
matrices and returns a result matrix.</p>
<p> Signature:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">multiply(array, array)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Both inputs must be compatible for the multiply operation, and both
must have a single attribute. To be compatible, two matrices must have
the same size of 'inner' dimension and same chunk size along that
dimension.</p>
<p><strong> Example</strong>:</p>
<ol>
  <li>Create a 10-by-6 array <tt>lhs</tt> with one attribute of type
double:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">create array lhs &lt;val: double&gt; [ I=1:10,5,0, J=1:6,3,0 ];<br>store(build(lhs, (I*3)+J), lhs);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Create a 6-by-15 array:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">create array rhs &lt;val: double&gt; [ I=1:6,3,0, J=1:15,5,0 ];<br>store(build(rhs, (I*3)+J), rhs);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Multiply the two arrays. The result is 10-by-15:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">multiply(lhs, rhs);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Remove the arrays:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">remove(lhs);<br>remove(rhs);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p><strong> NOTES:</strong></p>
<ol>
  <li><em>multiply</em> supports all numeric data types (double, float,
and all signed and unsigned integer data types).</li>
  <li>If two input arrays contain multiple attributes the attribute to
be used in the multiply operator must be obtained using project().</li>
  <li>Matrix multiply currently does not accept matrices with NULL
attributes. Empty cells in the inputs are treated as 0.</li>
  <li>If two input matrices do not have compatible chunk sizes, the AFL
repart() operator must be used to produce compatible matrices prior to
multiplication.</li>
  <li>multiply() does not create metadata or storage objects unless the
result is added in memory with the <tt>store</tt>() operator.</li>
</ol>
<h2 id="normalize"><a name="12_3">normalize</a></h2>
<p> Divide each element of a vector by the square root of the sum of
squares of the elements.</p>
<p><strong> Signature</strong>: normalize(<em> array</em>,<em>
attribute : attribute_identifier</em> )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">scan(v10);<br><br>[(1),(2),(3),(4),(5),(6),(7),(8),(9),(10)]<br><br>normalize(v10);<br><br>[(0.0509647),(0.101929),(0.152894),(0.203859),(0.254824),<br>   (0.305788),(0.356753),(0.407718),(0.458682),(0.509647)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="transpose"><a name="12_4">transpose</a></h2>
<p> Performs the linear algebraic matrix transpose.</p>
<p> Signature:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">transpose (array)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The transpose operator accepts an array which may contain any
number of attributes and dimensions. Attributes may be of any type. If
the array contains dimensions d1, d2, d3, ..., dn the result contains
the dimensions in reverse order dn, ..., d3, d2, d1.</p>
<p><strong> Example 1</strong>:</p>
<ol>
  <li>Create an array E with two dimensions i and j and int32 attribute
x:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">CREATE ARRAY E &lt;x: int32&gt; [ i=0:2,3,0, j=0:2,3,0 ];<br>store(build(E, i), E);<br>scan(E);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Transpose the array:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">transpose(E);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Remove the array E:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">remove(E);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<p><strong> Example 2</strong>:</p>
<ol>
  <li>Create a 2-by-3 array:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">CREATE ARRAY E2x3 &lt;x: int32 &gt; [ i=0:1,2,0, j=0:2,3,0 ];<br>store(build(E2x3, x+1), E2x3);<br>scan (E2x3);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
  <li>Transpose the array. The resulting array is 3-by-2:
    <center>
    <table border="1" bordercolor="#d7d7d7" width="95%" align="center">
      <tbody>
        <tr>
          <td bgcolor="#f7f7f7">
          <pre class="wiki">transpose(E2x3);<br></pre>
          </td>
        </tr>
      </tbody>
    </table>
    </center>
  </li>
</ol>
<hr noshade="noshade">
<h1 id="NamespaceOperators:GetInformationAboutYourSciDBDatabase"><a
 name="13">Namespace Operators: Get Information About Your SciDB
Database</a></h1>
<p> AFL provides a number of mechanisms for getting information about
the database it is managing. These facilities all interrogate the SciDB
internal meta-data, and return an array object which can be subject to
further query expressions.</p>
<h2 id="attributes"><a name="13_1">attributes</a></h2>
<p><strong> Summary</strong>: Array attributes</p>
<p> Get a list of array attributes. Returns an array with the following
attributes: name, type, and boolean flag. The boolean flag represents
nullability of the attribute and is<em> True</em> if the attribute can
be set to NULL.</p>
<p><strong> Signature</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">attributes ( array_identifier )<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The argument to the attributes operator is the name of the array.</p>
<p><strong> Examples</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki"> CREATE ARRAY Attr_Example_One &lt; A: int32, B: string &gt; [ I=0:9,10,0 ];<br> attributes ( Attr_Example_One );<br><br> [("A","int32",false),("B","string",false)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY Attr_Example_Two &lt; A: string, B: double, C: int32 &gt; [ I=0:9,10,0 ];<br>attributes ( Attr_Example_Two );<br><br>[("A","string",false),("B","double",false),("C","int32",false)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Attributes are only available for stored arrays. Result arrays
returned by an AFL command may not be used as input to this <tt>
attributes</tt> operator.</p>
<h2 id="dimensions"><a name="13_2">dimensions</a></h2>
<p><strong> Summary</strong>: List array dimensions.</p>
<p><strong> Signature</strong>:</p>
<p> dimensions (<em> array_identifier</em> )</p>
<p> The argument to the dimensions operator is the name of the array.
It returns an array with the following attributes: name, start, length,
chunk size, chunk overlap, low-boundary, high-boundary.</p>
<p><strong> Examples</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array three_dimensions &lt;val:int64&gt; [X=0:9,10,0, Y=0:9,10,0, Z=0:99,10,0];<br>store(build(three_dimensions,X+1/1.0),three_dimensions);<br><br>dimensions (three_dimensions);<br><br>[("X",0,10,10,0,0,9,"int64"),("Y",0,10,10,0,0,9,"int64"),("Z",0,100,10,0,0,99,"int64")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> For a regular array defined using a create array statement with
fixed dimensions the<em> start</em> and<em> length</em> are set to the
values specified in the CREATE ARRAY statement.</p>
<p> The low and high boundaries represent the current occupancy of
cells within the array. Low-boundary represents the lowest dimension
value occupied by any element in the array and high-boundary represents
the highest dimension value occupied by an array element.</p>
<p><strong> NOTE:</strong></p>
<ul>
  <li>The length field for an unbounded dimension is set to the maximal
signed 64-bit integer.</li>
  <li>The low and high boundaries for a newly created array that does
not yet have any data is also set to undefined values recorded as
special constants (MAXINT64 - 1) and -(MAXINT64-1) respectively. These
constants are interpreted as undefined for array dimension values into
which no data has been loaded.</li>
</ul>
<h2 id="help"><a name="13_3">help</a></h2>
<p><strong> Summary</strong>: Operator signature</p>
<p> Accepts an operator name and returns an array containing a
human-readable signature for that operator.</p>
<p><strong> Signature</strong>: help (<em> operator_name: string</em> )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">help('multiply');<br><br>[("Operator: multiply<br>Usage: multiply(&lt;input&gt;, &lt;input&gt;)")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="list"><a name="13_4">list</a></h2>
<p><strong> Summary</strong>: List contents of SciDB namspace</p>
<p> The <tt>list</tt> operator allows you to get a list of elements in
the current SciDB instance.</p>
<p><strong> Signature</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">list ( element : string )<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Arguments</strong>:</p>
<p> The<em> element : string</em> parameter value is one of the
following:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <td> <tt>aggregates</tt></td>
      <td> Show all operators that take as input a SciDB array and
return a scalar.</td>
    </tr>
    <tr>
      <td> <tt>arrays</tt></td>
      <td> Show all arrays created in the current SciDB instance.</td>
    </tr>
    <tr>
      <td> <tt>functions</tt></td>
      <td> Show all functions. Each function will be listed with its
available dataypes and the library in which it resides.</td>
    </tr>
    <tr>
      <td> <tt>libraries</tt></td>
      <td> Show all libraries that are loaded in the current SciDB
instance.</td>
    </tr>
    <tr>
      <td> <tt>nodes</tt></td>
      <td> Show all nodes. Each node will be listed with its port, id
number, and time and date stamp for when it came online.</td>
    </tr>
    <tr>
      <td> <tt>operators</tt></td>
      <td> Show all operators and the library in which they reside.</td>
    </tr>
    <tr>
      <td> <tt>types</tt></td>
      <td> Show all the dataypes the SciDB supports.</td>
    </tr>
    <tr>
      <td> <tt>queries</tt></td>
      <td> Show all active queries. Each active query will have an id,
a time and date when it was initiated, an error code, whether it
generated any errors, and a status (boolean flag where TRUE means that
the query is idle).</td>
    </tr>
  </tbody>
</table>
<p> If called without any parameters, <tt>list</tt> will return a list
of all arrays created in SciDB. Arrays persist across SciDB sessions
until you re-initialize the database (<tt>scidb.py initall</tt><em>
hostname</em>).</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">list();<br><br>[("Reads"),("Load_and_Append"),("Load_Two"),("Example_One"),("Example_Four"),("Build_Example_INT")]<br><br>list('arrays');<br><br>[("Reads"),("Load_and_Append"),("Load_Two"),("Example_One"),("Example_Four"),("Build_Example_INT")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The <tt>list</tt> operator returns a SciDB array, so you can be
use it as the input to other data sampling operators. The following
query returns all of the functions in SciDB named 'regex', together
with their function signatures:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">filter(list ('functions'), name='regex');<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The following query uses the SciDB<em> regex()</em> function to
filter the functions to find only those that take as input a pair of
strings:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">filter (list ('functions'), regex(profile, '(.*)(string,string)(.*)'));<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> And finally, the following query filters out only functions that
take a pair of strings as input and compute some boolean result (like
"regex"). Then it sorts that result by the function's name (the first
attribute produced by<em> list('functions')</em>), and finally projects
out only the function's signature:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">project (<br>    sort (<br>        filter (<br>            list ('functions'),<br>            regex(profile, '(.*)bool(.*)(string,string)(.*)')<br>        ),<br>    1),<br>    profile<br>);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="show"><a name="13_5">show</a></h2>
<p><strong> Summary</strong>: Array format</p>
<p> The <tt>show</tt> operator combines the information an array's
attributes and dimensions. The result is formated as it would appear in
a <tt>create array ...</tt> statement.</p>
<p><strong> Signature</strong>:</p>
<p> show (<em> array_identifier</em> )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY Attr_Example_Two &lt; A: string, B: double, C: int32 &gt; [ I=0:9,10,0 ];<br>show ( Attr_Example_Two );<br><br>[("Attr_Example_Two 8&lt;A:string NOT NULL,B:double NOT NULL,C:int32 NOT NULL&gt; [I=0:9,10,0]")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="versions"><a name="13_6">versions</a></h2>
<p><strong> Summary</strong>: Array versions</p>
<p> Get a list of array versions for an array.</p>
<p><strong> Signature</strong>:</p>
<p> versions (<em> array_identifier</em> )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">versions(updarr);<br><br>[(1,"12/31/10 11:03:10"),(2,"12/31/10 12:22:17"),(3,"12/31/10 12:22:19")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The output of the versions command is a list of versions, each of
which has a version ID and a datestamp which is the date and time of
creation of that version.</p>
<hr noshade="noshade">
<h1 id="InternalCommands"><a name="14"><strong>Internal Commands</strong>
</a></h1>
<p> The commands in this chapter are for internal debugging purposes.
They are not guaranteed or tested for general customer use.</p>
<h2 id="cancel"><a name="14_1">cancel</a></h2>
<p><strong> Summary</strong>: Cancel a currently running query by query
id.</p>
<p><strong> Signature</strong>: cancel(<em> query_id : integer</em> )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">cancel(12345);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The query id can be obtained from the scidb log or via the list()
command. SciDB maintains query context information for each completed
and in-progress query in the server. If the user issues a "ctrl-C" or
abort from the client, the query is cancelled and its context is
removed from the server.</p>
<p> In-progress queries are aborted by issuing a cancel() command with
the query ID. Context information is also removed by this command.</p>
<p> This query context can also be removed for completed queries by
issuing a cancel() command.</p>
<p> Query context information maintained by the server is not
persistent and is lost on server restart.</p>
<h2 id="diskinfo"><a name="14_2">diskinfo</a></h2>
<p><strong> Summary</strong>: Check disk capacity</p>
<p> Get information about storage space. Returns an array with the
following attributes:</p>
<ul>
  <li>used</li>
  <li>available</li>
  <li>clusterSize</li>
  <li>nFreeClusters</li>
  <li>nSegments</li>
</ul>
<p><strong> Signature</strong></p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">diskinfo()<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="echo"><a name="14_3">echo</a></h2>
<p><strong> Summary</strong>: Print a string</p>
<p> Accepts a string and returns a single-element array containing the
string.</p>
<p><strong> Signature</strong>:</p>
<p> echo(<em> string</em> )</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">echo('Hello world');<br><br>[("Hello world")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="explain_logicalexplain_physical"><a name="14_4">
explain_logical/explain_physical</a></h2>
<p><strong> Summary</strong>: Show query plan</p>
<p> The operators explain_logical and explain_physical can be used to
emit a human-readable plan string for a particular query without
running the query itself. SciDB first constructs a logical plan,
optimizes it and then translates it into a physical plan.</p>
<p><strong> Signature</strong>:</p>
<p> explain_logical(<em> query: string</em>,<em> language: string</em>
) explain_physical (<em> query: string</em>,<em> language: string</em> )</p>
<p> where language corresponds to the language of the query string and
is either<em> afl</em> or<em> aql</em>.</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">explain_physical('store(join(a, b), c)','afl')<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Note that the output of the explain operators is a single-element
array that contains the plan string. The plan text format is intended
for SciDB developers and experts and is subject to change in the future.</p>
<h2 id="reduce_distro"><a name="14_5">reduce_distro</a></h2>
<p><strong> Summary</strong>: Reduce the distribution of a replicated
array</p>
<p> Given an array that is distributed with psReplication - quickly
reduce the distribution to a different schema by masking certain
chunks. For internal use.</p>
<p><strong> Signature</strong>:</p>
<p> reduce_distro(<em> array</em>,<em> partitioning_schema: integer</em>
)</p>
<p><strong> Example</strong>:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">reduce_distro(\"target@1:label\",2);<br><br>[("a"),("b"),("e"),("f"),("l"),("o"),("x"),("z")]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="setopt"><a name="14_6">setopt</a></h2>
<p> Set/get configuration option value at runtime. Option value should
be specified as string. If new value is not specified, then values of
this configuration option at all nodes are printed. If new value is
specified, then value of option is updated at all odes and result array
contains old and new values of the option at all nodes.</p>
<p><strong> Signature</strong></p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">setopt ( option-name [ , new-option-value ] ) <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Example</strong></p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">setopt('threads', '4')<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="sg"><a name="14_7">sg</a></h2>
<p><strong> Summary</strong>: Scatter or Gather an array.</p>
<p> The <tt>sg</tt> operator is used internally to redistribute or
repartition the elements of an array between SciDB processing nodes. <tt>
sg</tt> by itself does not perform any computation and its use in user
queries can lead to inefficiencies and is discouraged.</p>
<p> <tt>sg</tt> redistributes chunks of the input array across cluster
nodes according to a specified policy. sg is not a user-visible
operator, but it is heavily used by the system internally. It is a
physical operator for data movement within the system and users are not
expected to invoke it directly. For example, the scidb optimizer
inserts an sg operator after load to redistribute array data using
round robin distribution. The optimizer may also insert sg operators to
assist with aggregations, operators that don't preserve shape or
operators that don't preserve distribution.</p>
<p><strong> Signature</strong></p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sg ( ''array,'' [ ''partitioning schema'' [, ''node id'' [, ''result array name''<br>   [, ''store_flag'' [, ''offset_x'', ''offset_y'', ... ] ] ] ] ]) <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Arguments</strong>:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <td><strong> Argument name</strong></td>
      <td><strong> Description</strong> </td>
      <td><strong> Comments</strong></td>
    </tr>
    <tr>
      <td> input_array</td>
      <td> array to be redistributed.</td>
      <td> May also be the output of another operator like scan,
filter, etc.</td>
    </tr>
    <tr>
      <td> partitioning schema</td>
      <td> integer constant specifying partitioning schema.</td>
      <td> Possible values are shown in the table below.</td>
    </tr>
    <tr>
      <td> node number</td>
      <td> a node number to send all chunks.</td>
      <td> Used only with psLocalNode. Ignored for other partitioning
schemas.</td>
    </tr>
    <tr>
      <td> result array</td>
      <td> a name of result array.</td>
      <td> If omitted, the result of sg is nameless and temporary with
query duration.</td>
    </tr>
    <tr>
      <td> store_flag</td>
      <td> a boolean indicator used to specify whether sg should store
the result array.</td>
      <td> By default, true if result array name is given. If
store_flag is true, the result of sg is persisted as a new array with
given name. If store_flag is false, the result is a temporary named
array that can be referenced elsewhere in the query.</td>
    </tr>
    <tr>
      <td> offset</td>
      <td> a distribution offset vector.</td>
      <td> For internal use.</td>
    </tr>
  </tbody>
</table>
<p> The partition schema is one of the following types.</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <td> partition schema</td>
      <td> Description</td>
      <td> Comment</td>
    </tr>
    <tr>
      <td> 0</td>
      <td> psReplication</td>
      <td> replicate array on every node of cluster</td>
    </tr>
    <tr>
      <td> 1</td>
      <td> psRoundRobin</td>
      <td> distribute chunks by round robin</td>
    </tr>
    <tr>
      <td> 2</td>
      <td> psLocalNode</td>
      <td> send every local chunk to specified node</td>
    </tr>
    <tr>
      <td> 3</td>
      <td> psByRow</td>
      <td style="text-align: right;"> distribute every chunk to node
according to chunk coordinate of dimension 0</td>
    </tr>
    <tr>
      <td> 4</td>
      <td> psByCol</td>
      <td style="text-align: right;"> distribute every chunk to node
according to chunk coordinate of dimension 1</td>
    </tr>
  </tbody>
</table>
<p><strong> Examples</strong>:</p>
<p> Create a query to distribute array by round robin onto every node:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sg(seq_info, 1, -1, seq_info_sg);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Create a query to gather whole array on node 0 in memory array
(will not be stored on disk):</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">sg(seq_info_sg, 2, 0);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<hr noshade="noshade">
<h1 id="AQL:ArrayQueryLanguageReference"><a name="15">AQL: Array Query
Language Reference</a></h1>
<p> The AQL language includes two classes of queries:</p>
<ul>
  <li><strong>Data Definition Language</strong> (DDL) : queries to
define arrays and load data.</li>
  <li><strong>Data Manipulation Language</strong> (DML) : queries to
access and operate on array data.</li>
</ul>
<p> This document provides reference material for AQL.</p>
<h2 id="DDL"><a name="15_1"><strong>DDL</strong></a></h2>
<h3 id="CREATEARRAY"><a name="15_1_1">CREATE ARRAY</a></h3>
<p> The CREATE ARRAY command creates an array with specified name and
schema.</p>
<p> The rest of this document will refer to the following CREATE ARRAY
example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY A &lt;x: double NOT NULL, err: double&gt; [i=0:99,10,0, j=0:99,10,0];<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This creates a 100-by-100 array with a chunk size of 10 in each
dimension and no chunk overlap.</p>
<h3 id="LOAD"><a name="15_1_2">LOAD</a></h3>
<p> Loading data into arrays is done using the load command.</p>
<p> The syntax for LOAD is:</p>
<p> LOAD<em> array_name : string</em> FROM<em> file_path : string</em>;</p>
<p> Example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">LOAD A FROM '/tmp/A.txt';<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The data file formats supported by SciDB are documented in the AFL
document. The file path 'A.txt' is assumed to be a path name relative
to the coordinator's working directory. For this document, the file
A.txt is a 100-by-100 file with two numerical values per cell.</p>
<p><strong> Note</strong>: AQL only supports coordinator load
(corresponding to nodeid=0 in the AFL<em> load()</em> command). See the
section on<em> load()</em> in the AFL documentation.</p>
<h3 id="DROP"><a name="15_1_3">DROP</a></h3>
<p> Deleting arrays is done with the <tt>drop</tt> command.</p>
<p> DROP ARRAY array_name;</p>
<p> For example to drop array A, run the following command:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">DROP ARRAY A;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The array and all its versions are dropped. Any associated mapping
arrays created for noninteger dimensions are also dropped.</p>
<p><strong> Note</strong>: Many AQL commands do not create or accept
arrays with noninteger dimensions.</p>
<h2 id="DMLQuerySyntax"><a name="15_2"><strong>DML Query Syntax</strong></a>
</h2>
<h3 id="SELECTattributesFROM"><a name="15_2_1">SELECT attributes FROM</a>
</h3>
<p> As in SQL, AQL SELECT is used to select one or more attributes from
an array.</p>
<p> Syntax: SELECT "expr_list | *" [INTO name] FROM "array_name |
array_result"</p>
<p> For example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * FROM A;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This is a basic query the selects all attributes from the whole
array A. SELECT lists can also reference individual attributes and
dimensions, as well as constants and expressions. Expressions are
discussed later in this document.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT err FROM A;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This is a SELECT query that selects the attribute <tt>err</tt>
from A. To store the value of the attribute <tt>err</tt> in and array
called C:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT err INTO C FROM A;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This query selects the attribute <tt>err</tt> from the array A and
stores the result in array C. If the array C does not exist, an array
with the appropriate schema is created for it. If C exists, its
attribute values are updated.</p>
<p> If an array exists in SciDB, but its schema has different chunking
and overlap specifications, or some dimensions in the schema are
declared as noninteger dimensions, then the repart() or redimension()
is applied to the result before storing it into the destination array.</p>
<p> In place of a table<em> A</em> or a join result, SELECT can also be
used to select data from an AFL operator result. For a full list of AFL
operators, please refer to the "SciDB Array Functional Language
Reference" document. Shown below is such an example with the "show"
operator which return an array containing the schema of<em> A</em>.</p>
<p> Example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * FROM show(A);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="WHEREClause"><a name="15_2_2">WHERE Clause</a></h3>
<p> A WHERE clause is used to filter cells from the input array.</p>
<p> Syntax: SELECT "expr_list | *" [INTO name] FROM "array_name |
array_result" [ WHERE expr ]</p>
<p> For example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * FROM A WHERE err &lt; 2;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The above query selects all cells in the array whose error is less
than 2. The shape of the array is preserved by the WHERE clause. The
user will see a result with the same shape as A, except the cells that
don?t match the condition of the WHERE clause will be empty.</p>
<p> Note that the where clause can be used to check if a particular
attribute is NULL. This is done with the 'IS NULL' and 'IS NOT NULL'
construct.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT x FROM A WHERE x IS NOT null;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> SciSB supports SQL semantics for null values. Hence, any comparison
or use of null values in expressions will evaluate to NULL, except for
the ?is null? or 'is not null' predicates. For a description of NULL
values in SciDB please refer to the section on "CREATE ARRAY" in the
AFL document.</p>
<p> In contrast, EMPTY elements of an array are not evaluated by the
WHERE clause.</p>
<h3 id="AQLExpressions"><a name="15_2_3">AQL Expressions</a></h3>
<p> AQL expressions in the SELECT list or the WHERE clause are standard
expressions over the attributes and dimensions of the array. They can
also refer to special built-in functions supported by SciDB. The full
list of built-in functions is available in the Alphabetical List of
Functions appendix to this document.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT x FROM A WHERE sin(x)&lt;0;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> returns all values of the attribute x (in radians) where sin(x) is
negative.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT sqrt(x) FROM A WHERE sin(x)&lt;0;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> returns the square root of all values of the attribute x for which
sin(x) is negative.</p>
<h3 id="NaturalJOIN"><a name="15_2_4">Natural JOIN</a></h3>
<p> A join combines two or more arrays typically as a preprocessing
step for subsequent operations. The following example illustrates SciDB
JOIN.</p>
<p> Syntax:</p>
<p> SELECT "expr_list | *" [INTO name] FROM joinexpr [ WHERE expr ]</p>
<p> joinexpr := expr ( ("," expr) )*</p>
<p> Consider an array B, that has the same shape as array A declared
earlier:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE ARRAY B &lt;y: double, err2: double&gt; [i=0:99,10,0, j=0:99,10,0];<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The following query returns an array by joining arrays A and B.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * FROM A, B;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This join is a natural join of array A with B. This is only
possible with two arrays with matching shape. The arrays must have the
same number of dimensions, matching dimension start and endpoints, and
same chunk size. But dimension names need not match. The dimensions of
the resulting array are the same dimensions as the inputs but with the
dimension names from the first array.</p>
<p> The resulting array also has combined attributes of all inputs.
Each cell in the resulting array in this example has 4 attributes, x,
err from A and y, err2 from B. Natural join is useful when you need to
merge two arrays with the same shape in order to perform further
processing on their attributes.</p>
<p> The following example joins two arrays in order to compute the sum
of two attributes for each element.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT A.x + B.y FROM A,B;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="JOINON"><a name="15_2_5">JOIN ON</a></h3>
<p> AQL JOIN ON is used to join two compatible arrays.</p>
<p> The JOIN ON returns an array that is the cross product join of its
inputs. Only JOIN ON equality predicates are supported. Predicates must
use compatible dimensions from the input arrays -- size, types and
chunking.</p>
<p> Each cell in the output array contains all elements from the join
inputs from corresponding dimension values.</p>
<p> AQL currently supports dimension-dimension, attribute-attribute and
attribute-dimension JOINs.</p>
<h4 id="Dimension-dimensionjoin">Dimension-dimension join</h4>
<p> In a dimension-dimension join, two or more arrays can be joined on
dimensions. This is translated by AQL into AFL cross-joins. JOIN ON
dimension predicates are compiled into the dimension pairs list for
cross-join. Any aliasing required is performed by the AQL-to-AFL
compiler.</p>
<p> Example: Consider the following example 3-by-3 arrays <tt>v1</tt>
and <tt>k</tt>.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">CREATE array v1 &lt;a:double, b:int64&gt; [x=1:3,3,0, y=1:3,3,0];<br>CREATE ARRAY k &lt;c: string, d:double&gt; [x=1:3,3,0, y=1:3,3,0];<br><br>scan(v1)<br>[<br>[(1,1),(1,2),(1,3)],<br>[(2,1),(2,2),(2,3)],<br>[(3,1),(3,2),(3,3)]<br>]<br><br>scan(k)<br>[<br>[("addr_11",11),("addr_12",12),("addr_13",13)],<br>[("addr_21",21),("addr_22",22),("addr_23",23)],<br>[("addr_31",31),("addr_32",32),("addr_33",33)]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Performing a join on the first dimension creates a 3-by-3-by-3
array:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">set lang AQL;<br>DROP array res_dim;<br>SELECT * INTO res_dim FROM v1 JOIN k ON v1.x = k.x;<br><br>[<br>[<br>[(1,1,"addr_11",11),(1,1,"addr_12",12),(1,1,"addr_13",13)],<br>[(1,2,"addr_11",11),(1,2,"addr_12",12),(1,2,"addr_13",13)],<br>[(1,3,"addr_11",11),(1,3,"addr_12",12),(1,3,"addr_13",13)]<br>],<br>[<br>[(2,1,"addr_21",21),(2,1,"addr_22",22),(2,1,"addr_23",23)],<br>[(2,2,"addr_21",21),(2,2,"addr_22",22),(2,2,"addr_23",23)],<br>[(2,3,"addr_21",21),(2,3,"addr_22",22),(2,3,"addr_23",23)]<br>],<br>[<br>[(3,1,"addr_31",31),(3,1,"addr_32",32),(3,1,"addr_33",33)],<br>[(3,2,"addr_31",31),(3,2,"addr_32",32),(3,2,"addr_33",33)],<br>[(3,3,"addr_31",31),(3,3,"addr_32",32),(3,3,"addr_33",33)]<br>]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The output of the join on statement above is an array with the
following schema:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">&lt;a:double NOT NULL,b:int64 NOT NULL,c:string NOT NULL,d:double NOT NULL&gt; <br>     [x=1:3,3,0,y=1:3,3,0,y_2=1:3,3,0]<br><br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The new generated dimension name is y_2.</p>
<h4 id="Attribute-attributeJOIN">Attribute-attribute JOIN</h4>
<p> The JOIN ON predicate may have a list of equality predicates based
on array attributes. If this is done, the inputs are first transformed
into temporary stored arrays using the redimension_store() operator and
then joined using AFL cross_join(). Any additional arrays created to
execute the JOIN are removed at the end of query execution.</p>
<p> The following shows an example of attribute-attribute join:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * INTO res_attr FROM v1 JOIN k ON v1.a = k.d;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The above query produces a result with the following schema:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">&lt;a:double NOT NULL,b:int64 NOT NULL,c:string NOT NULL,<br>     empty_indicator:indicator NOT NULL&gt; [x=1:3,3,0,y=1:3,3,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * FROM vector3 A JOIN vector3 B ON A.a = B.b and A.b = B.a;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> produces a result with the following schema:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">&lt;a:int64 NOT NULL, b:int64 NOT NULL, empty_indicator:indicator NOT NULL&gt;<br>[i=*:*,10,0, i_2=*:*,10,0]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h4 id="Dimension-AttributeJoin">Dimension-Attribute Join</h4>
<p> A dimension-attribute join can be performed between attributes and
dimensions that have the same data type.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * INTO result FROM v1 JOIN k ON v1.b = k.x;<br>[<br>[<br>[(2,1,"addr_11"),(),()],<br>[(),(3,2,"addr_22"),()],<br>[(),(),(4,3,"addr_33")]<br>],<br>[<br>[(),(3,2,"addr_22"),()],<br>[(),(),()],[(),(),()]],<br>[<br>[(),(),(4,3,"addr_33")],<br>[(),(),()],[(),(),()]<br>]<br>]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="Aggregates"><a name="15_2_6">Aggregates</a></h3>
<p> AQL supports the following built-in aggregate functions:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <th> Name</th>
      <th> Operation Performed</th>
    </tr>
    <tr>
      <td> <tt>avg</tt></td>
      <td> Average value</td>
    </tr>
    <tr>
      <td> <tt>count</tt></td>
      <td> Number of nonempty elements</td>
    </tr>
    <tr>
      <td> <tt>max</tt></td>
      <td> Largest value</td>
    </tr>
    <tr>
      <td> <tt>min</tt></td>
      <td> Smallest value</td>
    </tr>
    <tr>
      <td> <tt>sum</tt></td>
      <td> Sum of all the elements</td>
    </tr>
    <tr>
      <td> <tt>stdev</tt></td>
      <td> Standard deviation</td>
    </tr>
    <tr>
      <td> <tt>var</tt></td>
      <td style="text-align: left;">Variance</td>
    </tr>
  </tbody>
</table>
<p> The scalar aggregate functions in AQL take an input array and
produce a scalar result. The value for the result is the aggregate
function applied to the entire array.</p>
<p> For example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT max (SELECT a1 FROM a);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Each array aggregate function accepts one attribute of appropriate
type. For example, to compute the maximum value of an attribute, that
attribute type must support inequality and equality functions. So, for
the max aggregate, the data types that can be used are</p>
<blockquote>
  <p> integers (int8, int16, int32, int64, uint8, uint16, uint32,
uint64) and floating point (double,float) types.</p>
</blockquote>
<p> count here is an aggregate function that takes an array as input
and returns a scalar value in its output.</p>
<p> Below is a query that counts all the measurements of array A:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT count(A);<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p><strong> Note</strong>: While all aggregates can be calculated in
this manner over the entire array typically on one attribute, the<em>
count</em> function is an exception. In the AFL version, you can use a
dimension name as an optional input into the count function.</p>
<ul>
  <li>When <tt>count()</tt> is used without any arguments, the result
is a</li>
</ul>
<p> count of the number of non-empty elements in the array.</p>
<ul>
  <li>When <tt>count</tt> is supplied</li>
</ul>
<p> with a dimension name, count counts the number of non-null
occurrences of that attribute within the array.</p>
<h3 id="GROUPBYAggregates"><a name="15_2_7">GROUP BY Aggregates</a></h3>
<p> AQL aggregates can also be used with the GROUP BY clause. The
syntax for a group by aggregate is as follows.</p>
<p> SELECT "namedExprList | *" [ INFO name] FROM joinexpr [ WHERE expr
] [ groupBy ];</p>
<p> groupBy := "group by" dimensionList "as" pathExpr</p>
<p> dimensionList := dim ("," dim)*</p>
<p> AQL GROUP BY takes a list of dimensions as a "group by" list,
groups the array by the specified dimensions and computes the aggregate
function for each group. The result of aggregate is an array with same
dimensions as the source array without the group by dimensions. The
result array has a single attribute which is the aggregate result per
group.</p>
<p> The result of a "GROUP BY x, y" is an array with only x, y
dimensions and a new attribute which is the corresponding partition.
This partition can be accessed by sub-queries or expressions in the
SELECT aggregate clause. The following examples explain the GROUP BY
aggregate.</p>
<h4 id="Example1.countgroupby">Example 1. count group by</h4>
<p> Suppose we want to first group measurements by the first dimension,
then calculate the count over each of the groups, the AQL query will
look like this:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT count(part)<br>FROM A<br>GROUP BY i AS part;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The group by clause here creates a nested array for each group and
names the nested array<em> part.</em> Part is a one-dimensional array
corresponding to a given value of dimension<em> i</em> and attributes
of the input array<em> A.</em></p>
<h4 id="Example2.groupbyavgoveranattribute">Example 2. group by avg
over an attribute</h4>
<p> Now suppose we need to compute the average measurement from A,
grouped by i we issue the following AQL query which selects the
attribute to be used as input to the average. AQL also supports
standard SQL-like syntax for computing the aggregate over array
groupings. In the current release of SciDB, the AQL GROUP BY must
provide a name for the partition attribute created in the GROUP BY
aggregate. See example below.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT avg(x)<br>FROM A<br>GROUP BY i AS T;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="Nestedsub-queries"><a name="15_2_8">Nested sub-queries</a></h3>
<p> In this release nested queries can either be simple aggregate
queries in the SELECT clause, or nested queries in the FROM clause.
Other kinds of nested queries will be supported in forthcoming releases</p>
<p> In the example below, we select partitions whose average value is
greater than 10:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * FROM<br>( <br>SELECT avg (SELECT x FROM part)<br>FROM A<br>GROUP BY i AS part<br>)<br>WHERE avg &gt; 10;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="UpdatesandVersions"><a name="15_2_9">Updates and Versions</a></h3>
<p> AQL arrays that are updatable can be updated using the following
command:</p>
<p> UPDATE array SET "attr = expr", ... [ WHERE condition ];</p>
<p> For example, to add 1.0 to each measurement in array A and add 0.05
to each error, we can write the following query:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">UPDATE A SET x = x+1, err = err + 0.05;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Update can be used with a WHERE clause. To increase the measurement
only if the error is smaller than 0.05:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">UPDATE A SET x = x+1 WHERE err &lt; 0.05;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Note that the UPDATE clause can be used to update non-null elements
using the following example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * FROM A;<br>[(), (2), (3)]<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">UPDATE A SET a = a + 1 WHERE a IS NOT NULL; <br>[(), (3), (4)] <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">UPDATE A SET a = 22222 WHERE a IS NULL;<br>[(22222),(3),(4)] <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> For a definition of NULLs in the SciDB array data model please
refer to the AFL documentation for this release.</p>
<p> SciDB saves all versions of the data, so the user has an option to
query data as it was in the database at a specific time. This is done
by appending a @ datetime prefix after the name of the array. For
example, the following query returns data as of November 11 2010:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * FROM A @ datetime('2011-12-15 22:33:12');<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> If multiple versions have the same datetime, the most recent
version, i.e., the one with the highest version number is returned. The
timestamp of a version is the time on the SciDB server, which is by
default reported in UTC timezone.</p>
<p> To set the time zone, use the datetimetz argument.</p>
<p> For convenience, SciDB includes a now() function, so one can write
a query to retrieve all data that was in the array 1000 miliseconds
prior to current date and time:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * FROM A @ now() - 1000;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Any expression yielding a datetime value is supported after the @
operator.</p>
<h3 id="Aliases"><a name="15_2_10">Aliases</a></h3>
<p> AQL provides a way to refer to arrays in the query via aliases.
These are useful when using the same array repeatedly in an AQL
statement, or when abbreviating a long array name. Aliases are created
by adding an "as" to the array name, followed by the alias. Future
references to the array can then use the alias.</p>
<p> Example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT * FROM vector3 AS A;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Once an alias has been assigned, all attributes and dimensions of
the array can use the fully qualified name using the dotted naming
convention.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT A.x + 10 from vector3 AS A;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> For example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">SELECT pow(sin(a1), 2) as p1, pow(cos(a1), 2) as p2 FROM A;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<hr noshade="noshade">
<h1 id="SciDBPlugins:ExtendingSciDBFunctionality"><a name="16">SciDB
Plugins: Extending SciDB Functionality</a></h1>
<p> User-defined extensions to SciDB functionality are referred to as<em>
plugins</em>. SciDB supports user-defined functions (UDFs),
user-defined types (UDTs), and user-defined operators (UDOs).</p>
<h2 id="Extensibility:TypesandFunctions"><a name="16_1">Extensibility:
Types and Functions</a></h2>
<p> Out of the box, SciDB provides users with a standard set of data
types; integer, float/double, and string. Scientific and large-scale
analytic applications often require other data types such as complex
numbers, rational numbers, two-dimensional points, or others. Some
applications call for specific mathematical functions (such as greatest
common factor of two integers or non-uniform random number generation)
that SciDB does not provide by default. SciDB's extensibility mechanism
allows users to add their own implementation of types and functions to
the SciDB engine.</p>
<p> Suppose a SciDB application requires a rational number datatype.
Rather than use double precision, the user wants to store an
integer-type numerator and denominator pair. As part of the the new
type's functionality users will also want to support basic arithmetic (
+, -, *, / ) and logical (&lt;, &lt;=, =, &gt;=, &gt;, &lt;&gt;)
functionality.</p>
<p> At the level of the AQL query language, the new type can be used as
follows:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">create array rational_example &lt; N : rational &gt; [ I=0:99,10,0, J=0:99,10,0 ]<br><br># Q1: <br><br>SELECT COUNT(*)<br>   FROM rational_example AS R<br> WHERE R.N = rational(1,2);<br><br># Q2: <br><br>SELECT str(R.N) <br>  FROM rational_example AS R<br> WHERE R.N + rational(1,4) &gt; rational(1,2);<br>  <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> So far as a user's queries are concerned, there will be no
difference between the way a built-in type and a user-defined type (or
function) works. There are, however, a couple of things to be aware of:</p>
<ol>
  <li>All type conversions need to be explicit. SciDB does not (yet)
support implicit casting.</li>
  <li>Client applications can only accommodate a limited set of types:
doubles, integers, and strings. When you write queries (using iquery,
say) the query's result needs to explicitly convert result types into
something that the client understands.</li>
  <li>While it is quite possible to write complex and computationally
expensive UDFs (we include an example of a prime number factorization)
it's generally a better practice to build UDFs as small, self-contained
units of functionality and then to combine them using the SciDB query
language's facilities.</li>
  <li>We do not (yet) support features like embedding queries within
UDFs, or plugins that do anything more sophisticated than take a vector
of scalar values and return a single scalar type result.</li>
</ol>
<h2 id="SciDBPluginExamples"><a name="16_2">SciDB Plugin Examples</a></h2>
<p> SciDB includes multiple example extensions in the ~/examples folder
located beneath the SciDB root directory. These examples are:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <td><strong>Name</strong></td>
      <td><strong>Description</strong></td>
    </tr>
    <tr>
      <td>complex</td>
      <td>Complex Number UDT (a + b.i), together with the associated
algebraic operations, and equality.</td>
    </tr>
    <tr>
      <td>rational</td>
      <td>Rational Number UDT (int64 numerator and denominator)
together with the associated algebra operations and ordering comparisons</td>
    </tr>
    <tr>
      <td>point</td>
      <td>2-D Point UDT. Double precision X and Y</td>
    </tr>
    <tr>
      <td>more_math</td>
      <td>A selection of user-defined functions which perform useful
mathematical operations.</td>
    </tr>
  </tbody>
</table>
<h2 id="SciDBPluginsArchitecture"><a name="16_3">SciDB Plugins
Architecture</a></h2>
<p> The basic architecture of a SciDB Plugin works as follows. The
algorithms implemented within the SciDB engine are designed to treat
instances of data type values as<em> black box</em> memory segments.
For example, all that the SciDB engine "knows" about the contents of
the Complex Number data type is that it is 16 bytes long. The code that
needs to know about the contents of these 16 bytes is implemented by
the user in their own C/C++, which they compile into a shared library.</p>
<p> At run-time, the SciDB engine dynamically links this shared library
and calls the functions it contains to perform the operations specified
in the query.</p>
<p> For example, the user-written 'C' code to add two complex numbers
looks like this:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">//<br>// This is the struct that describes how the 16 bytes of data that makes up an instance <br>// of a SciDB Complex UDT is organized.<br>struct Complex<br>{<br>    double re;<br>    double im;<br>};<br><br>//<br>// This is the code that takes data from the SciDB engine, performs the addition, and deposits<br>// the return result in an appropriately sized "black box" of bytes. The SciDB engine takes <br>// this return result and stores it, or passes it on to another function. <br>static void addComplex(const Value** args, Value* res, void*)<br>{<br>    Complex&amp; a = *(Complex*)args[0]-&gt;data();<br>    Complex&amp; b = *(Complex*)args[1]-&gt;data();<br>    Complex&amp; c = *(Complex*)res-&gt;data();<br><br>    c.re = a.re + b.re;    <br>    c.im = a.im + b.im;<br>}<br><br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> When it parses a query like the one labeled "Q2" above, the SciDB
engine checks to ensure that it had been provided with a shared library
containing code to perform the plus ( Type, Type ) -&gt; Type
operation. In this case, SciDB would look for a function named "+" that
took two arguments of the appropriate type (in this case, a pair of
complex number instances). Then at run time the SciDB engine would
assemble the necessary 16-byte "black boxes", invoke the function 'C'
addComplex(), and deal with the value it computed.</p>
<h2 id="User-DefinedFunctions:HowSciDBProvidesDatatypeInstances"><a
 name="16_4">
User-Defined Functions: How SciDB Provides Datatype Instances</a></h2>
<p> As you can see from the example code above, SciDB uses a
typesystem::Value class to encapsulate information about all type value
instances. The Values class provides a set of methods for getting and
setting the "value" of the class for each of the SciDB built-in types;
getType() and setType(), or more explicitly (in the case of a
typesystem::Value val; instance that contains a string) val.getString()
and val.setString().</p>
<p> From the perspective of the SciDB engine, all UDFs have the same
basic signature:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">void functionUDF(const Value** args, Value* res, void*)<br>{<br><br>}<br><br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Each function must "know" how many arguments it is to receive.
These arguments are obtained from the vector of typesystem::Value
pointers that makes up the first argument. Each UDF (currently) returns
a single result and the location where this result is to be placed is
passed in by reference in the second argument. The final argument is a
pointer to a data structure that conveys information about the state of
the engine, and is a means of passing data between repeated calls to
the UDF within the same query.</p>
<h2 id="LoadingaPlugin"><a name="16_5">Loading a Plugin</a></h2>
<p> Each of these example plugins included with the SciDB distribution
is built (by default) at the time we build the core engine. However,
SciDB does not load unregistered plugins when it starts up. To use one
of the examples you need to load it into the SciDB instance. The
following figure illustrates how to load shared libraries containing
plugins into SciDB using first, the AFL interface, and second, our AQL
query language.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">--<br>-- AFL load_library() operation<br>load_library ( 'librational.so' )<br><br>--<br>-- AQL 'load library' syntax<br>load library 'librational.so';<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The act of loading a plugin shared library first registers the
library in the SciDB system catalogs. Then it opens and examines the
shared library to store its contents with SciDB's internal extension
management subsystem. Shared library module which are registered with
the SciDB instance will be loaded at system start time.</p>
<p> If you want to unload library run:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">--<br>-- AFL unload_library() operation<br>unload_library('libpoint1')<br><br>--<br>-- AQL 'unload library' syntax<br>unload library 'libpoint1'<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This command will unregister the library in the system catalog. The
library will not be loaded on consecutive restart, but it might not be
unloaded immediately because some queries can be using it.</p>
<h2 id="Tutorial:CreatingSciDBPlugins"><a name="16_6">Tutorial:
Creating SciDB Plugins</a></h2>
<p> This section explains the steps needed for creating a new plugin
for SciDB.</p>
<h3 id="DesigningyourUDT"><a name="16_6_1">Designing your UDT</a></h3>
<p> Your UDT will need the following kinds of UDFs.</p>
<ol>
  <li>UDFs that construct instances of your new type based on the
values of other types. In general the types you will use as input to
these UDFs will be built in types. For example, it is typical to use a
string as a source for a new data type's contents. For example, the
following UDF converts a string with a particular format into an
instance of a rational number UDT.</li>
</ol>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">//<br>// This is the struct used to store the data inside SciDB. <br>typedef struct<br>{<br>    int64_t num;<br>    int64_t denom;<br>} SciDB_Rational;<br><br>void str2Rational(const Value** args, Value* res, void*)<br>{<br>	int64_t n, d;<br>    SciDB_Rational* r = (SciDB_Rational*)res-&gt;data();<br><br>    if (sscanf(args[0]-&gt;getString(), "(%"PRIi64"/%"PRIi64")", &amp;n, &amp;d) != 2)<br>        throw PLUGIN_USER_EXCEPTION("librational", SCIDB_SE_UDO, RATIONAL_E_CANT_CONVERT_TO_RATIONAL)<br>            &lt;&lt; args[0]-&gt;getString();<br><br>	if ((0 == d) &amp;&amp; (0 == n))<br>		d = 1;<br>		<br>	boost::rational&lt;int64_t&gt;rp0(n, d);<br>	r-&gt;num   = rp0.numerator();<br>	r-&gt;denom = rp0.denominator();<br><br>}<br><br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Note that the "string to UDT" conversion function is particularly
important. type ( string ) -&gt; type is the UDF used by the load()
operation to bulk ingest data into SciDB.</p>
<ol start="2">
  <li>UDFs that convert your UDT back into a built-in type, or a number
of built-in types. In the case of the complex type, for example, you
can either write a UDF that composes the 16 bytes into a string, or
else a pair of UDFs that extract the real and imaginary portions of the
type.</li>
</ol>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">static void reComplex(const Value** args, Value* res, void*)<br>{<br>   Complex&amp; a = *(Complex*)args[0]-&gt;data();<br>   res-&gt;setDouble(a.re);<br>}<br><br>static void imComplex(const Value** args, Value* res, void*)<br>{<br>   Complex&amp; a = *(Complex*)args[0]-&gt;data();<br>   res-&gt;setDouble(a.im);<br>}<br><br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Remember that SciDB will not perform implicit casting. You need to
include these UDFs in any queries that pull these values out of
database.</p>
<ol start="3">
  <li>UDFs that perform common type operations, such as simple
arithmetic or relational operations will not need to support all
datatypes. While it makes sense to support the full set of relational
operators for a datatype that can be ordered (such as rational number),
a values in the complex domain cannot be ordered (for sorting, say).
All SciDB needs for ordering are two UDFs: one to return TRUE when two
type values are equal, and a second to return TRUE when one type is
less than another.</li>
</ol>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">void rationalLT(const Value** args, Value* res, void * v)<br>{<br>    SciDB_Rational* r0 = (SciDB_Rational*)args[0]-&gt;data();<br>    SciDB_Rational* r1 = (SciDB_Rational*)args[1]-&gt;data();<br><br>	check_zero ( r0 );<br>	check_zero ( r1 );<br><br>	boost::rational&lt;int64_t&gt;rp0(r0-&gt;num, r0-&gt;denom);<br>	boost::rational&lt;int64_t&gt;rp1(r1-&gt;num, r1-&gt;denom);<br><br>	if ( rp0 &lt; rp1 ) <br>        res-&gt;setBool(true);<br>	else<br>        res-&gt;setBool(false);<br>}<br><br>void rationalEQ(const Value** args, Value* res, void * v)<br>{<br>    SciDB_Rational* r0 = (SciDB_Rational*)args[0]-&gt;data();<br>    SciDB_Rational* r1 = (SciDB_Rational*)args[1]-&gt;data();<br><br>	check_zero ( r0 );<br>	check_zero ( r1 );<br><br>	boost::rational&lt;int64_t&gt;rp0(r0-&gt;num, r0-&gt;denom);<br>	boost::rational&lt;int64_t&gt;rp1(r1-&gt;num, r1-&gt;denom);<br><br>	if ( rp0 == rp1 ) <br>        res-&gt;setBool(true);<br>	else<br>        res-&gt;setBool(false);<br>}<br><br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<ol start="4">
  <li>UDFs that are necessary to support the integration of the UDT
with other facilities; aggregates like AVG(), MAX() and MIN(), for
example. MAX() and MIN() use the UDFs that order instance values. If
your type has a peculiar requirements for MAX() and MIN(), it might be
reasonable to add these UDFs.</li>
</ol>
<h3 id="ExceptionsandErrorHandling"><a name="16_6_2">Exceptions and
Error Handling</a></h3>
<p> Your UDFs will often need to check for errors and exceptions in
their code. In SciDB, we provide facilities to report to the SciDB
engine that your UDF has encountered an error, and what kind of error.
Doing this allows the SciDB engine to terminate the query and report
some useful status information to the log file. Errors and exceptions
are thrown using a macro USER_EXCEPTION( error_code, description :
string ).</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">    throw PLUGIN_USER_EXCEPTION(&lt;plugin name&gt;, SCIDB_SE_UDO, \<br>    &lt;plugin error code&gt;) &lt;&lt; &lt;args&gt;;<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> For example,</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">void str2Rational(const Value** args, Value* res, void*)<br>{<br>	int64_t n, d;<br>    SciDB_Rational* r = (SciDB_Rational*)res-&gt;data();<br><br>    if (sscanf(args[0]-&gt;getString(), "(%"PRIi64"/%"PRIi64")", &amp;n, &amp;d) != 2)<br>        throw PLUGIN_USER_EXCEPTION("librational", SCIDB_SE_UDO, RATIONAL_E_CANT_CONVERT_TO_RATIONAL)<br>            &lt;&lt; args[0]-&gt;getString();<br><br>	if ((0 == d) &amp;&amp; (0 == n))<br>		d = 1;<br>		<br>	boost::rational&lt;int64_t&gt;rp0(n, d);<br>	r-&gt;num   = rp0.numerator();<br>	r-&gt;denom = rp0.denominator();<br><br>}<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> For a full list of the terse error codes that you can throw from
within a UDF, consult the '~/include/system/ErrorCodes.h' file.</p>
<h3 id="RegisteringYourCFunctionsasUDFs"><a name="16_6_3">Registering
Your 'C' Functions as UDFs</a></h3>
<p> Once you have implemented your functions, you should register them
with the SciDB facilities for extracting information from a shared
library. The SciDB install provides a set of 'C' macros to do this.
These macros are:</p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <td><strong>Macro Name</strong></td>
      <td><em>Description<strong></strong> </em></td>
      <td>Example<strong></strong></td>
    </tr>
    <tr>
      <td>REGISTER_TYPE ( name, length )</td>
      <td>Instructs SciDB to register a new UDT in it's catalogs with
the name provided (note that this argument to the macro is not a
string) and the length, in bytes, of the type instance values.</td>
      <td>REGISTER_TYPE ( complex, 16 )</td>
    </tr>
    <tr>
      <td>REGISTER_FUNCTION ( name, input argument types, output
argument type, function pointer)</td>
      <td>Instructs SciDB to register a new UDF in its catalogs. The
new UDF can be called in AQL or AFL using the first argument name
(again, not a string), the the function is expected to take a list of
argument types as input, and return a value of the type provided. The
actual reference to the function you want SciDB to call is the last
argument to the macro.</td>
      <td>REGISTER_FUNCTION(+, ("complex", "complex"), "complex",
addComplex);</td>
    </tr>
    <tr>
      <td>REGISTER_CONVERTER(input type, output type, conversion cost,
function pointer)</td>
      <td>From time to time SciDB needs to convert types, and it can
require UDFs to perform this operation. This macro is how you register
conversions.</td>
      <td>REGISTER_CONVERTER(string, complex, EXPLICIT_CONVERSION_COST,
string2complex);</td>
    </tr>
  </tbody>
</table>
<h3 id="ASimpleRecipe"><a name="16_6_4">A Simple Recipe</a></h3>
<p> The simplest way to implement your own plugin library is to copy
the style of the examples.</p>
<ol>
  <li>Create a new directory in parallel to the one that implements one
of the examples, say the complex type.</li>
</ol>
<p> In the ~/examples/CMakeLists.txt file, add new line with name of
new directory. Let's say the new directory is named "point1"</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">add_subdirectory("complex")   &lt;-- already exists.<br>add_subdirectory("point1")       &lt;-- the reference to your new plugin directory<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> At this point you will want to rename <tt>point1/complex.cpp</tt>
to something more appropriate for the purposes of the library.</p>
<ol start="2">
  <li>Change the contents of the new <tt>~/examples/point1/CMakeLists.txt</tt>
file to get the server to build your new plugin library.</li>
</ol>
<ol start="3">
  <li>Make your modifications in the new source code file: <tt>
~/examples/point1/point.cpp</tt>.</li>
</ol>
<ol start="4">
  <li>Using "make", build "libpoint1.so". It will be placed into the
plugins directory folder alongside "libcomplex.so".</li>
</ol>
<ol start="5">
  <li>Load your new library module.</li>
</ol>
<h2 id="User-DefinedOperators"><a name="16_7">User-Defined Operators</a></h2>
<p> The most complicated user-defined objects are user-defined
operators. Every operator in SciDB is a pair of objects:</p>
<ul>
  <li>A<em> logical operator</em> class, and</li>
  <li>A<em> physical operator</em> class.</li>
</ul>
<p> The main purpose of logical operator is:</p>
<ul>
  <li>to infer an array schema, and</li>
  <li>to provide information about expected inputs and parameters of
the operator.</li>
</ul>
<p> Ideally, the logical operator is common to every operator of the
same class. However, the logical operator can have several
implementations called<em> physical operators</em>. The main purpose of
physical operator to execute operator implementation.</p>
<p> Every operator, logical or physical, can have a<em> state</em>.
States are created by special factory methods. Every instance of an
operator is a new instance of the class. This means that you can add a
new field to inherited classes.</p>
<h3 id="CreatingaUser-DefinedOperator"><a name="16_7_1">Creating a
User-Defined Operator</a></h3>
<p> The easiest way to create a new operator is to find the closest
built-in operator, copy-and-paste it into a separate folder, and change
the existing implementation into the desired implementation.</p>
<p> In the <tt>example/operators</tt> directory in your SciDB build
you can find a stub example for creating a plugin with user-defined
operators. You can replace the example stubs by the built-in operator
implementation that is closest to what you want your new operator to do
and then rename internal classes and operator names.</p>
<p> The following sections provide short descriptions of base classes
for logical and physical operators and descriptive comments about class
members.</p>
<h4 id="LogicalOperatorExample">Logical Operator Example</h4>
<p> The logical operator must be inherit from the LogicalOperator class
and implement the methods constructor and inferSchema:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">class LogicalStub : public LogicalOperator<br>{<br>public:<br>    LogicalStub(const std::string&amp; logicalName, const std::string&amp; alias):<br>        LogicalOperator(logicalName, alias)<br>    {<br>        /**<br>         * See built-in operators implementation for example<br>         */<br>    }<br><br>    ArrayDesc inferSchema(std::vector&lt;ArrayDesc&gt; schemas, boost::shared_ptr&lt;Query&gt; query)<br>    {<br>        /**<br>         * See built-in operators implementation for example<br>         */<br>        return ArrayDesc();<br>    }<br><br>};<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The constructor contains code for the declaration of possible
inputs and parameters. For example, the APPLY operator has the
following constructor:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">    Apply(const std::string&amp; logicalName, const std::string&amp; alias):<br>        LogicalOperator(logicalName, alias)<br>    {<br>        _properties.tile = true;<br>        ADD_PARAM_INPUT()<br>        ADD_PARAM_OUT_ATTRIBUTE_NAME("void")//0<br>        ADD_PARAM_EXPRESSION("void")        //1<br>        ADD_PARAM_VARIES()<br>    }<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<ul>
  <li><tt>properties.tile</tt> is true if operator can work in tile
mode.</li>
  <li><tt>ADD_PARAM_INPUT()</tt> says that operator expects one more
input (in this case, an input array).</li>
  <li><tt>ADD_PARAM_OUT_ATTRIBUTE_NAME("void")</tt> says that the
operator will add new attribute with the given data type ("void" means
"any").</li>
  <li><tt>inferSchema</tt> will produce the real data types based on
input schema.</li>
  <li><tt>ADD_PARAM_EXPRESSION("void")</tt> says that operator expect
one expression with "any" ("void") data type. You may add other
attributes and attribute kinds as well.</li>
  <li><tt>ADD_PARAM_VARIES()</tt> means that APPLY can have a variable
number of parameters. In this case you need to implement one more
virtual method <tt>nextVaryParamPlaceholder</tt>. See the APPLY
implementation for example.</li>
  <li><tt>inferSchema</tt> provides the schema for resultant array.</li>
</ul>
<h4 id="Physicaloperators">Physical operators</h4>
<p> Physical operators must inherit from the PhysicalOperator class and
implement the <tt>execute</tt> method:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">class PhysicalStub: public PhysicalOperator<br>{<br>public:<br>    PhysicalStub(const std::string&amp; logicalName, const std::string&amp; physicalName,\<br>    const Parameters&amp; parameters, const ArrayDesc&amp; schema):<br>	    PhysicalOperator(logicalName, physicalName, parameters, schema)<br>	{<br>	}<br><br>    shared_ptr&lt;Array&gt; execute(std::vector&lt;shared_ptr&lt;Array&gt; &gt;&amp; inputArrays,\<br>    shared_ptr&lt;Query&gt; query)<br>	{<br>        /**<br>         * See built-in operators implementation for example<br>         */<br>        return shared_ptr&lt;Array&gt;();<br>	}<br>};<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> For example, here is the APPLY operator:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">    boost::shared_ptr&lt;Array&gt; execute(vector&lt; boost::shared_ptr&lt;Array&gt; &gt;&amp; inputArrays,\<br>    boost::shared_ptr&lt;Query&gt; query)<br>    {<br>        assert(inputArrays.size() == 1);<br>        assert(_parameters.size()%2 == 0);<br><br>        vector&lt;shared_ptr&lt;Expression&gt; &gt; expressions(0);<br><br>        size_t currentParam = 0;<br>        for(size_t i =0; i&lt; _schema.getAttributes().size(); i++)<br>        {<br>            assert(_parameters[currentParam]-&gt;getParamType() == PARAM_ATTRIBUTE_REF);<br>            assert(_parameters[currentParam+1]-&gt;getParamType() == PARAM_PHYSICAL_EXPRESSION);<br><br>            string const&amp; schemaAttName = _schema.getAttributes()[i].getName();<br>            string const&amp; paramAttName = \<br>            ((boost::shared_ptr&lt;OperatorParamReference&gt;&amp;)_parameters[currentParam])-&gt;\<br>            getObjectName();<br><br>            if(schemaAttName!=paramAttName)<br>            {<br>                expressions.push_back\<br>                ( shared_ptr&lt;Expression&gt; ());<br>            }<br>            else<br>            {<br>                expressions.push_back(((boost::shared_ptr&lt;OperatorParamPhysicalExpression&gt;&amp;)\<br>               _parameters[currentParam+1])-&gt;getExpression());<br>                currentParam+=2;<br>            }<br><br>            if(currentParam == _parameters.size())<br>            {<br>                for (size_t j = i+1; j&lt; _schema.getAttributes().size(); j++)<br>                {<br>                    expressions.push_back( shared_ptr&lt;Expression&gt; () );<br>                }<br>                break;<br>            }<br>        }<br><br>        assert(currentParam == _parameters.size());<br>        assert(expressions.size() == _schema.getAttributes().size());<br><br>        boost::shared_ptr&lt;Array&gt; input = inputArrays[0];<br>        return boost::shared_ptr&lt;Array&gt;(new ApplyArray(_schema, input, \<br>        expressions, query, _tileMode));<br>    }<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The <tt>execute()</tt> method takes a number of input arrays and
query context. It can use all methods of input arrays and perform any
evaluations. The result must be a new array instance.</p>
<p> It is also possible to create a pipelined array instance which will
perform evaluations only when data will be requested. For example, you
may want to evaluate a chunk only when the <tt>getChunk</tt> method is
called. ApplyArray in the above code is an example of such an array.</p>
<hr noshade="noshade">
<h1 id="Connectors"><a name="17">Connectors</a></h1>
<h2 id="SciDBClientAPIforPython"><a name="17_1">SciDB Client API for
Python</a></h2>
<p> SciDB uses an ODBC/JDBC like interface to connect to the SciDB
server and execute commands. This interface is available from multiple
computer languages. This page documents the Python version of the SciDB
API.</p>
<p> To get access to the API add the following to your Python file:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">import sys<br>sys.path.append('/opt/scidb/11.10/lib')  # or location appropriate to your installed version<br>import scidbapi as scidb<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> This imports the scidbapi module, scidbapi.py, which defines an
interface to scidb. This interface is implemented using several Python
and C++ libraries beneath it: libscidbpython.py (generated by the SWIG
compiler) contains python classes that are proxies for C++ classes,
_libscidbpython.so which was also generated by SWIG and provides some
of the conversion between the Python API and C++, and
libscidbclient.so, which implements the C++ remote client library for
SciDB.</p>
<p> You can then list information about the scidbapi module with the
Python statement:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">help(scidb)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<hr>
<h2 id="ExamplePythonApplication"><a name="17_2">Example Python
Application</a></h2>
<p> Two sample python applications are provided in the <tt>
/opt/scidb/11.12/share/scidb/examples/python</tt> directory of a server
installation. These are also located at src/capi/pythonexamples
directory of the SciDB sources, available to registered SciDB
developers. The example files are:</p>
<ul>
  <li>README</li>
  <li>sample.py is a program that creates and loads an array, executes
a select AQL statement, and drops the array.</li>
  <li>sample2.py takes in a list of afl/aql queries from a file (or
files) and executes them. This example shows the use of additional data
types and the empty flag for queries with filter predicates.</li>
  <li>simplearray.data is read by sample.py</li>
  <li>sample2.csv is read by sample2.py</li>
</ul>
<p> NOTE: You may find other contributed examples in the
src/capi/pythonexamples; however, they will not be given the level of
attention for maintaining correctness as sample.py and sample2.py and
may be written in older versions of the API.</p>
<p> NOTE: The python API will probably move to its own directory in the
source tree (out of the capi directory) in the near future.</p>
<hr>
<h2 id="Example:ConnectandExecuteaSimpleQuery"><a name="17_3">Example:
Connect and Execute a Simple Query</a></h2>
<p> You connect to SciDB using connect() and execute queries using
executeQuery(). Connect() takes a server address and the port number
for the SciDB coordinator.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">db = scidb.connect("localhost", 1239)<br># connect to the SciDB coordinator.<br>result = db.executeQuery("drop array simplearray", 'aql') <br># execute an AQL query<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> You then iterate over result to obtain the result data. See the
section on Array and Chunk Iterators, below.</p>
<hr>
<h2 id="CreateandLoadQueries"><a name="17_4">Create and Load Queries</a></h2>
<p><em> executeQuery (statement, type, result, handle)</em></p>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <th>Arg</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><em>statement</em></td>
      <td>Valid AQL or AFL statement.</td>
    </tr>
    <tr>
      <td><em>type</em></td>
      <td>scidb.AQL or scidb.AFL.</td>
    </tr>
    <tr>
      <td><em>result</em></td>
      <td style="text-align: left;">Each query requires a new
QueryResult structure on the client. QueryResult is described in the
section below on Data Access.</td>
    </tr>
    <tr>
      <td><em>handle</em></td>
      <td>connection handle</td>
    </tr>
  </tbody>
</table>
<p> The examples below show how to execute create and load queries.</p>
<p> Create an array<em> simplearray</em>.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">db.executeQuery("CREATE immutable ARRAY simplearray <br>     &lt; foo:int32, bar:char, baz:string &gt; [row=0:99,10,0, col=0:9,10,0]", "aql")<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Load data into this array. The data file must be visible on the
server's file system. A relative path to the file will be interpreted
relative to the working directory of the server. This will be
appropriate if the data were saved from the same server. In other
cases, it may be more appropriate to use an absolute path to files to
be loaded.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">db.executeQuery("load simplearray from 'simplearray.data'", "AQL")<br>db.executeQuery("select * from simplearray", "AQL")<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<hr>
<h2 id="DataAccess"><a name="17_5">Data Access</a></h2>
<h3 id="QueryResult"><a name="17_5_1">Query Result</a></h3>
<p> Accessing the schema of the result set is performed through a set
of python objects accessible through the QueryResult.</p>
<p> Use the following help commands to get more information</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">help(scidb.swig.QueryResult)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<blockquote>
  <table class="wiki" border="1" width="100%">
    <tbody>
      <tr>
        <th>Arg</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>array</td>
        <td>Handle to the array object, its iterators and descriptors
returned by the server.</td>
      </tr>
      <tr>
        <td>queryID</td>
        <td>Query ID as known to the server. It is valid after the
successful execution of a statement and may not be re-used.</td>
      </tr>
      <tr>
        <td>selective</td>
        <td>Indicates if a data retrieval command was executed.</td>
      </tr>
      <tr>
        <td>executionTime</td>
        <td>Execution time of this query.</td>
      </tr>
      <tr>
        <td>explainLogical</td>
        <td>Logical plan used.</td>
      </tr>
      <tr>
        <td>explainPhysical</td>
        <td>Physical plan used.</td>
      </tr>
    </tbody>
  </table>
</blockquote>
<h3 id="ArrayAttributeandDimensionDescriptors"><a name="17_5_2">Array,
Attribute, and Dimension Descriptors</a></h3>
<p> Additional information such as the dimensions and attributes of the
result array are accessible from objects in the array. For more
information use help on the following classes:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">help(scidb.swig.ArrayDesc)<br>help(scidb.swig.AttributeDesc)<br>help(scidb.swig.DimensionDesc)<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="ArrayandChunkIterators"><a name="17_5_3">Array and Chunk
Iterators</a></h3>
<p> The data access API is based on the nested array data model of
SciDB.</p>
<p> A SciDB array is returned to the caller as a collection of<em>
chunks</em> that together represent the array. Array and chunk
iterators must be used to scan all cells of the array.</p>
<p> Each attribute of the array can be accessed using a separate set of
iterators. Attribute iteration is done at two levels: an outer
iteration of chunks of the array and an iteration of cells in a chunk.
The array iterator iterates over the chunks in dimension major order,
as does the chunk iterator. That is to say that both arrays and chunks
are multidimensional and data is returned in first to last dimension
order (e.g., row-major order for a 2d array).</p>
<p> The data access API includes the following objects.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">Array<br>ArrayDesc<br>AttributeDesc<br>DimensionDesc <br>ConstArrayIterator<br>ConstChunkIterator<br>ConstChunk<br>Coordinates<br>Value<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> The following example shows how to iterate over all chunks of an
array, and all elements of each chunk.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">    chunkiters = []<br>    for i in range(attrs.size()):<br>        nc = -1<br>        while not iters[i].end():<br>            nc += 1<br>            chunkiter = iters[i].getChunk().getConstIterator(<br>                 (scidb.swig.ConstChunkIterator.IGNORE_EMPTY_CELLS |<br>                  scidb.swig.ConstChunkIterator.IGNORE_OVERLAPS))<br>            print "Chunk iterator %d loaded." % nc<br>            <br>            while not chunkiter.end():<br>                dataitem = chunkiter.getItem()<br><br>                item = scidb.getTypedValue(dataitem, attrs[i].getType()) <br>                # generate the right type of python object<br><br>                print "Data: %s" % item<br><br>           iters[i].increment_to_next();<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h3 id="Items"><a name="17_5_4">Items</a></h3>
<p> Each<em> dataitem</em> returned by the iterator requires a
different internal method to retrieve it. Determining that method
requires examining the type of its attribute, which can be found by
calling AttributeDesc.getType(). If you are using a built-in type, then
there is a utility function that will call the per-type for you and
return and object of the correct type. For example:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">    scidb.getTypedValue(dataItem, attrs[i].getType()) <br>    # attrs is a per-attribute array of AttributeDesc<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> Special methods are available to detect if an element (or array
position) has special significance, such as:</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">dataitem.isEmpty()<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<h2 id="Cleanup"><a name="17_6">Cleanup</a></h2>
<p> A query previously started may be canceled using cancelQuery(). See
above for a description of the query ID.</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">db.cancelQuery(queryID) # queryID is in the queryResult class<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> And the client can disconnect from the server using</p>
<center>
<table border="1" bordercolor="#d7d7d7" width="95%" align="center">
  <tbody>
    <tr>
      <td bgcolor="#f7f7f7">
      <pre class="wiki">db.disconnect()<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</center>
<p> which will also be called when the db object is deleted (typically
by garbage collection). In order to be sure the connection resources
are recycled for use by the SciDB server, its probably smart to call
db.disconnect() explicitly, rather than waiting for garbage collection
to delete the db object at some indeterminate point in the future.</p>
<h2 id="ExceptionHandling"><a name="17_7">Exception Handling</a></h2>
<p> If the connector encounters an error, or if the server returns an
error during query execution an exception is raised to the python
application. These exceptions may be handled using the standard python
try/except mechanism.</p>
<hr noshade="noshade">
<h1 id="Appendix:AlphabeticalListofAFLOperators"><a name="18">Appendix:
Alphabetical List of AFL Operators</a></h1>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <th> Operator Name</th>
      <th> Description</th>
      <th> Category</th>
    </tr>
    <tr>
      <td> adddim</td>
      <td> Add one dimension</td>
      <td> Creating an Array</td>
    </tr>
    <tr>
      <td> aggregate</td>
      <td> Compute a single result from an array dimension</td>
      <td> Sorting, Windowing, and Aggregating</td>
    </tr>
    <tr>
      <td> allversions</td>
      <td> Show all array versions</td>
      <td> Namespace</td>
    </tr>
    <tr>
      <td> apply</td>
      <td> Compute new values from array attribute and index values</td>
      <td> Basic Array Operations</td>
    </tr>
    <tr>
      <td> attribute_rename</td>
      <td> Change the name of an array attribute</td>
      <td> Changing Array Schemas</td>
    </tr>
    <tr>
      <td> attributes</td>
      <td> List array attributes</td>
      <td> Namespace</td>
    </tr>
    <tr>
      <td> avg</td>
      <td> Average of a set of array indexes or attributes</td>
      <td> Sorting, Windowing, and Aggregating</td>
    </tr>
    <tr>
      <td> bernoulli</td>
      <td> Use Bernoulli sampling to select a set of cells from an array</td>
      <td> Data Sampling</td>
    </tr>
    <tr>
      <td> between</td>
      <td> Select data from a specified region</td>
      <td> Sampling</td>
    </tr>
    <tr>
      <td> build</td>
      <td> Build array data</td>
      <td> Basic Array Operations</td>
    </tr>
    <tr>
      <td> build_sparse</td>
      <td> Build sparse array data</td>
      <td> Basic Array Operations</td>
    </tr>
    <tr>
      <td> cancel</td>
      <td> Cancel a query</td>
      <td> Internal</td>
    </tr>
    <tr>
      <td> cast</td>
      <td> Change attribute or dimension names</td>
      <td> Changing Array Schemas</td>
    </tr>
    <tr>
      <td> concat</td>
      <td> Concatenate two arrays</td>
      <td> Combining Arrays</td>
    </tr>
    <tr>
      <td> count</td>
      <td> Nonempty array cells</td>
      <td> Sorting, Aggregating, and Windowing</td>
    </tr>
    <tr>
      <td> create array</td>
      <td> Create SciDB array</td>
      <td> Creating an Array</td>
    </tr>
    <tr>
      <td> cross</td>
      <td> Cross product join</td>
      <td> Combining Arrays</td>
    </tr>
    <tr>
      <td> cross_join</td>
      <td> Cross product join with equality predicates</td>
      <td> Combining Arrays</td>
    </tr>
    <tr>
      <td> deldim</td>
      <td> Delete one dimension</td>
      <td> Changing Array Schemas</td>
    </tr>
    <tr>
      <td> dimensions</td>
      <td> Show array dimensions</td>
      <td> Namespace</td>
    </tr>
    <tr>
      <td> diskinfo</td>
      <td> Show space available on SciDB disk</td>
      <td> Internal</td>
    </tr>
    <tr>
      <td> echo</td>
      <td> Print a string</td>
      <td> Internal</td>
    </tr>
    <tr>
      <td> explain_logical</td>
      <td> Explain how the logical structure of a query will be enacted</td>
      <td> Internal</td>
    </tr>
    <tr>
      <td> explain_physical</td>
      <td> Explain how the physical structure of a query will be enacted</td>
      <td> Internal</td>
    </tr>
    <tr>
      <td> filter</td>
      <td> Select by Boolean expression</td>
      <td> Data Sampling</td>
    </tr>
    <tr>
      <td> help</td>
      <td> Operator signature</td>
      <td> Namespace</td>
    </tr>
    <tr>
      <td> input</td>
      <td> Read a file from the system</td>
      <td> Loading and Updating</td>
    </tr>
    <tr>
      <td> inverse</td>
      <td> Matrix inverse</td>
      <td> Matrix Algebra</td>
    </tr>
    <tr>
      <td> join</td>
      <td> Combine attributes by dimension value</td>
      <td> Combining Arrays</td>
    </tr>
    <tr>
      <td> list</td>
      <td> List database contents</td>
      <td> Namespace</td>
    </tr>
    <tr>
      <td> load</td>
      <td> Load data into existing array</td>
      <td> Loading and Updating</td>
    </tr>
    <tr>
      <td> load_library</td>
      <td> Load a plugin</td>
      <td> System Administration</td>
    </tr>
    <tr>
      <td> lookup</td>
      <td> Select data by pattern</td>
      <td> Data Sampling</td>
    </tr>
    <tr>
      <td> max</td>
      <td> Maximum of a set of array indexes or attributes</td>
      <td> Sorting, Windowing, and Aggregating</td>
    </tr>
    <tr>
      <td> merge</td>
      <td> Merge array attributes</td>
      <td> Combining arrays</td>
    </tr>
    <tr>
      <td> min</td>
      <td> Minimum of a set of array indexes or attributes</td>
      <td> Sorting, Windowing, and Aggregating</td>
    </tr>
    <tr>
      <td> multiply</td>
      <td> Matrix multiply</td>
      <td> Matrix algebra</td>
    </tr>
    <tr>
      <td> normalize</td>
      <td> Normalize vector values</td>
      <td> Matrix algebra</td>
    </tr>
    <tr>
      <td> project</td>
      <td> Display attribute values</td>
      <td> Basic Array Operations</td>
    </tr>
    <tr>
      <td> redimension</td>
      <td> Transform attributes to dimensions</td>
      <td> Changing Array Schemas</td>
    </tr>
    <tr>
      <td> redimension_store</td>
      <td> Transform attributes to dimensions</td>
      <td> Change array schema</td>
    </tr>
    <tr>
      <td> reduce_distro</td>
      <td> Reduce distribution</td>
      <td> Internal</td>
    </tr>
    <tr>
      <td> regrid</td>
      <td> Compute aggregates for a sub-grid</td>
      <td> Sort, Window, and Aggregate</td>
    </tr>
    <tr>
      <td> remove</td>
      <td> Remove array from SciDB instance</td>
      <td> Creating an Array</td>
    </tr>
    <tr>
      <td> rename</td>
      <td> Rename array</td>
      <td> Creating an Array</td>
    </tr>
    <tr>
      <td> repart</td>
      <td> Change array chunk size</td>
      <td> Changing Array Schemas</td>
    </tr>
    <tr>
      <td> reshape</td>
      <td> Change array dimension size</td>
      <td> Changing Array Schemas</td>
    </tr>
    <tr>
      <td> reverse</td>
      <td> Reverse dimension values</td>
      <td> Changing Array Schemas</td>
    </tr>
    <tr>
      <td> sample</td>
      <td> Select subset of data at random</td>
      <td> Data Sampling</td>
    </tr>
    <tr>
      <td> save</td>
      <td> Save array data to file</td>
      <td> Loading and Updating</td>
    </tr>
    <tr>
      <td> scan</td>
      <td> Print attributes</td>
      <td> Basic Array Operations</td>
    </tr>
    <tr>
      <td> setopt</td>
      <td> Set/get configuration option value at runtime</td>
      <td> Internal</td>
    </tr>
    <tr>
      <td> sg</td>
      <td> Scatter or gather an array</td>
      <td> Internal</td>
    </tr>
    <tr>
      <td> show</td>
      <td> Print array format</td>
      <td> Namespace</td>
    </tr>
    <tr>
      <td> slice</td>
      <td> Select subplane from array</td>
      <td> Data Sampling</td>
    </tr>
    <tr>
      <td> sort</td>
      <td> Sort attribute values</td>
      <td> Sorting, Windowing, and Aggregating</td>
    </tr>
    <tr>
      <td> sort2</td>
      <td> Sort</td>
      <td> Internal</td>
    </tr>
    <tr>
      <td> stdev</td>
      <td> Standard deviation</td>
      <td> Sorting, Windowing, and Aggregating</td>
    </tr>
    <tr>
      <td> store</td>
      <td> Write array to memory</td>
      <td> Loading and Updating</td>
    </tr>
    <tr>
      <td> subarray</td>
      <td> Select by dimension range</td>
      <td> Data Sampling</td>
    </tr>
    <tr>
      <td> substitute</td>
      <td> Substitute null values</td>
      <td> Loading and Updating</td>
    </tr>
    <tr>
      <td> sum</td>
      <td> Sum</td>
      <td> Sorting, Windowing, and Aggregating</td>
    </tr>
    <tr>
      <td> thin</td>
      <td> Select elements from array dimension</td>
      <td> Data Sampling</td>
    </tr>
    <tr>
      <td> transpose</td>
      <td> Transpose array dimension</td>
      <td> Changing Array Schemas</td>
    </tr>
    <tr>
      <td> unload_library</td>
      <td> Remove library from SciDB instance</td>
      <td> System Administration</td>
    </tr>
    <tr>
      <td> unpack</td>
      <td> Reduce multidimensional array to 1 dimension</td>
      <td> Changing Array Schemas</td>
    </tr>
    <tr>
      <td> var</td>
      <td> Variance</td>
      <td> Sorting, Windowing, and Aggregating</td>
    </tr>
    <tr>
      <td> versions</td>
      <td> Show array versions</td>
      <td> Namespace</td>
    </tr>
    <tr>
      <td> window</td>
      <td> Compute window aggregates</td>
      <td> Sorting, Windowing, and Aggregating</td>
    </tr>
    <tr>
      <td> xgrid</td>
      <td> Expand element into grid</td>
      <td> Changing Array Schemas</td>
    </tr>
  </tbody>
</table>
<hr noshade="noshade">
<h1 id="Appendix:AlphabeticalListofSciDBFunctions"><a name="19">Appendix:
Alphabetical
List
of
SciDB
Functions</a></h1>
<table class="wiki" border="1" width="100%">
  <tbody>
    <tr>
      <th> Function Name</th>
      <th> Description</th>
      <th> Category</th>
    </tr>
    <tr>
      <td> %</td>
      <td> Remainder</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> *</td>
      <td> Multiplication</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> +</td>
      <td> Addition</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> -</td>
      <td> Subtraction</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> /</td>
      <td> Division</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> &lt;</td>
      <td> Less than</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> &lt;=</td>
      <td> Less than or equal</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> &lt;&gt;</td>
      <td> Not equal</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> =</td>
      <td> Equals</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> &gt;</td>
      <td> Greater than</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> &gt;=</td>
      <td> Greater than or equal</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> abs</td>
      <td> Absolute value</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> acos</td>
      <td> Inverse (arc) cosine in radians</td>
      <td> Transcendental</td>
    </tr>
    <tr>
      <td> and</td>
      <td style="text-align: right;"> Boolean AND</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> append_offset</td>
      <td> Change time and date by a given amount</td>
      <td> Timestamp</td>
    </tr>
    <tr>
      <td> apply_offset</td>
      <td> Change time and date by a given amount</td>
      <td> Timestamp</td>
    </tr>
    <tr>
      <td> asin</td>
      <td> Inverse (arc) sine in radians</td>
      <td> Transcendental</td>
    </tr>
    <tr>
      <td> atan</td>
      <td> Inverse (arc) tangent in radians</td>
      <td> Transcendental</td>
    </tr>
    <tr>
      <td> ceil</td>
      <td> Round to next-highest integer</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> cos</td>
      <td> Cosine (input in radians)</td>
      <td> Transcendental</td>
    </tr>
    <tr>
      <td> exp</td>
      <td> Exponential</td>
      <td> Transcendental</td>
    </tr>
    <tr>
      <td> first</td>
      <td> Start of string</td>
      <td> Strings</td>
    </tr>
    <tr>
      <td> floor</td>
      <td> Round to next-lowest integer</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> get_offset</td>
      <td> Returns time offset in seconds</td>
      <td> Timestamp</td>
    </tr>
    <tr>
      <td> high</td>
      <td> String information</td>
      <td> Strings</td>
    </tr>
    <tr>
      <td> iif</td>
      <td> Inline IF</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> is_nan</td>
      <td> Returns TRUE is attribute value is NaN</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> is_null</td>
      <td> Returns TRUE is attribute value is null</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> last</td>
      <td> End of string</td>
      <td> String</td>
    </tr>
    <tr>
      <td> length</td>
      <td> Get string length</td>
      <td> String</td>
    </tr>
    <tr>
      <td> log</td>
      <td> Base-e logarithm</td>
      <td> Transcendental</td>
    </tr>
    <tr>
      <td> log10</td>
      <td> Base-10 logarithm</td>
      <td> Transcendental</td>
    </tr>
    <tr>
      <td> low</td>
      <td> String query</td>
      <td> String</td>
    </tr>
    <tr>
      <td> nodeid</td>
      <td> Return node id</td>
      <td> Troubleshooting</td>
    </tr>
    <tr>
      <td> not</td>
      <td> Boolean NOT</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> now</td>
      <td> Current array version</td>
      <td> Timestamp</td>
    </tr>
    <tr>
      <td> or</td>
      <td> Boolean OR</td>
      <td> Logical</td>
    </tr>
    <tr>
      <td> pow</td>
      <td> Raise to a power</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> random</td>
      <td> Random number</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> regex</td>
      <td> Search for regular expression</td>
      <td> Strings</td>
    </tr>
    <tr>
      <td> sin</td>
      <td> Sine (input in radians)</td>
      <td> Transcendental</td>
    </tr>
    <tr>
      <td> sqrt</td>
      <td> Square root</td>
      <td> Arithmetic</td>
    </tr>
    <tr>
      <td> strchar</td>
      <td> Convert string to char</td>
      <td> Datatype conversion</td>
    </tr>
    <tr>
      <td> strftime</td>
      <td> Convert string to datetime</td>
      <td> Datatype conversion</td>
    </tr>
    <tr>
      <td> strip_offset</td>
      <td> disregards OFFSET and returns result as a DATETIME</td>
      <td> Timestamp</td>
    </tr>
    <tr>
      <td> strlen</td>
      <td> Maximum string length</td>
      <td> Strings</td>
    </tr>
    <tr>
      <td> substr</td>
      <td> Select substring</td>
      <td> Strings</td>
    </tr>
    <tr>
      <td> tan</td>
      <td> Tangent (input in radians)</td>
      <td> Transcendental</td>
    </tr>
    <tr>
      <td> togmt</td>
      <td> Switch to GMT from current time zone setting</td>
      <td> Timestamp</td>
    </tr>
    <tr>
      <td> tznow</td>
      <td> Set time zone</td>
      <td> Timestamp</td>
    </tr>
  </tbody>
</table>
</body>
</html>
